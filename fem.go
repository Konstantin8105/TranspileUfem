//
//	Package - transpiled by c4go
//
//	If you have found any issues, please raise an issue at:
//	https://github.com/Konstantin8105/c4go/
//

package main

// #include </home/konstantin/go/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr3.c>
import "C"

import "fmt"
import "os"
import "math"
import "unsafe"
import "github.com/Konstantin8105/c4go/noarch"

// _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_math_h_47 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.h:47
//
//   File name: fem_math.h
//   Date:      2003/04/12 12:45
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Software - matrix library - header file
//
//	 $Id: fem_math.h,v 1.21 2005/07/11 17:56:16 jirka Exp $
//
type _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_math_h_47 struct {
	type_   int32
	rows    int32
	cols    int32
	len_    int32
	pos     []int32
	data    []float64
	frompos []int32
	defpos  []int32
}

// tMatrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.h:47
type tMatrix = _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_math_h_47

// _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_math_h_60 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.h:60
// 0 = dense; 1 = sparse (rows)
// lenght of "pos" and "data" (if used) fields
// from in "pos" and "data" - sparse only sizeof(frompos) = rows
// number in "pos" and "data" - sparse only
type _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_math_h_60 struct {
	type_ int32
	rows  int32
	len_  int32
	pos   []int32
	data  []float64
}

// tVector - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.h:60
type tVector = _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_math_h_60

// _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_mat_h_83 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mat.h:83
//
//   File name: fem_mat.h
//   Date:      2003/04/16 20:37
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - material definition - header file
//
//  $Id: fem_mat.h,v 1.7 2004/11/11 21:39:24 jirka Exp $
//
// Included headers:
// DOF type definitions:
// structure for finite element
type _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_mat_h_83 struct {
	type_  int32
	val    []int32
	num    int32
	val_rp []int32
	num_rp int32
	test   func(int32) int32
}

// tMat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mat.h:83
type tMat = _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_mat_h_83

// _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_spnt_h_45 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.h:45
//
//   File name: fem_spnt.h
//   Date:      2003/06/08 16:50
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - routines to save results in selected points (for NRM etc.)
//
//	 $Id: fem_spnt.h,v 1.1 2003/09/14 20:36:59 jirka Exp $
//
// structure for saved values
type _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_spnt_h_45 struct {
	mult   float64
	x      float64
	y      float64
	z      float64
	unused int32
}

// tSaPo - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.h:45
type tSaPo = _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_spnt_h_45

// _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_elem_h_82 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_elem.h:82
//
//   File name: fem_elem.h
//   Date:      2003/04/09 10:27
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - element definition - header file
//
//  $Id: fem_elem.h,v 1.16 2005/07/11 17:56:16 jirka Exp $
//
// Included headers:
//
//   File name: fem_elem.h
//   Date:      2003/04/09 10:27
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - element definition - header file
//
//  $Id: fem_elem.h,v 1.16 2005/07/11 17:56:16 jirka Exp $
//
type _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_elem_h_82 struct {
	type_     int32
	dim       int32
	nodes     int32
	dofs      int32
	ndof      []int32
	rs        int32
	real_     []int32
	rs_rp     int32
	real_rp   []int32
	res       int32
	nres      []int32
	res_rp    int32
	nres_rp   []int32
	stiff     func(int32, int32, []tMatrix, []tVector, []tVector) int32
	therm     func(int32, []int32, []tVector, []tVector) int32
	mass      func(int32, []tMatrix) int32
	rvals     func(int32) int32
	eload     func(int32, int32, []tVector) int32
	res_p_loc func(int32, int32, []float64, []float64, []float64) int32
	res_node  func(int32, int32, int32, []float64) int32
	volume    func(int32, []float64) int32
}

// tElem - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_elem.h:82
type tElem = _struct_at_GOPATH_src_github_com_Konstantin8105_TranspileUfem_ufem_fem_fem_elem_h_82

// femFindIntVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:37
func femFindIntVal(val int32, fld []int32, fldLen int32) int32 {
	//
	//   File name: fem_accs.c
	//   Date:      2003/04/07 17:33
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solve - data access
	//
	//  $Id: fem_accs.c,v 1.16 2005/01/16 22:59:31 jirka Exp $
	//
	// returnes position of value "val" in field (or -1 if not found)
	// * @param val value
	// * @param fld field to be searched
	// * @param fldLen lenght of "fld"
	// * @return first position of value of -1
	//
	var retVal int32 = -1
	var i int32
	for i = 0; i < fldLen; i++ {
		if fld[i] == val {
			retVal = fld[i]
			break
		}
	}
	return retVal
}

// femGetIntPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:60
func femGetIntPos(pos int32, fld []int32, fldLen int32) int32 {
	// gets LONG node value from position
	// * @param pos node position in field
	// * @param fld field
	// * @param fldLen lenght of field
	// * @return value
	//
	var coordVal int32
	if pos < fldLen {
		coordVal = fld[pos]
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s: %li\n\x00"), []byte("Out of range\x00"), pos)
	}
	return coordVal
}

// femGetDblPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:83
func femGetDblPos(pos int32, fld []float64, fldLen int32) float64 {
	// gets DOUBLE node value from position
	// * @param pos node position in field
	// * @param fld field
	// * @param fldLen lenght of field
	// * @return value
	//
	var coordVal float64
	if pos < fldLen {
		coordVal = fld[pos]
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s: %li\n\x00"), []byte("Out of range\x00"), pos)
	}
	return coordVal
}

// femGetIntLPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:109
func femGetIntLPos(pos int32, val_pos int32, from_fld []int32, fldL []int32, fldLLen int32) int32 {
	// returns "long" value from fldL field
	// * @param pos position if fld_from (e.g. "row" in table)
	// * @param val_pos position of value (e.g. "collumn" - from 0)
	// * @param  from_fld field with starts in fldL
	// * @param  fldL acessed field
	// * @param  fldLen lenght of access field
	// * @return value (-1 on error)
	//
	var pos_val int32 = -1
	var ind int32
	ind = from_fld[pos] + val_pos
	if ind >= fldLLen {
		noarch.Fprintf(msgout, []byte("[E] %s\n!\x00"), []byte("index out of field\x00"))
		return pos_val
	}
	pos_val = fldL[ind]
	return pos_val
}

// femGetDblLPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:138
func femGetDblLPos(pos int32, val_pos int32, from_fld []int32, fldL []float64, fldLLen int32) float64 {
	// returns "double" value from fldL field
	// * @param pos position if fld_from (e.g. "row" in table)
	// * @param val_pos position of value (e.g. "collumn" - from 0)
	// * @param  from_fld field with starts in fldL
	// * @param  fldL acessed field
	// * @param  fldLen lenght of access field
	// * @return value (-1 on error)
	//
	var pos_val float64 = float64(-1)
	var ind int32
	ind = from_fld[pos] + val_pos
	if ind >= fldLLen {
		noarch.Fprintf(msgout, []byte("[E] %s\n!\x00"), []byte("index out of field\x00"))
		return pos_val
	}
	pos_val = fldL[ind]
	return pos_val
}

// femFldItemLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:165
func femFldItemLen(Pos int32, fldFrom []int32, fldLen int32, fldLenL int32) int32 {
	// computes number of items pointed by starting point if fldFrom[fldLen]
	// * @param Pos position of line to compute
	// * @param fldFrom wield with starting positions
	// * @param fldLen length of fldFrom field
	// * @return computed lenth (number >= 0)
	//
	var len_ int32
	if Pos < 0 {
		return 0
	}
	if Pos+1 >= fldLen {
		len_ = fldLenL - fldFrom[Pos]
	} else {
		len_ = fldFrom[Pos+1] - fldFrom[Pos]
	}
	return len_
}

// femGetRepVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:196
func femGetRepVal(pos int32, valType int32, repNum int32, SetL []float64, SetLenL int32, SetFrom []int32, SetLen int32, valList []int32, valLen int32, valListRP []int32, valLenRP int32) (c4goDefaultReturn float64) {
	// Gets value from  non/repeating data set
	// * @param pos pos of line in SetFrom
	// * @param valType type of data
	// * @param repeat if value is in "repeating" part (AF_YES of AF_NO)
	// * @param repNum set number for repeatable data (1,2,3,n !!)
	// * @param SetL field with values
	// * @param SetLenL lenth of SetL
	// * @param SetFrom starts in SetL
	// * @param SetLen lenth of SetFrom
	// * @param valList list of possible values
	// * @param valLen lenth of valList
	// * @param valListRP list of possible repeating values
	// * @param valLenRP lenth of valListRP
	// * @return value
	//
	var val float64
	var i int32
	var repeat int32 = 1
	var i_pos int32 = -1
	var len_ int32
	if pos >= SetLen {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Value outside field requested\x00"))
		return float64(0)
	}
	if repNum <= 0 {
		repeat = 0
	}
	len_ = femFldItemLen(pos, SetFrom, SetLen, SetLenL)
	if repeat == 0 {
		{
			// non-repeating
			for i = 0; i < valLen; i++ {
				if valType == valList[i] {
					i_pos = i
					break
				}
			}
		}
		if i_pos == -1 {
			noarch.Fprintf(msgout, []byte("[E] %s (%li) %s!\n\x00"), []byte("Requested asked non-repeating value\x00"), valType, []byte("is invalid\x00"))
			return float64(0)
		}
	} else {
		{
			// repeating
			for i = 0; i < valLenRP; i++ {
				if valType == valListRP[i] {
					i_pos = i + valLenRP*(repNum-1) + valLen
					break
				}
			}
		}
		if i_pos == -1 {
			noarch.Fprintf(msgout, []byte("[E] %s (%li) %s!\n\x00"), []byte("Requested asked repeating value\x00"), valType, []byte("is invalid\x00"))
			return float64(0)
		}
	}
	if i_pos >= len_ {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Value outside field requested - program error\x00"))
		noarch.Fprintf(msgout, []byte("[E] %s (%li>%li)(%li|%li|%li)!\n\x00"), []byte("Value outside field requested - program error\x00"), i_pos, len_, pos, valType, repNum)
		return float64(0)
	} else {
		val = SetL[SetFrom[pos]+i_pos]
		return val
	}
	return
}

// femGetRepValIndex - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:297
func femGetRepValIndex(pos int32, valType int32, repNum int32, SetL []float64, SetLenL int32, SetFrom []int32, SetLen int32, valList []int32, valLen int32, valListRP []int32, valLenRP int32) (c4goDefaultReturn int32) {
	// -----------------------------------
	// Gets index of the non/repeating data
	// * @param pos pos of line in SetFrom
	// * @param valType type of data
	// * @param repeat if value is in "repeating" part (AF_YES of AF_NO)
	// * @param repNum set number for repeatable data (1,2,3,n !!)
	// * @param SetL field with values
	// * @param SetLenL lenth of SetL
	// * @param SetFrom starts in SetL
	// * @param SetLen lenth of SetFrom
	// * @param valList list of possible values
	// * @param valLen lenth of valList
	// * @param valListRP list of possible repeating values
	// * @param valLenRP lenth of valListRP
	// * @return value
	//
	var index int32
	var i int32
	var repeat int32 = 1
	var i_pos int32 = -1
	var len_ int32
	if pos >= SetLen {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Value outside field requested\x00"))
		return -1
	}
	if repNum <= 0 {
		repeat = 0
	}
	len_ = femFldItemLen(pos, SetFrom, SetLen, SetLenL)
	if repeat == 0 {
		{
			// non-repeating
			for i = 0; i < valLen; i++ {
				if valType == valList[i] {
					i_pos = i
					break
				}
			}
		}
		if i_pos == -1 {
			noarch.Fprintf(msgout, []byte("[E] %s (%li) %s!\n\x00"), []byte("Requested non-repeating index\x00"), valType, []byte("is invalid\x00"))
			return -1
		}
	} else {
		{
			// repeating
			for i = 0; i < valLenRP; i++ {
				if valType == valListRP[i] {
					i_pos = i + valLenRP*(repNum-1) + valLen
					break
				}
			}
		}
		if i_pos == -1 {
			noarch.Fprintf(msgout, []byte("[E] %s (%li) %s!\n\x00"), []byte("Requested repeating index\x00"), valType, []byte("is invalid\x00"))
			return 0
		}
	}
	if i_pos >= len_ {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Value outside field requested - program error\x00"))
		noarch.Fprintf(msgout, []byte("[E] %s (%li>%li)(%li|%li|%li)!\n\x00"), []byte("Value outside field requested - program error\x00"), i_pos, len_, pos, valType, repNum)
		return -1
	} else {
		index = SetFrom[pos] + i_pos
		return index
	}
	return
}

// femAddPutRepVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:396
func femAddPutRepVal(pos int32, valType int32, repNum int32, SetL []float64, SetLenL int32, SetFrom []int32, SetLen int32, valList []int32, valLen int32, valListRP []int32, valLenRP int32, AddMode int32, val float64) (c4goDefaultReturn float64) {
	// -----------------------------------
	// Puts/Adds value to  non/repeating data set
	// * @param pos pos of line in SetFrom
	// * @param valType type of data
	// * @param repeat if value is in "repeating" part (AF_YES of AF_NO)
	// * @param repNum set number for repeatable data (1,2,3,n !!)
	// * @param SetL field with values
	// * @param SetFrom starts in SetL
	// * @param SetLen lenth of SetFrom
	// * @param valList list of possible values
	// * @param valLen lenth of valList
	// * @param valListRP list of possible repeating values
	// * @param valLenRP lenth of valListRP
	// * @param AddMode (AF_YES of AF_NO)
	// * @param Val value ;-)
	// * @return state value
	//
	var i int32
	var repeat int32 = 1
	var i_pos int32 = -1
	var len_ int32
	if pos >= SetLen {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Value outside field requested\x00"))
		return float64(-3)
	}
	if repNum <= 0 {
		repeat = 0
	}
	len_ = femFldItemLen(pos, SetFrom, SetLen, SetLenL)
	if repeat == 0 {
		{
			// non-repeating
			for i = 0; i < valLen; i++ {
				if valType == valList[i] {
					//fprintf(msgout,"iii(%i)iii\n",i);
					i_pos = i
					break
				}
			}
		}
		if i_pos == -1 {
			noarch.Fprintf(msgout, []byte("[E] %s (%li) %s!\n\x00"), []byte("Requested added non-repeating value\x00"), valType, []byte("is invalid\x00"))
			return float64(-3)
		}
	} else {
		{
			// repeating
			for i = 0; i < valLenRP; i++ {
				if valType == valListRP[i] {
					i_pos = i + valLenRP*(repNum-1) + valLen
					break
				}
			}
		}
		if i_pos == -1 {
			noarch.Fprintf(msgout, []byte("[E] %s (%li) %s!\n\x00"), []byte("Requested added repeating value\x00"), valType, []byte("is invalid\x00"))
			return float64(-3)
		}
	}
	if i_pos >= len_ {
		noarch.Fprintf(msgout, []byte("[E] %s (%li>%li)!\n\x00"), []byte("Value outside field requested - program error\x00"), i_pos, len_)
		return float64(-3)
	} else {
		if AddMode == 1 {
			SetL[SetFrom[pos]+i_pos] += val
		} else {
			SetL[SetFrom[pos]+i_pos] = val
		}
		return float64(0)
	}
	return
}

// fem2IntPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:495
func fem2IntPos(val1 int32, fld1 []int32, val2 int32, fld2 []int32, fldLen int32) int32 {
	//  returns index of fld1 and fld2 for (fld1 == val1) AND (fld2 == val2)
	// * @param val1 1st value
	// * @param fld1 1st field
	// * @param val2 2nd value
	// * @param fld2 2nd field
	// * @param fldLen length of fld1 and fld2 (fields must be the same size)
	// * @return index (or -1 if fails)
	//
	var i int32
	var pos int32
	pos = -1
	for i = 0; i < fldLen; i++ {
		if val1 == fld1[i] && val2 == fld2[i] {
			pos = i
			return pos
		}
	}
	return -1
}

// femGetRepNum - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_accs.c:528
func femGetRepNum(pos int32, SetL []float64, SetLenL int32, SetFrom []int32, SetLen int32, valList []int32, valLen int32, valListRP []int32, valLenRP int32) int32 {
	// Returnes number of REPEATING data sets
	// * @param pos pos of line in SetFrom
	// * @param valType type of data
	// * @param repeat if value is in "repeating" part (AF_YES of AF_NO)
	// * @param repNum set number for repeatable data (1,2,3,n !!)
	// * @param SetL field with values
	// * @param SetLenL lenth of SetL
	// * @param SetFrom starts in SetL
	// * @param SetLen lenth of SetFrom
	// * @param valList list of possible values
	// * @param valLen lenth of valList
	// * @param valListRP list of possible repeating values
	// * @param valLenRP lenth of valListRP
	// * @return value
	//
	var len_ int32
	var repNum0 float64
	var repNum int32
	if pos >= SetLen {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Value outside field requested\x00"))
		return 0
	}
	if valLenRP <= 0 {
		return 0
	}
	len_ = femFldItemLen(pos, SetFrom, SetLen, SetLenL)
	repNum0 = float64(len_-valLen) / float64(valLenRP)
	if int32(repNum0) <= 0 {
		return 0
	}
	if repNum0 > float64(int32(repNum0)) {
		repNum = int32(repNum0) + 1
	} else {
		repNum = int32(repNum0)
	}
	return repNum
}

// alm_bergam_k - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_alm.c:73
func alm_bergam_k(d_la_0 float64, F []tVector, dut []tVector) (c4goDefaultReturn float64) {
	if femVecNormBig(dut) > 0 {
		//
		//   File name: fem_alm.c
		//   Date:      2007/02/05 15:24
		//   Author:    Jiri Brozovsky
		//
		//   Copyright (C) 2007 Jiri Brozovsky
		//
		//   This program is free software; you can redistribute it and/or
		//   modify it under the terms of the GNU General Public License as
		//   published by the Free Software Foundation; either version 2 of the
		//   License, or (at your option) any later version.
		//
		//   This program is distributed in the hope that it will be useful, but
		//   WITHOUT ANY WARRANTY; without even the implied warranty of
		//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
		//   General Public License for more details.
		//
		//   You should have received a copy of the GNU General Public License
		//   in a file called COPYING along with this program; if not, write to
		//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
		//   02139, USA.
		//
		//  FEM solver: Arc-Lenght Method
		//
		// from fem_sol.c:
		// total number of ACTIVE DOFs in structure (== size of "K" matrix)
		// lenght of nDOFfld
		// description of DOFs in nodes
		// numbers of items in "K" rows K_rows[nDOFAct]
		// K_rows for full ALM
		// structure stiffness matrix
		// structure load vector
		// unballanced forces vector
		// structure displacement vector
		// structure displacement vector - total displacements (NRM)
		// substep displacement vector for ALM
		// substep unballanced displacement vector for ALM
		// substep unballanced displacement vector for ALM
		// substep unballanced displacement vector for ALM
		// backup load vector for ALM and full ALM
		// step sum of unballanced forces for full ALM
		// whole load vector full ALM
		// structure and step matrix for full ALM
		// displacement and lambda vectro for full ALM
		// load and arc lenght vector for full ALM
		// Bergam's parameter of actuall stiffness (stiffness computation)
		return d_la_0 * femVecVecMultBig(F, dut) / femVecVecMultBig(dut, dut)
	} else {
		return 0
	}
	return
}

// femSolveFullALM - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_alm.c:91
func femSolveFullALM() int32 {
	// Non-linear analysis: Arc-Lenght Method (full version with non-symmetric matrix)
	// * 3rd attempt to make it working
	// * @param incr_type method for computation on load increment
	// * @return state value
	//
	var rv int32
	var i int32
	var j int32
	var k int32
	// number of steps
	var steps int32 = 1
	// number of iterations
	var substeps int32 = 333
	// convergence criteria
	var crit float64 = 0.0001
	var nobreak int32
	var converged int32
	var sum_jter int32
	var prev_steps int32 = 5
	var opt_steps int32 = 5
	var psi2 float64 = 0.01
	var lambda_sum float64
	var lambda_step float64
	var d_lambda float64
	var prev_lambda float64
	var normF float64
	var normFr float64
	var a_o float64
	var sqvar float64
	var dL2 float64
	var f_f float64
	var need_repeat int32
	var repeat_num int32
	var max_repeat int32 = 6
	var jb int32
	//crit     = solNoLinPre ;
	steps = solNoLinSteps
	substeps = solNoLinIter
	//rsize    = solNoLinBig ;
	nobreak = solNoBreakStep
	femTangentMatrix = 1
	noarch.Fprintf(msgout, []byte("[I] ALM %s:\n\x00"), []byte("solution\x00"))
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		// initialization of things:
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	femBackResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done _before_ adding of loads!
		goto memFree
	}
	// Backup result set:
	femBackResNull()
	// initial approximation of lambdas:
	d_lambda = 1 / float64(steps)
	prev_lambda = d_lambda
	{
		// steps:
		for i = 1; i <= steps*2; i++ {
			converged = 0
			if lambda_sum > 0.3 {
				// for convergence in softening
				psi2 = 1e-08
			}
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&du0))[:])
			femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			lambda_step = float64(opt_steps) / float64(prev_steps) * prev_lambda
			if need_repeat == 1 {
				lambda_step = math.Abs(lambda_step) / -10
			}
			if (func() int32 {
				rv = fem_fill_K(0)
				return rv
			}()) != 0 {
				// initial step - sample computation:
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_loads(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_disps(1, 0)
				return rv
			}()) != 0 {
				goto memFree
			}
			femValVecMultSelf(lambda_step, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&FF))[:])
			normF = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			f_f = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&FF))[:], (*[1000000]tVector)(unsafe.Pointer(&FF))[:])
			if solUseBiCGs != 1 {
				if solUseCGSSOR != 1 {
					if (func() int32 {
						rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				} else {
					if (func() int32 {
						rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				}
			} else {
				if (func() int32 {
					rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
			if femRunSolIterBC == 1 {
				for jb = 0; jb < resRLen; jb++ {
					resRval0[jb] = resRval[jb]
				}
			}
			if (func() int32 {
				rv = fem_fill_K(1)
				return rv
			}()) != 0 {
				// Fr is needed
				goto memFree
			}
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			// initial dL2 is needed:
			sqvar = lambda_step * psi2 * f_f
			// dL2 have is constant in step
			dL2 = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:]) + lambda_step*sqvar
			{
				// iteration:
				for j = 1; j <= substeps; j++ {
					sum_jter++
					// from previous iter. (if any)
					femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&du0))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
					// some values based on a previous step:
					sqvar = lambda_step * psi2 * f_f
					a_o = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&du0))[:], (*[1000000]tVector)(unsafe.Pointer(&du0))[:]) + lambda_step*sqvar - dL2
					// Fr -> F
					femVecClone((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
					femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
					if (func() int32 {
						rv = fem_fill_K(0)
						return rv
					}()) != 0 {
						goto memFree
					}
					if (func() int32 {
						rv = fem_add_disps(1, 0)
						return rv
					}()) != 0 {
						goto memFree
					}
					if math.Abs(a_o) > 0 {
						// filling of large matrix and vectors:
						// maybe redundant, but may help convergence
						femVecCloneDiff((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&uLa))[:])
						// F, because is is actually a Fr!
						femVecCloneDiff((*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&Fra))[:])
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&Fra))[:], nDOFAct+1, a_o, 0)
						femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:])
						femMatCloneDiffToEmpty((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&KF))[:])
						femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:], nDOFAct+1, nDOFAct+1, -2*sqvar, 0)
						{
							// slow - TODO replace with something faster!
							for k = 1; k <= nDOFAct; k++ {
								femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:], nDOFAct+1, k, -2*femVecGet((*[1000000]tVector)(unsafe.Pointer(&du0))[:], k), 0)
								// F vector to KF (last column) !!
								// TODO: slow!
								femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:], k, nDOFAct+1, -1*femVecGet((*[1000000]tVector)(unsafe.Pointer(&FF))[:], k), 0)
							}
						}
						if (func() int32 {
							rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:], (*[1000000]tVector)(unsafe.Pointer(&Fra))[:], (*[1000000]tVector)(unsafe.Pointer(&uLa))[:], 1e-17/10000, 2*nDOFAct+1)
							return rv
						}()) != 0 {
							// solve non-symetric problem:
							goto memFree
						}
						d_lambda = femVecGet((*[1000000]tVector)(unsafe.Pointer(&uLa))[:], nDOFAct+1)
						lambda_step += d_lambda
						// TODO: check this!!!
						femVecCloneDiff((*[1000000]tVector)(unsafe.Pointer(&uLa))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
						// TODO: useless???
						femVecCloneDiff((*[1000000]tVector)(unsafe.Pointer(&Fra))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
					} else {
						if solUseBiCGs != 1 {
							if solUseCGSSOR != 1 {
								if (func() int32 {
									rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
									return rv
								}()) != 0 {
									goto memFree
								}
							} else {
								if (func() int32 {
									rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
									return rv
								}()) != 0 {
									goto memFree
								}
							}
						} else {
							if (func() int32 {
								rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
								return rv
							}()) != 0 {
								goto memFree
							}
						}
						// a_o=0 => d_lambda=0
						d_lambda = 0
						if femRunSolIterBC == 1 {
							for jb = 0; jb < resRLen; jb++ {
								resRval0[jb] = resRval[jb]
							}
						}
					}
					// !!!
					femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					if (func() int32 {
						rv = fem_fill_K(1)
						return rv
					}()) != 0 {
						// get unballanced forces and results :
						// Fr is needed
						goto memFree
					}
					normFr = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					noarch.Fprintf(msgout, []byte("ALM stp: %3li, iter: %3li, la: %f, norm: %e, dl: %e\n\x00"), i, j, lambda_sum+lambda_step, normFr, d_lambda)
					prev_steps = j
					femWriteSolNorm(sum_jter, lambda_sum+lambda_step, normFr, normF*crit, normF*1)
					if normFr/normF <= crit {
						if j == 1 {
							// convergence test:
							d_lambda = lambda_step
						}
						converged = 1
						break
					}
				}
			}
			if converged == 1 {
				// end of "j" .. substeps
				lambda_sum += lambda_step
				// reactions
				femGetSumReact(i, sum_jter, lambda_sum, femSumReactName, femTangentMatrix)
				femSaPoInput(lambda_sum, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 2)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 3)), 0, 0)
				if femSubStepCheckNumber(i) == 1 {
					// save step results:
					// substep results
					femVecClone((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
					solSimNum = lambda_sum
					if (func() int32 {
						rv = femWriteRes(femSubStepFname(i))
						return rv
					}()) != 0 {
						goto memFree
					}
					solID++
					femVecClone((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
				}
				if lambda_sum >= 1 || lambda_sum <= 0 {
					// 1.0 is enough
					break
				}
				femBackResGet()
				need_repeat = 0
			} else {
				// converged == AF_NO
				noarch.Fprintf(msgout, []byte("[w] ALM: %s: %li !\n\x00"), []byte("Unconverged step\x00"), i)
				repeat_num++
				if repeat_num > max_repeat {
					noarch.Fprintf(msgout, []byte("[E] ALM: %s: %li !\n\x00"), []byte("Number of restarts exceeded in step\x00"), i)
					if nobreak != 1 {
						goto memFree
					} else {
						break
					}
				} else {
					femBackResPut()
					need_repeat = 1
				}
			}
			if femComputePE == 1 {
				femCompPE((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1)
			}
		}
	}
	// end of "i .. steps"
	// save final results:
	femVecClone((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	solSimNum = lambda_sum
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
memFree:
	;
	if converged == 1 {
		noarch.Fprintf(msgout, []byte("[I] ALM: %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[W] ALM: %s.\n\x00"), []byte("Unconverged solution\x00"))
	}
	fem_sol_free()
	femDataFree()
	femResFree()
	femBackResFree()
	noarch.Fprintf(msgout, []byte("[ ] ALM Solution return: %i\n\x00"), rv)
	femCloseSolNormFile()
	return rv
}

// alm_cyl_lambda - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_alm.c:445
func alm_cyl_lambda(du0 []tVector, dut []tVector, dur []tVector, du []tVector, f_f float64, d_la_0 float64, psi2 float64, dL2 float64) float64 {
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// Computes lambda change for CALM (TODO: works? in what cases?)
	// empty one
	var d_la float64
	var dl_1 float64
	var dl_2 float64
	var disc float64
	var cos1 float64
	var cos2 float64
	var a1 float64
	var a2 float64
	var a3 float64
	var a4 float64
	var a5 float64
	femVecSetZeroBig(du)
	femVecAddVec(du, 1, du0)
	femVecAddVec(du, 1, dur)
	a1 = femVecVecMultBig(dut, dut) + psi2*f_f
	a2 = 2*femVecVecMultBig(dur, du) + 2*d_la_0*psi2*f_f
	a3 = femVecVecMultBig(du, du) - dL2 + d_la_0*d_la_0*psi2*f_f
	a4 = femVecVecMultBig(du0, dur) + femVecVecMultBig(du0, du0)
	a5 = femVecVecMultBig(du0, dut)
	disc = a2*a2 - 4*a1*a3
	if disc <= 0 {
		noarch.Fprintf(msgout, []byte("[W] %s!\n\x00"), []byte("load multiplier is imaginar\x00"))
		return 0
	} else {
		dl_1 = (-a2 + math.Sqrt(disc)) / a1
		dl_2 = (-a2 - math.Sqrt(disc)) / a1
		cos1 = (a4 + dl_1*a5) / dL2
		cos2 = (a4 + dl_2*a5) / dL2
		if cos1 > cos2 {
			d_la = dl_1
		} else {
			d_la = dl_2
		}
	}
	return d_la
}

// femSolveALM - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_alm.c:533
func femSolveALM(incr_type int32) int32 {
	// Stop signal function for NRM
	// * @param sig_num (unused but required) signal number
	//
	// TODO Non-linear analysis: Arc-Lenght Method
	// * @param incr_type method for computation on load increment
	// * @return state value
	//
	var rv int32
	var i int32
	var j int32
	// number of steps
	var steps int32 = 1
	// number of iterations
	var substeps int32 = 99
	// convergence criteria
	var crit float64 = 1e-05
	var nobreak int32
	var converged int32
	var sum_jter int32
	var was_steps int32
	var opt_steps int32 = 10
	var was_dl float64
	var dL2 float64
	var d_la_0 float64
	var d_la float64
	var lambda float64
	var a_o float64
	var psi2 float64
	var multR float64 = 0.3
	// 0=linearized, 1=cyllindric
	var alm_type int32
	var f_f float64
	var normF float64
	var normFr float64
	var need_repeat int32
	var repeat_count int32
	var repeat_max int32 = 10
	var laststp int32
	var jb int32
	//crit     = solNoLinPre ;
	steps = solNoLinSteps
	substeps = solNoLinIter
	//rsize    = solNoLinBig ;
	nobreak = solNoBreakStep
	// default data multiplier
	multR = 1 / float64(steps)
	steps *= 2
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		// initialization of things:
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	femBackResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done _before_ adding of loads!
		goto memFree
	}
	for i = 1; i <= steps*4; i++ {
		converged = 0
		if lambda > 0.1 {
			// for convergence in softening
			psi2 = 0
		}
		if (func() int32 {
			rv = fem_fill_K(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_loads(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_disps(1, 0)
			return rv
		}()) != 0 {
			goto memFree
		}
		// !!!
		femValVecMultSelf(multR, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
		if solUseBiCGs != 1 {
			if solUseCGSSOR != 1 {
				if (func() int32 {
					rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			} else {
				if (func() int32 {
					rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
		} else {
			if (func() int32 {
				rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		}
		if femRunSolIterBC == 1 {
			for jb = 0; jb < resRLen; jb++ {
				resRval0[jb] = resRval[jb]
			}
		}
		if i == 1 {
			f_f = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			normF = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			dL2 = math.Pow(1/float64(steps), 2)*psi2*f_f + femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
		}
		if need_repeat == 1 {
			// repeated try: reduce arc lenght
			dL2 *= 0.1
		}
		// TODO: custom d_la_0 here...
		d_la_0 = math.Sqrt(dL2) / math.Sqrt(femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])+psi2*f_f)
		if d_la_0 > 0.222 {
			d_la_0 = 0.222
		}
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
		femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
		if (func() int32 {
			rv = fem_fill_K(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_loads(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_disps(1, 0)
			return rv
		}()) != 0 {
			goto memFree
		}
		// !!!
		femValVecMultSelf(multR, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
		femValVecMultSelf(d_la_0, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
		if solUseBiCGs != 1 {
			if solUseCGSSOR != 1 {
				if (func() int32 {
					rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			} else {
				if (func() int32 {
					rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
		} else {
			if (func() int32 {
				rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		}
		femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&du0))[:])
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
		if femRunSolIterBC == 1 {
			for jb = 0; jb < resRLen; jb++ {
				resRval0[jb] = resRval[jb]
			}
		}
		if (func() int32 {
			rv = fem_fill_K(1)
			return rv
		}()) != 0 {
			goto memFree
		}
		// residual forces of 0th iter
		femVecClone((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		for j = 1; j <= substeps; j++ {
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
			femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			if (func() int32 {
				rv = fem_fill_K(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_loads(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_disps(1, 0)
				return rv
			}()) != 0 {
				goto memFree
			}
			// !!!
			femValVecMultSelf(multR, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			if femSaveSparMatFStat == 1 {
				femSparseMatPrnF(femSubStepMatrixFname(femSaveSparMatFName, i), (*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			}
			if femSaveVecFStat == 1 {
				femVecPrnF(femSubStepMatrixFname(femSaveVecFName, i), (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			}
			if solUseBiCGs != 1 {
				if solUseCGSSOR != 1 {
					if (func() int32 {
						rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				} else {
					if (func() int32 {
						rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				}
			} else {
				if (func() int32 {
					rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&dut))[:])
			// unballanced forces
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
			femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			if (func() int32 {
				rv = fem_fill_K(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			if (func() int32 {
				rv = fem_add_disps(1, 0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if solUseBiCGs != 1 {
				if solUseCGSSOR != 1 {
					if (func() int32 {
						rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				} else {
					if (func() int32 {
						rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				}
			} else {
				if (func() int32 {
					rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&dur))[:])
			if femRunSolIterBC == 1 {
				for jb = 0; jb < resRLen; jb++ {
					resRval0[jb] = resRval[jb]
				}
			}
			a_o = psi2*d_la_0*d_la_0*f_f + femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&du0))[:], (*[1000000]tVector)(unsafe.Pointer(&du0))[:]) - dL2
			switch alm_type {
			case 1:
				// d_la computation
				d_la = alm_cyl_lambda((*[1000000]tVector)(unsafe.Pointer(&du0))[:], (*[1000000]tVector)(unsafe.Pointer(&dut))[:], (*[1000000]tVector)(unsafe.Pointer(&dur))[:], (*[1000000]tVector)(unsafe.Pointer(&du))[:], f_f, d_la_0, psi2, dL2)
			case 0:
				fallthrough
			default:
				// linearized ALM:
				d_la = -1 * ((0.5*a_o + femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&du0))[:], (*[1000000]tVector)(unsafe.Pointer(&dur))[:])) / (femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&du0))[:], (*[1000000]tVector)(unsafe.Pointer(&dut))[:]) + d_la_0*psi2*f_f))
				break
			}
			if d_la > 4 {
				d_la = 4
			}
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u))[:], d_la, (*[1000000]tVector)(unsafe.Pointer(&dut))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&du0))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			if (func() int32 {
				rv = fem_fill_K(1)
				return rv
			}()) != 0 {
				goto memFree
			}
			// residual forces of 0th iter
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
			normFr = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
			d_la_0 += d_la
			was_steps = j
			was_dl = d_la_0
			sum_jter++
			femWriteSolNorm(sum_jter, d_la_0+lambda, normFr, normF*crit, normF*1)
			noarch.Fprintf(msgout, []byte("[ ] ALM stp: %3li, it: %3li, dla %e, la: %f, Fr: %e\n\x00"), i, j, d_la*multR, (d_la_0+lambda)*multR, normFr)
			if normFr/normF <= crit {
				// convergence test:
				converged = 1
				break
			}
		}
		if converged == 1 {
			// for j
			lambda += d_la_0
			// reactions
			femGetSumReact(i, sum_jter, lambda*multR, femSumReactName, femTangentMatrix)
			femSaPoInput(lambda*multR, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 2)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 3)), 0, 0)
			if femSubStepCheckNumber(i) == 1 {
				// save step results:
				// substep results
				femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
				solSimNum = lambda * multR
				if (func() int32 {
					rv = femWriteRes(femSubStepFname(i))
					return rv
				}()) != 0 {
					goto memFree
				}
				solID++
				femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			}
			if lambda*multR >= 1.01 || lambda*multR <= 0.004 {
				// 1.0 is enough
				break
			}
			femBackResGet()
			need_repeat = 0
		} else {
			// converged == AF_NO
			noarch.Fprintf(msgout, []byte("[w] ALM: %s: %li !\n\x00"), []byte("Unconverged step\x00"), i)
			if i == 1 {
				goto memFree
			}
			repeat_count++
			need_repeat = 1
			i--
			if repeat_count > repeat_max {
				if nobreak != 1 {
					goto memFree
				} else {
					break
				}
			}
			multR /= 2
			femBackResPut()
		}
		laststp = i
		if femComputePE == 1 {
			femCompPE((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1)
		}
	}
	// for i
	// save final results:
	femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	solSimNum = lambda * multR
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
memFree:
	;
	if converged == 1 || laststp > 1 {
		noarch.Fprintf(msgout, []byte("[I] ALM: %s, %s: %li, %s: %f %s: %li.\n\x00"), []byte("Solution done\x00"), []byte("steps\x00"), laststp, []byte("load\x00"), lambda*multR, []byte("restarts\x00"), repeat_count)
	} else {
		noarch.Fprintf(msgout, []byte("[W] ALM: %s.\n\x00"), []byte("Unconverged solution\x00"))
	}
	fem_sol_free()
	femDataFree()
	femResFree()
	femBackResFree()
	noarch.Fprintf(msgout, []byte("[ ] ALM Solution return: %i\n\x00"), rv)
	femCloseSolNormFile()
	return rv
}

// fem_asse_max_disp_simple - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:42
func fem_asse_max_disp_simple(disp_max float64) int32 {
	if femVecMaxAbs((*[1000000]tVector)(unsafe.Pointer(&u))[:]) >= math.Abs(disp_max) {
		//
		//   File name: fem_asse.c
		//   Date:      2011/01/31 18:27
		//   Author:    Jiri Brozovsky
		//
		//   Copyright (C) 2011 Jiri Brozovsky
		//
		//   This program is free software; you can redistribute it and/or
		//   modify it under the terms of the GNU General Public License as
		//   published by the Free Software Foundation; either version 2 of the
		//   License, or (at your option) any later version.
		//
		//   This program is distributed in the hope that it will be useful, but
		//   WITHOUT ANY WARRANTY; without even the implied warranty of
		//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
		//   General Public License for more details.
		//
		//   You should have received a copy of the GNU General Public License
		//   in a file called COPYING along with this program; if not, write to
		//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
		//   02139, USA.
		//
		//   General assessment routines (mainly for libfem.so)
		//
		// from fem_ch2d
		// from fem_chen
		// Max. displacement test
		// * @param disp_max maximum allowed displacement (x,y, or z)
		// * @return 0 if passed, non-zero number (usually 1) if failed
		//
		// failed
		return 1
	}
	return 0
}

// fem_asse_mat_vmis - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:55
func fem_asse_mat_vmis(sigma []tVector, epsilon []tVector, ePos int32) int32 {
	// Material point failure test - material 4: von Mises plasticity condition
	// * @param sigma stress vector
	// * @param epsilon strain vector
	// * @param mType type of material
	// * @return 0 if passed, non-zero number (usually 1) if failed
	//
	var f_y float64
	var s_vmis float64
	f_y = femGetMPValPos(ePos, 12, 0)
	if sigma[0].len_ > 3 {
		// 3D case
		s_vmis = math.Sqrt(stress3D_J2(sigma) * 3)
	} else {
		// 2D case
		s_vmis = math.Sqrt(stress2D_J2(sigma) * 3)
	}
	if s_vmis < math.Abs(f_y) {
		// passed
		return 0
	} else {
		// failed
		return 1
	}
	return 0
}

// fem_asse_mat_concr - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:83
func fem_asse_mat_concr(sigma []tVector, epsilon []tVector, ePos int32) int32 {
	// Material point failure test - material 3: concrete (simplified)
	// * @param sigma stress vector
	// * @param epsilon strain vector
	// * @param mType type of material
	// * @return 0 if passed, non-zero number (usually 1) if failed
	//
	var f_yt float64
	var f_ybc float64
	var val_t float64
	var val_bc float64
	var phi float64
	f_yt = femGetMPValPos(ePos, 14, 0)
	f_ybc = femGetMPValPos(ePos, 13, 0)
	if sigma[0].len_ > 3 {
		// 3D case
		femPrinc3D(sigma, epsilon)
		val_bc = femVecGet(epsilon, 3)
	} else {
		// 2D case
		// epsilon serves as principal stress vector!
		femGetPrincStress2D(sigma, epsilon, c4goUnsafeConvert_float64(&phi))
		val_bc = femVecGet(epsilon, 2)
	}
	val_t = femVecGet(epsilon, 1)
	if val_t > math.Abs(f_yt) && val_bc < -1*math.Abs(f_ybc) {
		// failed
		return 1
	} else {
		// passed
		return 0
	}
	return 0
}

// fem_asse_mat_by_type - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:121
func fem_asse_mat_by_type(sigma []tVector, epsilon []tVector, ePos int32) int32 {
	// Material point failure test wrapper
	// * @param sigma stress vector
	// * @param epsilon strain vector
	// * @param mType type of material
	// * @param ePos position of studied element
	// * @return 0 if passed, non-zero number (usually 1) if failed
	//
	var mType int32
	mType = Mat[femGetIntPos(femGetIntPos(ePos, eMP, eLen), mpType, mpLen)].type_
	switch mType {
	case 3:
		// concrete
		return fem_asse_mat_concr(sigma, epsilon, ePos)
	case 4:
		// von Mises steel
		return fem_asse_mat_vmis(sigma, epsilon, ePos)
	default:
		return 0
		// nothing to test
		break
	}
	return 0
}

// fem_steel_link_stability_simple - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:155
func fem_steel_link_stability_simple(NN float64, E float64, A float64, L float64, tH float64, tF float64, te float64, tI float64) int32 {
	// Tests elastic stability of links according to Eurocode 3 (one axis only):
	//  @param N  normal force - computed
	//  @param E  young modullus
	//  @param A  element area
	//  @param L  element lenght
	//  @param tH element height
	//  @param tF limit stress
	//  @param te initial excentricity
	//  @param tI moment of inertia
	//  @return status: 1..failed, 0..not failed
	//
	// normal force - computed
	// young modullus
	// element area
	// element lenght
	// element height
	// limit stress
	// initial excentricity
	// moment of inertia
	// data for solution:
	// radius of garation
	var ti float64
	var Rt float64
	var Rc float64
	var R1 float64
	var N float64
	// computation of data
	ti = math.Sqrt(tI / A)
	N = -1 * NN
	// procedure:
	R1 = 1 + tF*math.Pow(L/ti, 2)/(3.141592653589793*3.141592653589793*E) + L*te*tH*0.5/(ti*ti)
	Rc = (R1 - math.Sqrt(R1*R1-tF*(4*math.Pow(L/ti, 2)/(3.141592653589793*3.141592653589793*E)))) / (2 * math.Pow(L/ti, 2) / (3.141592653589793 * 3.141592653589793 * E * A))
	Rt = tF
	if N < 0 {
		if math.Abs(N) > math.Abs(Rc) {
			return 1
		} else {
			return 0
		}
	} else {
		if math.Abs(N/A) > math.Abs(Rt) {
			return 1
		} else {
			return 0
		}
	}
	return 0
}

// fem_test_steel_link_stability - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:212
func fem_test_steel_link_stability(ePos int32, eT int32) int32 {
	// Tests elastic stability of links according to Eurocode 3:
	//  @param ePos element position
	//  @param eT   element type
	//  @return status: 1..failed, 0..not failed
	//
	var mType int32
	var rv int32
	// normal force - computed
	var N float64
	// young modullus
	var E float64
	// limit stress
	var tF float64
	// element area
	var A float64
	// element lenght
	var L float64
	// element height
	var tHy float64
	// initial excentricity
	var tey float64
	// moment of inertia
	var tIy float64
	// element height
	var tHz float64
	// initial excentricity
	var tez float64
	// moment of inertia
	var tIz float64
	if (func() int32 {
		mType = Mat[femGetIntPos(femGetIntPos(ePos, eMP, eLen), mpType, mpLen)].type_
		return mType
	}()) != 4 {
		// only type==4 (von Mises) can work here
		return 0
	}
	N = femGetRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	E = femGetMPValPos(ePos, 2, 0)
	tF = femGetMPValPos(ePos, 12, 0)
	A = femGetRSValPos(ePos, 1, 0)
	tHy = femGetRSValPos(ePos, 3, 0)
	tIy = femGetRSValPos(ePos, 9, 0)
	tey = femGetRSValPos(ePos, 25, 0)
	if Elem[eT].dofs <= 2 {
		// 2 D link
		L = e001_lenght(ePos)
		return fem_steel_link_stability_simple(N, E, A, L, tHy, tF, tey, tIy)
	} else {
		// 3D link
		L = e007_length(ePos)
		if (func() int32 {
			rv = fem_steel_link_stability_simple(N, E, A, L, tHy, tF, tey, tIy)
			return rv
		}()) != 0 {
			return rv
		} else {
			tHz = femGetRSValPos(ePos, 2, 0)
			tIz = femGetRSValPos(ePos, 10, 0)
			tez = femGetRSValPos(ePos, 26, 0)
			return fem_steel_link_stability_simple(N, E, A, L, tHz, tF, tez, tIz)
		}
	}
	return 0
}

// fem_asse_fail_cond - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_asse.c:271
func fem_asse_fail_cond() int32 {
	// Checks failure condition in dependence of material and element type
	// * @return 0 if not failed, 1 if failed
	//
	var i int32
	var j int32
	var eT int32
	var dim int32
	var ips int32
	var result int32
	var stress3 tVector
	var stress6 tVector
	var strain3 tVector
	var strain6 tVector
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&stress3))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&stress6))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&strain3))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&strain6))[:])
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 0, 3, 3) != 0 {
		goto memFree
	}
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 0, 6, 6) != 0 {
		goto memFree
	}
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&strain3))[:], 0, 3, 3) != 0 {
		goto memFree
	}
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&strain6))[:], 0, 6, 6) != 0 {
		goto memFree
	}
	for i = 0; i < eLen; i++ {
		eT = femGetIntPos(i, eType, eLen)
		dim = Elem[eT].dim
		switch dim {
		case 1:
			if (func() int32 {
				result = fem_test_steel_link_stability(i, eT)
				return result
			}()) != 0 {
				// link
				// steel link stability:
				return result
			}
		case 2:
			// plane
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 1, femGetRepVal(i, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 2, femGetRepVal(i, 8, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 3, femGetRepVal(i, 10, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			if (func() int32 {
				result = fem_asse_mat_vmis((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], (*[1000000]tVector)(unsafe.Pointer(&strain3))[:], i)
				return result
			}()) != 0 {
				return result
			}
			ips = Elem[eT].res_rp
			for j = 1; j <= ips; j++ {
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 1, femGetRepVal(i, 7, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 2, femGetRepVal(i, 8, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], 3, femGetRepVal(i, 10, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				if (func() int32 {
					result = fem_asse_mat_vmis((*[1000000]tVector)(unsafe.Pointer(&stress3))[:], (*[1000000]tVector)(unsafe.Pointer(&strain3))[:], i)
					return result
				}()) != 0 {
					return result
				}
			}
		case 3:
			// 3D structure
			// TODO
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 1, femGetRepVal(i, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 2, femGetRepVal(i, 8, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 3, femGetRepVal(i, 9, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 4, femGetRepVal(i, 11, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 5, femGetRepVal(i, 12, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 6, femGetRepVal(i, 10, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
			if (func() int32 {
				result = fem_asse_mat_vmis((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], (*[1000000]tVector)(unsafe.Pointer(&strain6))[:], i)
				return result
			}()) != 0 {
				return result
			}
			ips = Elem[eT].res_rp
			for j = 1; j <= ips; j++ {
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 1, femGetRepVal(i, 7, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 2, femGetRepVal(i, 8, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 3, femGetRepVal(i, 9, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 4, femGetRepVal(i, 11, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 5, femGetRepVal(i, 12, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], 6, femGetRepVal(i, 10, j, resEVal, resELen, resEFrom, eLen, Elem[eType[i]].nres, Elem[eType[i]].res, Elem[eType[i]].nres_rp, Elem[eType[i]].res_rp), 0)
				if (func() int32 {
					result = fem_asse_mat_vmis((*[1000000]tVector)(unsafe.Pointer(&stress6))[:], (*[1000000]tVector)(unsafe.Pointer(&strain6))[:], i)
					return result
				}()) != 0 {
					return result
				}
			}
		case 4:
			// slab/shell
			// TODO
		case 5:
			// beam
			// TODO
		default:
			break
		}
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&stress3))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&stress6))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&strain3))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&strain6))[:])
	return result
}

// main - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem.c:54
func main() {
	argc := int32(len(os.Args))
	argv := [][]byte{}
	for _, argvSingle := range os.Args {
		argv = append(argv, []byte(argvSingle))
	}
	defer noarch.AtexitRun()
	//
	//   File name: fem.c
	//   Date:      2003/04/07 09:01
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - main file
	//
	//  $Id: fem.c,v 1.26 2004/12/31 23:09:25 jirka Exp $
	//
	// Main() function
	//
	var rv int32
	// for output from "fprintf(msgout,...)"
	msgout = noarch.Stdout
	if (func() int32 {
		rv = fem_parse_params(argc, argv)
		return rv
	}()) != 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Command line michmach\x00"))
		noarch.Exit(int32(rv))
	}
	if (func() int32 {
		rv = femDataNull()
		return rv
	}()) != 0 {
		// Setting of data to NULL
		noarch.Exit(int32(rv))
	}
	if (func() int32 {
		rv = femResNull()
		return rv
	}()) != 0 {
		noarch.Exit(int32(rv))
	}
	if (func() int32 {
		rv = femReadInput(fem_ifile)
		return rv
	}()) != 0 {
		noarch.Exit(int32(rv))
	}
	femSaPoSetNode(0, nLen)
	if (func() int32 {
		rv = femSaPoAlloc(solNoLinStepMax, 0)
		return rv
	}()) != 0 {
		noarch.Exit(int32(rv))
	}
	femSaPoLen = solNoLinStepMax
	if femTensorScale == 1 {
		rv = femWriteTensorScaleRaster(fem_tsfile, femTensorScaleDiv)
	}
	if femDynamics == 1 {
		if femEigenModal == 1 {
			if femEigenInvI == 1 {
				// dynamics
				// modal analysis
				// this does not work well
				rv = femSolveEigenInvIter(1500, 4)
			} else {
				// this totally fails
				rv = femSolveEigenLanczos(1500, 4)
			}
		} else {
			if femNewmarkEL == 1 {
				// Newmark: dynamics
				rv = femSolveDynNewmark(nil)
			} else {
				noarch.Fprintf(msgout, []byte("[E] %s!\x00"), []byte("Unknown analysis type\x00"))
				noarch.Exit(int32(-3))
			}
		}
	} else {
		if femTestConstIpn > -1 && femTestConstElem > -1 {
			// statics
			// constitutive data testing
			noarch.Exit(femDryRun())
		} else {
			if femComputePriceOnly == 1 {
				// statics
				// computes price of structure
				noarch.Exit(int32(femComputePrice()))
			} else {
				if femComputeGrCenOnly == 1 {
					noarch.Exit(int32(femComputeGravCentre()))
				} else {
					if femThermTrans == 1 {
						if (func() int32 {
							rv = femSolveThermTrans(nil)
							return rv
						}()) != 0 {
							// thermal transient
							noarch.Exit(int32(rv))
						}
					} else {
						if solNoLinS > 1 {
							switch solNoLinS {
							case 2:
								if (func() int32 {
									rv = femSolveNRM(0)
									return rv
								}()) != 0 {
									noarch.Exit(int32(rv))
								}
							case 3:
								if (func() int32 {
									rv = femSolveALM(2)
									return rv
								}()) != 0 {
									noarch.Exit(int32(rv))
								}
							case 4:
								if (func() int32 {
									rv = femSolveFullALM()
									return rv
								}()) != 0 {
									noarch.Exit(int32(rv))
								}
							case 6:
								if (func() int32 {
									rv = femSolveDirDisps(0)
									return rv
								}()) != 0 {
									noarch.Exit(int32(rv))
								}
							default:
								noarch.Exit(int32(-3))
								break
							}
						} else {
							if (func() int32 {
								rv = femSolve()
								return rv
							}()) != 0 {
								noarch.Exit(int32(rv))
							}
						}
					}
				}
			}
		}
	}
	// *
	femSaPoSave()
	femSaPoDestroy()
	// file names
	if len(fem_ifile) != 0 {
	}
	_ = fem_ifile
	fem_ifile = nil
	if len(fem_ofile) != 0 {
	}
	_ = fem_ofile
	fem_ofile = nil
	if len(fem_rfile) != 0 {
	}
	_ = fem_rfile
	fem_rfile = nil
	if len(fem_thrfile) != 0 {
	}
	_ = fem_thrfile
	fem_thrfile = nil
	if len(fem_throfile) != 0 {
	}
	_ = fem_throfile
	fem_throfile = nil
	noarch.Exit(int32(rv))
}

// femTs_2d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:42
func femTs_2d(Ts []tMatrix, fi0 float64) int32 {
	//
	//   File name: fem_ccr2.c
	//   Date:      2003/05/03 19:39
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - 2D concrete material
	//
	//  $Id: fem_ccr2.c,v 1.8 2004/05/30 13:53:36 jirka Exp $
	//
	// Computes Ts transformation matrix for 2D problem
	// * @param Ts matrix[3,3]  - must be allocated!
	// * @param fi0 angle [grad]
	// * @return state value
	//
	var c float64
	var s float64
	var fi float64
	femMatSetZero(Ts)
	fi = 3.141592653589793 * (fi0 / 180)
	c = math.Cos(fi)
	s = math.Sin(fi)
	femMatPutAdd(Ts, 1, 1, c*c, 0)
	femMatPutAdd(Ts, 1, 2, s*s, 0)
	femMatPutAdd(Ts, 1, 3, 2*c*s, 0)
	femMatPutAdd(Ts, 2, 1, s*s, 0)
	femMatPutAdd(Ts, 2, 2, c*c, 0)
	femMatPutAdd(Ts, 2, 3, -2*c*s, 0)
	femMatPutAdd(Ts, 3, 1, -1*c*s, 0)
	femMatPutAdd(Ts, 3, 2, c*s, 0)
	femMatPutAdd(Ts, 3, 3, c*c-s*s, 0)
	return 0
}

// femTe_2d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:78
func femTe_2d(Ts []tMatrix, fi0 float64) int32 {
	// Computes Te transformation matrix for 2D problem
	// * @param Ts matrix[3,3]  - must be allocated!
	// * @param fi0 angle [grad]
	// * @return state value
	//
	var c float64
	var s float64
	var fi float64
	femMatSetZero(Ts)
	fi = 3.141592653589793 * (fi0 / 180)
	c = math.Cos(fi)
	s = math.Sin(fi)
	femMatPutAdd(Ts, 1, 1, c*c, 0)
	femMatPutAdd(Ts, 1, 2, s*s, 0)
	femMatPutAdd(Ts, 1, 3, c*s, 0)
	femMatPutAdd(Ts, 2, 1, s*s, 0)
	femMatPutAdd(Ts, 2, 2, c*c, 0)
	femMatPutAdd(Ts, 2, 3, -1*c*s, 0)
	femMatPutAdd(Ts, 3, 1, -2*c*s, 0)
	femMatPutAdd(Ts, 3, 2, 2*c*s, 0)
	femMatPutAdd(Ts, 3, 3, c*c-s*s, 0)
	return 0
}

// betaKolmar - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:117
func betaKolmar(epsilon float64) float64 {
	//
	// * Computes reduction coefficient for G modulus (using Kolmar's theory)
	// * @param  epsilon  relative deformation perpedicular to  crack
	// * @return beta     reduction coefficient (0, 1>
	//
	var c1 float64
	var c2 float64
	if epsilon <= 0 {
		// uncracked
		return 1
	}
	c1 = 7 + 333*(0-0.005)
	c2 = 10 - 167*(0-0.005)
	if c2 <= 0 {
		return 0
	}
	return math.Log(math.Abs(epsilon/c1)) / c2
}

// betaCerv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:136
func betaCerv(epsilon float64) (c4goDefaultReturn float64) {
	//
	// * Computes reduction coefficient for G modulus (using Cervenka's method)
	// * @param  epsilon  relative deformation perpedicular to  crack
	// * @return beta     reduction coefficient (0, 1>
	//
	var k3 float64 = 0.4
	var beta float64
	k3 = 1
	if epsilon < 0 {
		return 1
	} else {
		beta = 1 - math.Pow(epsilon/0.005, k3)
		if beta > 1 {
			return 1
		}
		if beta < 0.001 {
			return 0.001
		} else {
			return beta
		}
	}
	return
}

// betaCoeff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:157
func betaCoeff(epsilon float64, E float64, Ecr float64) float64 {
	// Computes "beta" reduction coefficient
	// * @param  epsilon relative deformation in needed direction
	// * @return beta (result)
	//
	var afMethodG int32 = 1
	var e_max float64 = 0.0004
	if Ecr/E > 1 {
		return 1
	}
	if epsilon < 0 {
		return 1
	}
	switch afMethodG {
	case 1:
		if epsilon > e_max {
			// Damjanic + Owen:
			return 1e-06
		} else {
			return 1 - epsilon/e_max
		}
	case 2:
		// Kolmar
		return betaKolmar(epsilon)
	case 3:
		// Mang:
		return 0.2
		break
	case 4:
		// Brdecko:
		return 0.3
	case 5:
		if Ecr/E < 1e-06 {
			// Glemberk + Sammuelson:
			return 1e-06
		} else {
			return Ecr / E
		}
	case 6:
		// Cervenka:
		return betaCerv(epsilon)
	default:
		return 1
		break
	}
	return 1
}

// chenGetRt - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:208
func chenGetRt(E float64, Gf float64, epsilon_el float64, sigma_max float64, sigma_max_cr float64, L float64) float64 {
	//
	// * Computes residual stifness of cracked material (Rt)
	// * using simplified crack band model
	// * @param  E          initial stifness modulus
	// * @param  Gf         fracture energy
	// * @param  epsilon_el elastic part of relative deformation
	// * @param  sigma_max  maximal (== failure) stress
	// * @param  L          crack band width
	// * @return Rt modulus size (may be 0, too)
	//
	var sigma_i float64
	var Ez float64
	var Rt float64
	if epsilon_el == 0 {
		return E
	}
	if epsilon_el < 0 {
		if math.Abs(sigma_max_cr/E) > math.Abs(epsilon_el) {
			// crushing
			return E
		} else {
			return math.Abs(sigma_max_cr / epsilon_el)
		}
	}
	if math.Abs(sigma_max/E) > math.Abs(epsilon_el) {
		return E
	}
	// Descending modulus:
	Ez = -1 * E / (1 - 2*Gf*E/(L*sigma_max*sigma_max))
	// Actual equivalent stess:
	sigma_i = epsilon_el*Ez + sigma_max*(1-Ez/E)
	Rt = sigma_i / epsilon_el
	if Rt > E {
		// Modulus is returned:
		Rt = E
	} else {
		if Rt < 1e-08*E {
			Rt = 1e-08 * E
		} else {
			Rt = sigma_i / epsilon_el
		}
	}
	noarch.Fprintf(msgout, []byte("[i] L=%f Gf=%f E=%f Ez=%f Rt=%f\n\x00"), L, Gf, E, Ez, Rt)
	return Rt
}

// femCEB_FIP_Val - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:281
func femCEB_FIP_Val(s_01 float64, s_02 float64, f_uc float64, f_ut float64, f_uc_new []float64, f_ut_new []float64) {
	// ----------------------------------------------
	var crit float64
	var alpha float64
	var s_1 float64
	var s_2 float64
	f_uc_new[0] = f_uc
	f_ut_new[0] = f_ut
	if s_02 > s_01 {
		// always must be s_1 > s_2:
		s_1 = s_02
		s_2 = s_01
	} else {
		s_1 = s_01
		s_2 = s_02
	}
	if s_2 < -0.96*math.Abs(f_uc) {
		// applying criteria:
		alpha = s_1 / s_2
		crit = -1 * ((1 + 3.8*alpha) * f_uc) / ((1 + alpha) * (1 + alpha))
		if s_2 <= crit {
			// crushing
			f_uc_new[0] = math.Abs(-0.96 * math.Abs(f_uc))
			return
		} else {
			// nothing
			return
		}
	}
	if s_2 < 0 {
		crit = (1 + 0.8*(s_2/f_uc)) * f_ut
		if s_1 >= crit {
			// cracking
			f_ut_new[0] = crit
			return
		} else {
			// nothing
			return
		}
	} else {
		if s_1 >= f_ut {
			// s2 > 0
			// cracking
			return
		} else {
			// nothing
			return
		}
	}
}

// femCEB_FIP_Test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:336
func femCEB_FIP_Test(s_01 float64, s_02 float64, f_uc float64, f_ut float64) (c4goDefaultReturn float64) {
	// Test material status using CEB-FIP criteria
	// * @return 0=uncracked, 1=tension, -1=compression
	// *
	var crit float64
	var alpha float64
	var s_1 float64
	var s_2 float64
	if s_02 > s_01 {
		// always must be s_1 > s_2:
		s_1 = s_02
		s_2 = s_01
	} else {
		s_1 = s_01
		s_2 = s_02
	}
	if s_2 < -0.96*math.Abs(f_uc) {
		// applying criteria:
		alpha = s_1 / s_2
		crit = -1 * ((1 + 3.8*alpha) * f_uc) / ((1 + alpha) * (1 + alpha))
		noarch.Fprintf(msgout, []byte(" CEB-FIP MC90: CRIT=%e S2=%e\n\x00"), crit, s_2)
		if s_2 <= crit {
			// crushing
			return float64(-1)
		} else {
			// nothing
			return float64(0)
		}
	}
	if s_2 < 0 && s_2 >= -0.96*math.Abs(f_uc) {
		crit = (1 + 0.8*(s_2/f_uc)) * f_ut
		noarch.Printf([]byte("CRIT=%e S1=%e\n\x00"), crit, s_1)
		if s_1 >= crit {
			// cracking
			return float64(1)
		} else {
			// nothing
			return float64(0)
		}
	} else {
		if s_1 >= f_ut {
			// s2 > 0
			// cracking
			return float64(1)
		} else {
			// nothing
			return float64(0)
		}
	}
	return
}

// D_Fill_Te - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:409
func D_Fill_Te(Te []tMatrix, TeT []tMatrix, fi0 float64) int32 {
	// Computes Te transformation matrix for 2D problem
	var c float64
	var s float64
	var fi float64
	var i int32
	var j int32
	if Te[0].rows != TeT[0].rows || Te[0].cols != TeT[0].cols || Te[0].rows != 3 || Te[0].cols != 3 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Transformation matrix not allocated or has invalid size\x00"))
		return -9
	}
	fi = 3.141592653589793 * (fi0 / 180)
	c = math.Cos(fi)
	s = math.Sin(fi)
	femMatPutAdd(Te, 1, 1, c*c, 0)
	femMatPutAdd(Te, 1, 2, s*s, 0)
	femMatPutAdd(Te, 1, 3, c*s, 0)
	femMatPutAdd(Te, 2, 1, s*s, 0)
	femMatPutAdd(Te, 2, 2, c*c, 0)
	femMatPutAdd(Te, 2, 3, -1*c*s, 0)
	femMatPutAdd(Te, 3, 1, -2*c*s, 0)
	femMatPutAdd(Te, 3, 2, 2*c*s, 0)
	femMatPutAdd(Te, 3, 3, c*c-s*s, 0)
	for i = 1; i <= 3; i++ {
		for j = 1; j <= 3; j++ {
			femMatPutAdd(TeT, i, j, femMatGet(Te, j, i), 0)
		}
	}
	return 0
}

// D_Plane_OrthoCB - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:463
func D_Plane_OrthoCB(R1 float64, R2 float64, nu float64, G float64, beta float64, fi_1 float64, Dcr []tMatrix) int32 {
	//
	// * Computes ortotropic D matrix (by me) )
	// * @param R1 stifness in 1st direction
	// * @param R2 stifness in 2nd direction
	// * @param nu poisson ratio
	// * @param G shear modulus
	// * @param beta G modulus multiplier
	// * @param fi_1 1st direction angle (grad)
	// * @param Dcr material stifness matrix
	// * @param
	//
	var rv int32
	//int i,j ;
	// "d" multiplier for Cervenka's matrix
	var dMult float64
	var Dc0 tMatrix
	var Dt tMatrix
	var TeT tMatrix
	var Te tMatrix
	// this line is needed only to avoid compiler warnings
	dMult = 0
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		// Allocating of matrix in local coordinates and transformation matrices:
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	if math.Abs(R1+R2) > 0 {
		// Cervenka and fixed by me:
		dMult = R2 / (R2 - nu*nu*R1)
	} else {
		dMult = 0
	}
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 1, dMult*R1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 2, dMult*nu*R1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 1, dMult*nu*R1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 2, dMult*R2, 0)
	//femMatPut(&Dc0,3,3, ((beta * G)  / dMult) ) ;
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 3, 3, beta*G, 0)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_0\x00"))
	// Transformation of Dc0 to global coordinates (Dcr):
	D_Fill_Te((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], fi_1)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], []byte("TE\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], []byte("TET\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_00\x00"))
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], Dcr)
	noarch.Fprintf(msgout, []byte("[!] R1=%f R2=%f nu=%f beta=%f phi=%f\n\x00"), R1, R2, nu, beta, fi_1)
memFree:
	;
	//FEM_PI*fi_1/180.0
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:])
	return rv
}

// D_Plane_OrthoCerv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:558
func D_Plane_OrthoCerv(R1 float64, R2 float64, nu float64, G float64, beta float64, fi_1 float64, Dcr []tMatrix) int32 {
	//
	// * Computes ortotropic D matrix (Cervenka et al - SBETA) )
	// * @param R1 stifness in 1st direction
	// * @param R2 stifness in 2nd direction
	// * @param nu poisson ratio
	// * @param G shear modulus
	// * @param beta G modulus multiplier
	// * @param fi_1 1st direction angle (grad)
	// * @param Dcr material stifness matrix
	// * @param
	//
	var rv int32
	var Dc0 tMatrix
	var Dt tMatrix
	var TeT tMatrix
	var Te tMatrix
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		// Allocating of matrix in local coordinates and transformation matrices:
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatSetZero(Dcr)
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	if R1 < 1e-17 {
		R1 = 1e-17
	}
	if R2 < 1e-17 {
		R2 = 1e-17
	}
	if beta < 1e-17 {
		beta = 1e-17
	}
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 1, 1/R1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 2, 1/R2, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 2, -nu/R2, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 1, -nu/R2, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 3, 3, 1/(beta*G), 0)
	femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	// Transformation of Dc0 to global coordinates (Dcr):
	D_Fill_Te((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], fi_1)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], []byte("TE\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], []byte("TET\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_00\x00"))
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], Dcr)
	noarch.Fprintf(msgout, []byte("[!] R1=%f R2=%f nu=%f beta=%f phi=%f\n\x00"), R1, R2, nu, beta, fi_1)
memFree:
	;
	//FEM_PI*fi_1/180.0
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:])
	return rv
}

// D_Plane_Ortho - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:623
func D_Plane_Ortho(R1 float64, R2 float64, nu float64, beta float64, fi_1 float64, Dcr []tMatrix) int32 {
	//
	// * Computes ortotropic D matrix (Bittnar-Sejnoha Numericke met. I  pp.21) )
	// * @param R1 stifness in 1st direction
	// * @param R2 stifness in 2nd direction
	// * @param nu poisson ratio
	// * @param G shear modulus
	// * @param beta G modulus multiplier
	// * @param fi_1 1st direction angle (grad)
	// * @param Dcr material stifness matrix
	// * @param
	//
	var rv int32
	//int i,j ;
	// "d" multiplier for Cervenka's matrix
	var dMult float64
	var Dc0 tMatrix
	var Dt tMatrix
	var TeT tMatrix
	var Te tMatrix
	// this line is needed only to avoid compiler warnings
	dMult = 0
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		// Allocating of matrix in local coordinates and transformation matrices:
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	dMult = 1 / (1 - nu*nu)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 1, dMult*R1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 2, dMult*nu*math.Sqrt(R1*R2), 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 1, dMult*nu*math.Sqrt(R1*R2), 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 2, dMult*R2, 0)
	//femMatPut(&Dc0,3,3, ((beta * G)  / dMult) ) ;
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 3, 3, beta*0.25*(R1+R2-2*nu*math.Sqrt(R1*R2)), 0)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_0\x00"))
	// Transformation of Dc0 to global coordinates (Dcr):
	D_Fill_Te((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], fi_1)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], []byte("TE\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], []byte("TET\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_00\x00"))
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], Dcr)
	noarch.Fprintf(msgout, []byte("[!] R1=%f R2=%f nu=%f beta=%f phi=%f\n\x00"), R1, R2, nu, beta, fi_1)
memFree:
	;
	//FEM_PI*fi_1/180.0
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:])
	return rv
}

// fem_Fill_Plane_Ds - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:682
func fem_Fill_Plane_Ds(p_x float64, E0 float64, phi float64, epsilon_sum []tVector, s_max float64, Mode int32, Ds []tMatrix) int32 {
	// Computes stifness matrix of reinforcement
	// unused
	// unused
	var rv int32
	var Te tMatrix
	var TeT tMatrix
	var D0 tMatrix
	var D1 tMatrix
	var E float64
	var i int32
	var j int32
	E = E0
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], 0, 3, 3, 0, nil)
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], 0, 3, 3, 0, nil)
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:], 0, 3, 3, 0, nil)
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D1))[:], 0, 3, 3, 0, nil)
	if Mode == 1 {
	}
	if (func() int32 {
		rv = D_Fill_Te((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], phi)
		return rv
	}()) != 0 {
		// non-linear code here
		goto memFree
	}
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:], 1, 1, p_x*E, 0)
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D1))[:])
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&D1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D0))[:])
	for i = 1; i <= 3; i++ {
		for j = 1; j <= 3; j++ {
			femMatPutAdd(Ds, i, j, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:], i, j), 1)
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D1))[:])
	return rv
}

// D_ConcCrack2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr2.c:740
func D_ConcCrack2D(ePos int32, iPoint int32, A float64, epsilon []tVector, newM int32, Problem int32, D []tMatrix) int32 {
	// Creates material stifness matrix for 2D plane stress (concrete)
	// *  @param E    Young modulus
	// *  @param nu   Poisson ratio
	// *  @param Type   type of "D": 0..plane stress, 1..plane strain
	// *  @param D   matrix (must be [4,4] and only indexes 1,2,3 are filled!)
	//
	var rv int32
	//long   state = 0;
	var E float64
	var nu float64
	var G float64
	var s_tens float64
	var s_cmpr float64
	var Gf float64
	var phi float64
	var res_E1 float64
	var res_E2 float64
	var res_phi float64
	var res_beta float64
	var f_ut_new float64
	var f_uc_new float64
	var epsilon_1 tVector
	var sigma_x tVector
	var sigma_1 tVector
	var Ts tMatrix
	var E_s float64
	var ps_x1 float64
	var ps_x2 float64
	var phi_s1 float64
	var phi_s2 float64
	femMatSetZero(D)
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	E = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	s_tens = femGetMPValPos(ePos, 7, 0)
	s_cmpr = femGetMPValPos(ePos, 8, 0)
	Gf = femGetMPValPos(ePos, 9, 0)
	E_s = femGetMPValPos(ePos, 10, 0)
	phi_s1 = femGetRSValPos(ePos, 4, 0)
	ps_x1 = femGetRSValPos(ePos, 5, 0)
	phi_s2 = femGetRSValPos(ePos, 6, 0)
	ps_x2 = femGetRSValPos(ePos, 7, 0)
	G = E / (2 * (1 + nu))
	res_E1 = femGetRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	res_E2 = femGetRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	res_phi = femGetRepVal(ePos, 30, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	res_beta = femGetRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	if res_E1 == 0 && res_E2 == 0 && res_phi == 0 && newM == 0 {
		// data initialization - if needed
		res_E1 = E
		res_E2 = E
		res_phi = 0
		res_beta = 1
		femAddPutRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E1)
		femAddPutRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E2)
		femAddPutRepVal(ePos, 30, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_phi)
		femAddPutRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_beta)
	}
	if (func() int32 {
		rv = D_Plane_OrthoCB(E, E, nu, G, 1, 0, D)
		return rv
	}()) != 0 {
		//#ifndef PSEUDO_SEC
		goto memFree
	}
	if newM == 1 {
		// new stifness matrix
		femMatVecMult(D, epsilon, (*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
		// compute princ. stresses here !
		femGetPrincStress2D((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], c4goUnsafeConvert_float64(&phi))
		femTs_2d((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], phi)
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], epsilon, (*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:])
		femCEB_FIP_Val(femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2), s_cmpr, s_tens, c4goUnsafeConvert_float64(&f_uc_new), c4goUnsafeConvert_float64(&f_ut_new))
		res_E1 = chenGetRt(E, Gf, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 1), f_ut_new, f_uc_new, math.Sqrt(A))
		res_E2 = chenGetRt(E, Gf, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 2), f_ut_new, f_uc_new, math.Sqrt(A))
		if femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 1) > 0 {
			res_beta = betaCoeff(femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 1), E, res_E1)
		} else {
			res_beta = 1
		}
		if res_E1 < E || res_E2 < E {
			res_phi = phi
		} else {
			//printf("PHI = %e\n",res_phi);
			res_phi = 0
		}
		//printf("NORM: %f %f %f %f\n",res_E1, res_E2, f_ut_new, f_uc_new);
		femAddPutRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E1)
		femAddPutRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E2)
		femAddPutRepVal(ePos, 30, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_phi)
		femAddPutRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_beta)
		if (func() int32 {
			rv = D_Plane_OrthoCB(res_E1, res_E2, nu, G, res_beta, res_phi, D)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	//femMatPrn(D,"D_new_00");
	// in all cases:
	fem_Fill_Plane_Ds(ps_x1, E_s, phi_s1, nil, 0, newM, D)
	// unused
	// unused
	fem_Fill_Plane_Ds(ps_x2, E_s, phi_s2, nil, 0, newM, D)
memFree:
	;
	// unused
	// unused
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:])
	return rv
}

// fem_ccr_ortho_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr3.c:49
func fem_ccr_ortho_matrix(Ex float64, E1 float64, nu float64, G float64, beta float64, D []tMatrix) int32 {
	//
	//   File name: fem_ccr3.c
	//   Date:      2004/05/15 16:40
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// from "fem_ccr2.c":
	// from "fem_chen.h":
	// Computes orthotropic matrix for smeared crack model
	// * @param Ex cracked stiffness modulus
	// * @param E1 stiffness modulus in other directions
	// * @param nu Poisson's ratio
	// * @param G  shear modulus
	// * @param beta  here modulus reduction factor
	// * @param D matrix (must me allocated)
	// * @return status
	// *
	var rv int32
	// stiffness matrix derived by Lenka Lausova:
	femMatSetZero(D)
	femMatPutAdd(D, 1, 1, (1-nu)*Ex/(1-nu-2*(Ex/E1))*nu*nu, 0)
	femMatPutAdd(D, 1, 2, nu*Ex/(1-nu-2*(Ex/E1))*nu*nu, 0)
	femMatPutAdd(D, 1, 3, nu*Ex/(1-nu-2*(Ex/E1))*nu*nu, 0)
	femMatPutAdd(D, 2, 1, nu*Ex/(1-nu-2*(Ex/E1))*nu*nu, 0)
	femMatPutAdd(D, 2, 2, (E1-nu*nu*Ex)/((1+nu)*(1-nu-2*(Ex/E1))*nu*nu), 0)
	femMatPutAdd(D, 2, 3, nu*(E1+nu*Ex)/((1+nu)*(1-nu-2*(Ex/E1))*nu*nu), 0)
	femMatPutAdd(D, 3, 1, nu*Ex/(1-nu-2*(Ex/E1))*nu*nu, 0)
	femMatPutAdd(D, 3, 2, nu*(E1+nu*Ex)/((1+nu)*(1-nu-2*(Ex/E1))*nu*nu), 0)
	femMatPutAdd(D, 3, 3, (E1-nu*nu*Ex)/((1+nu)*(1-nu-2*(Ex/E1))*nu*nu), 0)
	femMatPutAdd(D, 4, 4, 2*G, 0)
	femMatPutAdd(D, 5, 5, 2*beta*G, 0)
	femMatPutAdd(D, 6, 6, 2*beta*G, 0)
	femMatPrn(D, []byte("D_ortho\x00"))
	return rv
}

// D_fill_T_TT - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr3.c:132
func D_fill_T_TT(m11 float64, m12 float64, m13 float64, m21 float64, m22 float64, m23 float64, m31 float64, m32 float64, m33 float64, Te []tMatrix, TeT []tMatrix) int32 {
	var rv int32
	femMatPutAdd(Te, 1, 1, m11*m11, 0)
	femMatPutAdd(Te, 1, 2, m12*m12, 0)
	femMatPutAdd(Te, 1, 3, m13*m13, 0)
	femMatPutAdd(Te, 1, 4, 2*m12*m13, 0)
	femMatPutAdd(Te, 1, 5, 2*m11*m13, 0)
	femMatPutAdd(Te, 1, 6, 2*m11*m12, 0)
	femMatPutAdd(Te, 2, 1, m21*m21, 0)
	femMatPutAdd(Te, 2, 2, m22*m22, 0)
	femMatPutAdd(Te, 2, 3, m23*m23, 0)
	femMatPutAdd(Te, 2, 4, 2*m22*m23, 0)
	femMatPutAdd(Te, 2, 5, 2*m21*m23, 0)
	femMatPutAdd(Te, 2, 6, 2*m21*m22, 0)
	femMatPutAdd(Te, 3, 1, m31*m31, 0)
	femMatPutAdd(Te, 3, 2, m32*m32, 0)
	femMatPutAdd(Te, 3, 3, m33*m33, 0)
	femMatPutAdd(Te, 3, 4, 2*m32*m33, 0)
	femMatPutAdd(Te, 3, 5, 2*m31*m33, 0)
	femMatPutAdd(Te, 3, 6, 2*m31*m32, 0)
	femMatPutAdd(Te, 4, 1, m21*m31, 0)
	femMatPutAdd(Te, 4, 2, m22*m32, 0)
	femMatPutAdd(Te, 4, 3, m23*m33, 0)
	femMatPutAdd(Te, 4, 4, m22*m33+m23*m32, 0)
	femMatPutAdd(Te, 4, 5, m21*m33+m23*m31, 0)
	femMatPutAdd(Te, 4, 6, m21*m32+m22*m31, 0)
	femMatPutAdd(Te, 5, 1, m11*m31, 0)
	femMatPutAdd(Te, 5, 2, m12*m32, 0)
	femMatPutAdd(Te, 5, 3, m13*m33, 0)
	femMatPutAdd(Te, 5, 4, m12*m33+m13*m32, 0)
	femMatPutAdd(Te, 5, 5, m11*m33+m13*m31, 0)
	femMatPutAdd(Te, 5, 6, m11*m32+m12*m31, 0)
	femMatPutAdd(Te, 6, 1, m11*m21, 0)
	femMatPutAdd(Te, 6, 2, m12*m22, 0)
	femMatPutAdd(Te, 6, 3, m13*m23, 0)
	femMatPutAdd(Te, 6, 4, m12*m23+m13*m22, 0)
	femMatPutAdd(Te, 6, 5, m11*m23+m13*m21, 0)
	femMatPutAdd(Te, 6, 6, m11*m22+m12*m21, 0)
	if (func() int32 {
		rv = femLUinverse(Te)
		return rv
	}()) != 0 {
		return rv
	}
	femMatTran(Te, TeT)
	return rv
}

// D_ConcCrack3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr3.c:203
func D_ConcCrack3D(ePos int32, iPoint int32, A float64, sigma_x []tVector, epsilon []tVector, newM int32, D []tMatrix) int32 {
	// Creates material stifness matrix for 3D
	// *  @param E    Young modulus
	// *  @param nu   Poisson ratio
	// *  @param Type   type of "D": 0..plane stress, 1..plane strain
	// *  @param D   matrix (must be [4,4] and only indexes 1,2,3 are filled!)
	//
	var rv int32
	var E float64
	var nu float64
	var G float64
	var s_tens float64
	var s_cmpr float64
	var Gf float64
	var res_E1 float64
	var res_E2 float64
	var res_beta float64
	//double f_ut_new, f_uc_new ;
	var m11 float64
	var m12 float64
	var m13 float64
	var m21 float64
	var m22 float64
	var m23 float64
	var m31 float64
	var m32 float64
	var m33 float64
	var cczone int32
	var M tMatrix
	var Te tMatrix
	var TeT tMatrix
	var D0 tMatrix
	var TD0 tMatrix
	var epsilon_1 tVector
	var sigma_1 tVector
	femMatSetZero(D)
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TD0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	E = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	s_tens = femGetMPValPos(ePos, 7, 0)
	s_cmpr = femGetMPValPos(ePos, 8, 0)
	Gf = femGetMPValPos(ePos, 9, 0)
	G = E / (2 * (1 + nu))
	res_E1 = femGetRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	res_E2 = femGetRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	res_beta = femGetRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	if newM != 1 {
		// new stifness matrix
		m11 = femGetRepVal(ePos, 39, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m12 = femGetRepVal(ePos, 40, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m13 = femGetRepVal(ePos, 41, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m21 = femGetRepVal(ePos, 42, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m22 = femGetRepVal(ePos, 43, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m23 = femGetRepVal(ePos, 44, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m31 = femGetRepVal(ePos, 45, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m32 = femGetRepVal(ePos, 46, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		m33 = femGetRepVal(ePos, 47, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		if res_E1 == 0 && res_E2 == 0 {
			// data initialization - if needed
			res_E1 = E
			res_E2 = E
			res_beta = 1
			m11 = 1
			m12 = 0
			m13 = 0
			m21 = 0
			m22 = 1
			m23 = 0
			m31 = 0
			m32 = 0
			m33 = 1
			femAddPutRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E1)
			femAddPutRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E2)
			femAddPutRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_beta)
			femAddPutRepVal(ePos, 39, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m11)
			femAddPutRepVal(ePos, 40, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m12)
			femAddPutRepVal(ePos, 41, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m13)
			femAddPutRepVal(ePos, 42, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m21)
			femAddPutRepVal(ePos, 43, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m22)
			femAddPutRepVal(ePos, 44, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m23)
			femAddPutRepVal(ePos, 45, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m31)
			femAddPutRepVal(ePos, 46, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m32)
			femAddPutRepVal(ePos, 47, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m33)
		}
	} else {
		if (func() int32 {
			rv = femPrinc3D(sigma_x, (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
			return rv
		}()) != 0 {
			// new stifness matrix
			noarch.Fprintf(msgout, []byte("[E] %s?!\n\x00"), []byte("Computation of principal stresses failed\x00"))
			goto memFree
		}
		femPrinc3dTranM(sigma_x, (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		m11 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 1, 1)
		m12 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 1, 2)
		m13 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 1, 3)
		m21 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 2, 1)
		m22 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 2, 2)
		m23 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 2, 3)
		m31 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 3, 1)
		m32 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 3, 2)
		m33 = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 3, 3)
		femVecPrn(sigma_x, []byte("S_X\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], []byte("S_1\x00"))
		noarch.Printf([]byte("m: %e %e %e %e %e %e %e %e %e\n\x00"), m11, m12, m13, m21, m22, m23, m31, m32, m33)
		if (func() int32 {
			rv = D_fill_T_TT(m11, m12, m13, m21, m22, m23, m31, m32, m33, (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
			return rv
		}()) != 0 {
			goto memFree
		}
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], epsilon, (*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:])
		if chen_limit_test(sigma_x, s_cmpr, s_cmpr*1.2, s_tens, c4goUnsafeConvert_int32(&cczone)) == 1 {
			if cczone != 1 {
				// NOTE: this ignores peak stresses dependence on 3D stress state:
				res_E1 = chenGetRt(E, Gf, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 1), s_tens, s_cmpr, math.Sqrt(A))
				// should be changed later
				res_E2 = E
				if femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 1) > 0 {
					res_beta = betaCoeff(femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:], 1), E, res_E1)
				} else {
					res_beta = 1
				}
				femAddPutRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E1)
				femAddPutRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_E2)
				femAddPutRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, res_beta)
				femAddPutRepVal(ePos, 39, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m11)
				femAddPutRepVal(ePos, 40, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m12)
				femAddPutRepVal(ePos, 41, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m13)
				femAddPutRepVal(ePos, 42, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m21)
				femAddPutRepVal(ePos, 43, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m22)
				femAddPutRepVal(ePos, 44, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m23)
				femAddPutRepVal(ePos, 45, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m31)
				femAddPutRepVal(ePos, 46, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m32)
				femAddPutRepVal(ePos, 47, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, m33)
			}
		}
	}
	if (func() int32 {
		rv = fem_ccr_ortho_matrix(res_E1, res_E2, nu, G, res_beta, (*[1000000]tMatrix)(unsafe.Pointer(&D0))[:])
		return rv
	}()) != 0 {
		// matrix is created from computed data:
		goto memFree
	}
	if (func() int32 {
		rv = D_fill_T_TT(m11, m12, m13, m21, m22, m23, m31, m32, m33, (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
		return rv
	}()) != 0 {
		// matrix must be rotated HERE!
		goto memFree
	}
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TD0))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TD0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], D)
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_1))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TD0))[:])
	return rv
}

// fem_D_ccr3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ccr3.c:392
func fem_D_ccr3D(ePos int32, e_rep int32, eT int32, mT int32, sigma []tVector, epsilon []tVector, Mode int32, D []tMatrix) int32 {
	var rv int32
	var A float64 = 1
	var x1 float64
	var y1 float64
	var z1 float64
	var x2 float64
	var y2 float64
	var z2 float64
	var x3 float64
	var y3 float64
	var z3 float64
	var x4 float64
	var y4 float64
	var z4 float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	if Elem[eT].nodes <= 8 {
		x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
		y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
		z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
		x3 = femGetDblPos(femGetIntLPos(ePos, 4, eFrom, eNodesL, eLenL), n_x, nLen)
		y3 = femGetDblPos(femGetIntLPos(ePos, 4, eFrom, eNodesL, eLenL), n_y, nLen)
		z3 = femGetDblPos(femGetIntLPos(ePos, 4, eFrom, eNodesL, eLenL), n_z, nLen)
		x4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_x, nLen)
		y4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_y, nLen)
		z4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_z, nLen)
	} else {
		if Elem[eT].nodes <= 24 {
			x2 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_x, nLen)
			y2 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_y, nLen)
			z2 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_z, nLen)
			x3 = femGetDblPos(femGetIntLPos(ePos, 8, eFrom, eNodesL, eLenL), n_x, nLen)
			y3 = femGetDblPos(femGetIntLPos(ePos, 8, eFrom, eNodesL, eLenL), n_y, nLen)
			z3 = femGetDblPos(femGetIntLPos(ePos, 8, eFrom, eNodesL, eLenL), n_z, nLen)
			x4 = femGetDblPos(femGetIntLPos(ePos, 6, eFrom, eNodesL, eLenL), n_x, nLen)
			y4 = femGetDblPos(femGetIntLPos(ePos, 6, eFrom, eNodesL, eLenL), n_y, nLen)
			z4 = femGetDblPos(femGetIntLPos(ePos, 6, eFrom, eNodesL, eLenL), n_z, nLen)
		} else {
			return -9
		}
	}
	A = math.Pow(math.Sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2))*math.Sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3)+(z1-z3)*(z1-z3))*math.Sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4)+(z1-z4)*(z1-z4))/(1/3), 2)
	rv = D_ConcCrack3D(ePos, e_rep-1, A, sigma, epsilon, Mode, D)
	return rv
}

// stress2D_I1 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:38
func stress2D_I1(stress []tVector) float64 {
	//
	//   File name: fem_ch2d.c
	//   Date:      2007/11/25 10:28
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2007 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM solver: 2D Chen-Chen plasticity condition
	//
	// from fem_stf2.c
	// Computes 1st stress invariant I1
	// * @param stress  3-compoment stress vector {s_x, s_y, s_xy}
	// * @return I1
	return femVecGet(stress, 1) + femVecGet(stress, 2)
}

// stress2D_J2 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:46
func stress2D_J2(stress []tVector) float64 {
	// Computes 2nd invariant of stress deviator J2
	// * @param stress  3-compoment stress vector {s_x, s_y, s_xy}
	// * @return J2
	var s_x float64
	var s_y float64
	var t_xy float64
	s_x = femVecGet(stress, 1)
	s_y = femVecGet(stress, 2)
	t_xy = femVecGet(stress, 3)
	return (math.Pow(s_x-s_y, 2)+s_x*s_x+s_y*s_y)/6 + t_xy*t_xy
}

// stress2D_J2dev - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:62
func stress2D_J2dev(stress []tVector) float64 {
	// Computes 2nd invariant of stress deviator J2
	// * @param stress  3-compoment stress vector {s_x, s_y, s_xy}
	// * @return J2
	var s_x float64
	var s_y float64
	var t_xy float64
	var s_q float64
	s_q = (femVecGet(stress, 1) + femVecGet(stress, 2)) / 3
	s_x = femVecGet(stress, 1) - s_q
	s_y = femVecGet(stress, 2) - s_q
	t_xy = femVecGet(stress, 3)
	return (math.Pow(s_x-s_y, 2)+s_x*s_x+s_y*s_y)/6 + t_xy*t_xy
}

// chen2d_get_A_tau2_y - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:89
func chen2d_get_A_tau2_y(fc float64, fbc float64, ft float64, Ac []float64, At []float64, tau2c []float64, tau2t []float64) int32 {
	// Computes material data for Chen yield criteria
	// * @param fc  compresive strenth
	// * @param fbc  biaxial compresive strenth
	// * @param ft  tensile strenth
	// * @param Ac  Ac material constant
	// * @param At  At material constant
	// * @param tau2c  tau^2_c material constant
	// * @param tau2t  tau^2_t material constant
	// * @return status
	//
	Ac[0] = (fbc*fbc - fc*fc) / (2*fbc - fc)
	At[0] = (fc - ft) / 2
	tau2c[0] = fbc * fc * (2*fc - fbc) / (3 * (2*fbc - fc))
	tau2t[0] = fc * ft / 6
	return 0
}

// chen2d_check_yield - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:109
func chen2d_check_yield(I1 float64, J2 float64, Ac float64, At float64, tau2c float64, tau2t float64) int32 {
	if I1 < 0 && math.Sqrt(J2)+I1/3 < 0 {
		// Checks the yield condition
		// * @param I1 1st stress invariant
		// * @param J2 2nd stress deviator invariant
		// * @param Ac  Ac material constant
		// * @param At  At material constant
		// * @param tau2c  tau^2_c material constant
		// * @param tau2t  tau^2_t material constant
		// * @return -1 for c-c plastic, +1 for ofthe plastic, 0 for elastic
		//
		// compression-compression zone:
		fmt.Printf("C-C\n")
		if J2+Ac*I1/3-tau2c > 0 {
			return -1
		}
	} else {
		if I1 >= 0 && math.Sqrt(J2)+I1/3 >= 0 {
			// other zones:
			fmt.Printf("T-T\n")
		} else {
			fmt.Printf("C-T\n")
		}
		if J2-I1*I1/6+At*I1/3-tau2t > 0 {
			return 1
		}
	}
	// must be elastic...
	return 0
}

// chen2d_alpha_beta - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:135
func chen2d_alpha_beta(Ay float64, Au float64, tau2y float64, tau2u float64, alpha []float64, beta []float64) int32 {
	// Computes parameters for intermediate conditions (c or t)
	// * @parameters Ay yield A Chen constant
	// * @parameters Au ultimate A Chen constant
	// * @parameters tau2y yield tau2 Chen constant
	// * @parameters tau2u ultimate tau2 Chen constant
	// * @return status
	//
	alpha[0] = (Au - Ay) / (tau2u - tau2y)
	beta[0] = (Ay*tau2u - Au*tau2y) / (tau2u - tau2y)
	return 0
}

// chen2d_equivalent_limits - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:157
func chen2d_equivalent_limits(status int32, ratio float64, I1 float64, J2 float64, alpha_c float64, beta_c float64, alpha_t float64, beta_t float64, sigma_c []float64, sigma_bc []float64, sigma_t []float64) int32 {
	// Computes equivalent limits (sigma_c, sigma_bc, sigma_t)
	// * for intermediate yield conditions
	// *
	// * @param I1 1st stress invariant
	// * @param J2 2nd stress deviator invariant
	// * @param alpha_c alpha intermediate parameter for compression
	// * @param beta_c beta intermediate parameter for compression
	// * @param alpha_t alpha intermediate parameter for tension
	// * @param beta_t beta intermediate parameter for tension
	// * @param sigma_c equivalent unixal compression limit
	// * @param sigma_bc equivalent biaxial compression limit
	// * @param sigma_t equivalent unixal tension limit
	// * @return status
	//
	// TODO: verify these equation - they have not to work:
	var t2 float64
	if status == -1 {
		// C-C
		{
		}
	} else {
		// TODO
		//  T-T, C-T, T-C
		// TODO
		t2 = (J2 + beta_t*I1/3 - I1*I1/6) / (1 - alpha_t*I1/3)
		sigma_t[0] = math.Sqrt(6 * t2)
		sigma_c[0] = ratio * sigma_t[0]
		sigma_bc[0] = 1.2 * sigma_c[0]
	}
	return 0
}

// chen2d_solve_eq_stresses - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:199
func chen2d_solve_eq_stresses(zone int32, I1 float64, J2 float64, alfac float64, betac float64, alfat float64, betat float64, a float64, fc []float64, fbc []float64, ft []float64) int32 {
	// TODO Computes equivalent stresses fc, fbc, ft for given stress
	// * state
	// *
	// -1 = C-C, 1=ost.
	// fybc/fc
	var tau2t float64
	var At float64
	var tau2c float64
	var Ac float64
	var ft1 float64
	var ft2 float64
	if zone >= 0 {
		tau2t = (J2 + I1*(2*betat-I1)/6) / (1 - alfat*I1/3)
		At = alfat*tau2t + betat
		ft1 = -1 * (At + math.Pow(math.Pow(2*At, 2)+24*tau2t, 1/2)*1/2)
		ft2 = -1 * (At + math.Pow(math.Pow(2*At, 2)+24*tau2t, 1/2)*-1/2)
		fbc[0] = 0
	} else {
		tau2c = (J2 + betac*I1/3) / (1 - alfac*I1/3)
		Ac = alfac*tau2c + betac
		ft[0] = 0
	}
	//auto-generated from mathomatic for C-C:
	//   * a=fybc/fyc
	//
	return 0
}

// chen2d_derivations_cc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:257
func chen2d_derivations_cc(alpha_c float64, beta_c float64, sigma_c float64, sigma_bc float64, sigma_t float64, sigma_x float64, sigma_y float64, tau_xy float64, deriv []tVector) int32 {
	// Computes the derivations of plascicity condition for C-C
	// * @param alpha_c alpha intermediate parameter for compression
	// * @param beta_c beta intermediate parameter for compression
	// * @param alpha_t alpha intermediate parameter for tension
	// * @param beta_t beta intermediate parameter for tension
	// * @param a relation a=sigma_bc/sigma_c (initial)
	// * @param sigma_c equivalent unixal compression limit
	// * @param sigma_bc equivalent biaxial compression limit
	// * @param sigma_t equivalent unixal tension limit
	// * @param sigma_x actual stress Sigma X
	// * @param sigma_y actual stress Sigma Y
	// * @param tau_xy actual stress TAu xy
	// * @param deriv derivatives (result)
	// * @return status
	//
	femVecPutAdd(deriv, 1, -1*(sigma_bc-2*sigma_c)*alpha_c*sigma_bc*sigma_c/(9*(2*sigma_bc-sigma_c))+beta_c/3+2/3*sigma_x-sigma_y/3, 0)
	femVecPutAdd(deriv, 2, -1*(sigma_bc-2*sigma_c)*alpha_c*sigma_bc*sigma_c/(9*(2*sigma_bc-sigma_c))+beta_c/3+2/3*sigma_y-sigma_x/3, 0)
	femVecPutAdd(deriv, 3, 2*tau_xy, 0)
	return 0
}

// chen2d_derivations_ct - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:296
func chen2d_derivations_ct(alpha_t float64, beta_t float64, sigma_c float64, sigma_bc float64, sigma_t float64, sigma_x float64, sigma_y float64, tau_xy float64, deriv []tVector) int32 {
	// Computes the derivations of plascicity condition for C-T
	// * @param alpha_c alpha intermediate parameter for compression
	// * @param beta_c beta intermediate parameter for compression
	// * @param alpha_t alpha intermediate parameter for tension
	// * @param beta_t beta intermediate parameter for tension
	// * @param a relation a=sigma_bc/sigma_c (initial)
	// * @param sigma_c equivalent unixal compression limit
	// * @param sigma_bc equivalent biaxial compression limit
	// * @param sigma_t equivalent unixal tension limit
	// * @param sigma_x actual stress Sigma X
	// * @param sigma_y actual stress Sigma Y
	// * @param tau_xy actual stress TAu xy
	// * @param deriv derivatives (result)
	// * @return status
	//
	femVecPutAdd(deriv, 1, 1/18*alpha_t*sigma_c*sigma_t-beta_t/3+sigma_x, 0)
	femVecPutAdd(deriv, 2, 1/18*alpha_t*sigma_c*sigma_t-beta_t/3+sigma_y, 0)
	femVecPutAdd(deriv, 3, 2*tau_xy, 0)
	return 0
}

// chen2d_H_Ohtani - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:314
func chen2d_H_Ohtani(ePos int32, status int32, E0 float64, s_c float64, s_bc float64, s_t float64, I1 float64, J2 float64) float64 {
	// Computes hardening parameter according to Ohtani+Chen
	var jj int32
	var a1 float64
	var a2 float64
	var a3 float64
	var Q1 float64
	var Q2 float64
	var Q3 float64
	var H1 float64
	var H2 float64
	var H3 float64
	var k []float64 = make([]float64, 4)
	var n []float64 = make([]float64, 4)
	if status < 0 {
		// alpha multipliers:
		// C-C
		a1 = 1
		a2 = 1
		a3 = 0
	} else {
		if I1 <= 0 && math.Sqrt(J2)+I1/3 >= 0 {
			// other areas
			// T-T
			a1 = 0
			a2 = 0
			a3 = 1
		} else {
			if s_c+s_t != 0 {
				// C-T, T-C
				a1 = (s_t - I1) / (s_c + s_t)
				a2 = (s_t - I1) / (s_c + s_t)
				a3 = (s_c + I1) / (s_c + s_t)
			} else {
				noarch.Fprintf(msgout, []byte("Impossible stress state in element %li!\n\x00"), ePos)
				a1 = 1e-17
				a2 = 1e-17
				a3 = 1e-17
			}
		}
	}
	if float64(status) < 0 {
		// get Q derivatives
		// TODO - check this
		Q1 = (s_c*s_c - 4*s_c*s_bc + s_bc*s_bc) * (I1 + 2*s_bc) / (3 * math.Pow(2*s_bc-s_c, 2))
		// ?
		Q2 = (s_c*s_c - 4*s_c*s_bc + s_bc*s_bc) * (I1 + s_bc) / (3 * math.Pow(2*s_bc-s_c, 2))
		Q3 = 0
	} else {
		Q1 = 1 / 6 * (I1 - s_c)
		Q2 = 0
		Q3 = 1 / 6 * (I1 - s_c)
	}
	{
		// obtain k, n HERE
		for jj = 1; jj <= 3; jj++ {
			k[jj] = femGetMPValPos(ePos, 30, jj)
			n[jj] = femGetMPValPos(ePos, 31, jj)
			noarch.Fprintf(msgout, []byte("KN[%i] %e %e\n\x00"), jj, k[jj], n[jj])
		}
	}
	noarch.Printf([]byte("Stresses s_c=%e s_bc=%e s_t=%e\n\x00"), s_c, s_bc, s_t)
	// C
	H1 = E0 * math.Pow(s_c/E0, 1-n[1]) / (k[1] * n[1])
	// BC
	H2 = E0 * math.Pow(s_bc/E0, 1-n[2]) / (k[2] * n[2])
	// T
	H3 = E0 * math.Pow(s_t/E0, 1-n[3]) / (k[3] * n[3])
	noarch.Fprintf(msgout, []byte("H1=%e H2=%e H3=%e(%e)\n\x00"), H1, H2, H3, s_t/E0)
	return a1*Q1*H1 + a2*Q2*H2 + a3*Q3*H3
}

// chen2d_D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ch2d.c:413
func chen2d_D(ePos int32, e_rep int32, Problem int32, epsilon []tVector, Mode int32, Dep []tMatrix) int32 {
	// computes stiffness matrix of Chen material
	// * @param ePos element index
	// * @param e_rem integration point
	// * @param Problem - problem type (ignored here)
	// * @param epsilon shear vector [3]
	// * @param Mode if ==AY_YES then new matrix is created
	// * @param Dep pointer to (allocated!) stiffness matrix (resul)
	//
	var rv int32
	var i int32
	var j int32
	var Ex float64
	var nu float64
	var f_yc float64
	var f_ybc float64
	var f_yt float64
	var f_uc float64
	var f_ubc float64
	var f_ut float64
	var alpha_c float64
	var beta_c float64
	var alpha_t float64
	var beta_t float64
	var H float64
	var sum float64
	var Auc float64
	var Aut float64
	var tauu2c float64
	var tauu2t float64
	var Ayc float64
	var Ayt float64
	var tauy2c float64
	var tauy2t float64
	var tau2c float64
	var tau2t float64
	var sigma_c float64
	var sigma_bc float64
	var sigma_t float64
	var status int32
	var status_old int32
	var I1 float64
	var J2 float64
	var sigma tVector
	var sigma_ps tVector
	var deriv tVector
	var De tMatrix
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_ps))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_ps))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	// get current material status: 0=elastic ; -1=CC; +1=other ;
	//   * 2=unloading
	status = int32(femGetRepVal(ePos, 63, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	// material properties:
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	f_yc = femGetMPValPos(ePos, 12, 0)
	f_ybc = femGetMPValPos(ePos, 13, 0)
	f_yt = femGetMPValPos(ePos, 14, 0)
	f_uc = femGetMPValPos(ePos, 15, 0)
	f_ubc = femGetMPValPos(ePos, 16, 0)
	f_ut = femGetMPValPos(ePos, 17, 0)
	H = 0
	if status == 0 || status == 2 {
		// get initial/previous matrix
		// elastic or unloading
		D_HookIso_planeRaw(Ex, nu, Problem, Dep)
		fmt.Printf("LINEAR - OLD !\n")
	} else {
		// plastic
		fmt.Printf("PLASTIC - OLD !\n")
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 1, femGetRepVal(ePos, 28, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 2, femGetRepVal(ePos, 29, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 3, femGetRepVal(ePos, 31, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		H = femGetRepVal(ePos, 64, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		noarch.Printf([]byte("DERIV %e  %e  %e\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 3))
		D_HookIso_planeRaw(Ex, nu, Problem, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
	}
	if Mode == 1 {
		// new matrix
		status_old = status
		D_HookIso_planeRaw(Ex, nu, Problem, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		// get current total stress:
		femMatVecMult(Dep, epsilon, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1, femGetRepVal(ePos, 7, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2, femGetRepVal(ePos, 8, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3, femGetRepVal(ePos, 10, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		noarch.Printf([]byte("SIGMA: %e  %e  %e\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
		I1 = stress2D_I1((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		J2 = stress2D_J2((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		// get data for yield condition
		chen2d_get_A_tau2_y(f_yc, f_ybc, f_yt, c4goUnsafeConvert_float64(&Ayc), c4goUnsafeConvert_float64(&Ayt), c4goUnsafeConvert_float64(&tauy2c), c4goUnsafeConvert_float64(&tauy2t))
		// check plasticity condition
		status = chen2d_check_yield(I1, J2, Ayc, Ayt, tauy2c, tauy2t)
		if status == 0 && status_old != 0 {
			// respect unloading
			status = 2
		}
		noarch.Printf([]byte("STATUS [%li,%li]: %li\n\x00"), ePos, e_rep, status)
		if status == 0 || status == 2 {
			// elastic or unloading
			// elastic or unloading
			D_HookIso_planeRaw(Ex, nu, Problem, Dep)
			fmt.Printf("LINEAR\n")
		} else {
			// plastic
			fmt.Printf("PLASTIC!\n")
			chen2d_get_A_tau2_y(f_uc, f_ubc, f_ut, c4goUnsafeConvert_float64(&Auc), c4goUnsafeConvert_float64(&Aut), c4goUnsafeConvert_float64(&tauu2c), c4goUnsafeConvert_float64(&tauu2t))
			chen2d_alpha_beta(Ayc, Auc, tauy2c, tauu2c, c4goUnsafeConvert_float64(&alpha_c), c4goUnsafeConvert_float64(&beta_c))
			chen2d_alpha_beta(Ayt, Aut, tauy2t, tauu2t, c4goUnsafeConvert_float64(&alpha_t), c4goUnsafeConvert_float64(&beta_t))
			// TODO compute intermediate equation parameters:
			chen2d_equivalent_limits(status, 0.5*(f_uc/f_ut+f_yc/f_yt), I1, J2, alpha_c, beta_c, alpha_t, beta_t, c4goUnsafeConvert_float64(&sigma_c), c4goUnsafeConvert_float64(&sigma_bc), c4goUnsafeConvert_float64(&sigma_t))
			// derivatives
			chen2d_derivations_ct(alpha_t, beta_t, sigma_c, sigma_bc, sigma_t, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3), (*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
			// get H:
			H = chen2d_H_Ohtani(ePos, status, Ex, sigma_c, sigma_bc, sigma_t, I1, J2)
			// get elastoplastic matrix
			chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
			femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], []byte("DE\x00"))
			femMatPrn(Dep, []byte("DEP\x00"))
			// get NEW current total stress:
			femMatVecMult(Dep, epsilon, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
			noarch.Printf([]byte("SIGMA PL0: %e  %e  %e\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1, femGetRepVal(ePos, 7, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2, femGetRepVal(ePos, 8, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3, femGetRepVal(ePos, 10, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
			noarch.Printf([]byte("SIGMA PL:  %e  %e  %e\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
		}
		// if plastic
		// save status
		femAddPutRepVal(ePos, 63, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(status))
		femAddPutRepVal(ePos, 28, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 1))
		femAddPutRepVal(ePos, 29, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 2))
		femAddPutRepVal(ePos, 31, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 3))
		femAddPutRepVal(ePos, 64, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, H)
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_ps))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	return rv
}

// stress3D_I1 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:49
func stress3D_I1(stress []tVector) float64 {
	//
	//   File name: fem_chen.c
	//   Date:      2004/01/03 18:26
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM Solver - 3D plasticity based on Chen-Chen
	//
	//   $Id: fem_chen.c,v 1.5 2005/01/16 22:59:32 jirka Exp $
	//
	// stress invariants etc.:
	return femVecGet(stress, 1) + femVecGet(stress, 2) + femVecGet(stress, 3)
}

// stress3D_J2 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:54
func stress3D_J2(stress []tVector) float64 {
	var val float64
	var s_x float64
	var s_y float64
	var s_z float64
	var t_xy float64
	var t_yz float64
	var t_zx float64
	s_x = femVecGet(stress, 1)
	s_y = femVecGet(stress, 2)
	s_z = femVecGet(stress, 3)
	t_zx = femVecGet(stress, 4)
	t_yz = femVecGet(stress, 5)
	t_xy = femVecGet(stress, 6)
	val = (math.Pow(s_x-s_y, 2)+math.Pow(s_y-s_z, 2)+math.Pow(s_z-s_x, 2))/6 + t_xy*t_xy + t_yz*t_yz + t_zx*t_zx
	return val
}

// stress3D_J2dev - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:76
func stress3D_J2dev(stress []tVector) float64 {
	var val float64
	var s_x float64
	var s_y float64
	var s_z float64
	var t_xy float64
	var t_yz float64
	var t_zx float64
	var s_h float64
	s_h = (femVecGet(stress, 1) + femVecGet(stress, 2) + femVecGet(stress, 3)) / 3
	s_x = femVecGet(stress, 1) - s_h
	s_y = femVecGet(stress, 2) - s_h
	s_z = femVecGet(stress, 3) - s_h
	t_zx = femVecGet(stress, 4)
	t_yz = femVecGet(stress, 5)
	t_xy = femVecGet(stress, 6)
	val = (math.Pow(s_x-s_y, 2)+math.Pow(s_y-s_z, 2)+math.Pow(s_z-s_x, 2))/6 + t_xy*t_xy + t_yz*t_yz + t_zx*t_zx
	return val
}

// chen_Ac - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:105
func chen_Ac(f_c0 float64, f_bc0 float64, f_t0 float64) (c4goDefaultReturn float64) {
	// Chen's constants:
	var f_c float64
	var f_bc float64
	var f_t float64
	f_t = math.Abs(f_t0)
	f_c = -1 * math.Abs(f_c0)
	f_bc = -1 * math.Abs(f_bc0)
	if 2*f_bc-f_c == 0 {
		return 0
	} else {
		return (f_bc*f_bc - f_c*f_c) / (2*f_bc - f_c)
	}
	return
}

// chen_At - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:123
func chen_At(f_c0 float64, f_bc0 float64, f_t0 float64) float64 {
	var f_c float64
	var f_t float64
	f_t = math.Abs(f_t0)
	f_c = -1 * math.Abs(f_c0)
	return 0.5 * (f_c - f_t)
}

// chen_tau_c - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:133
func chen_tau_c(f_c0 float64, f_bc0 float64, f_t0 float64) (c4goDefaultReturn float64) {
	var f_c float64
	var f_bc float64
	var f_t float64
	f_t = math.Abs(f_t0)
	f_c = -1 * math.Abs(f_c0)
	f_bc = -1 * math.Abs(f_bc0)
	if 2*f_bc-f_c == 0 {
		return 0
	} else {
		return math.Abs(f_bc*f_c*(2*f_c-f_bc)) / (3 * (2*f_bc - f_c))
	}
	return
}

// chen_tau_t - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:151
func chen_tau_t(f_c0 float64, f_bc0 float64, f_t0 float64) float64 {
	var f_c float64
	var f_t float64
	f_t = math.Abs(f_t0)
	f_c = -1 * math.Abs(f_c0)
	return math.Abs(f_c * f_t / 6)
}

// chen_alpha - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:163
func chen_alpha(A_y float64, tau_y float64, A_u float64, tau_u float64) (c4goDefaultReturn float64) {
	if tau_u-tau_y == 0 {
		// constants alpha_[ct], beta_[ct]
		return 0
	} else {
		return (A_u - A_y) / (tau_u - tau_y)
	}
	return
}

// chen_beta - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:175
func chen_beta(A_y float64, tau_y float64, A_u float64, tau_u float64) (c4goDefaultReturn float64) {
	if tau_u-tau_y == 0 {
		return 0
	} else {
		return (A_y*tau_u - A_u*tau_y) / (tau_u - tau_y)
	}
	return
}

// chen_deriv_c - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:190
func chen_deriv_c(deriv []tVector, stress []tVector, alfac float64, tauc0 float64, betac float64) int32 {
	// derivatives of the Chen's condition:
	// TODO FIX THIS: A_c
	var s_x float64
	var s_y float64
	var s_z float64
	var t_xy float64
	var t_yz float64
	var t_zx float64
	var tauc float64
	var a float64
	tauc = math.Sqrt(math.Abs(tauc0))
	//a = A_c / 3.0 ;
	a = (alfac*tauc + betac) / 3
	s_x = femVecGet(stress, 1)
	s_y = femVecGet(stress, 2)
	s_z = femVecGet(stress, 3)
	t_yz = femVecGet(stress, 4)
	t_zx = femVecGet(stress, 5)
	t_xy = femVecGet(stress, 6)
	femVecPutAdd(deriv, 1, (2*s_x-s_y-s_z)/3+a, 0)
	femVecPutAdd(deriv, 2, (2*s_y-s_x-s_z)/3+a, 0)
	femVecPutAdd(deriv, 3, (2*s_z-s_x-s_y)/3+a, 0)
	femVecPutAdd(deriv, 4, 2*t_yz, 0)
	femVecPutAdd(deriv, 5, 2*t_zx, 0)
	femVecPutAdd(deriv, 6, 2*t_xy, 0)
	return 0
}

// chen_deriv_t - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:219
func chen_deriv_t(deriv []tVector, stress []tVector, alfat float64, taut0 float64, betat float64, I1 float64) int32 {
	// TODO FIX THIS: A_t
	var s_x float64
	var s_y float64
	var s_z float64
	var t_xy float64
	var t_yz float64
	var t_zx float64
	var a float64
	var taut float64
	taut = math.Sqrt(math.Abs(taut0))
	//a = A_t / 3.0 ;
	a = (alfat*taut + betat - I1) / 3
	s_x = femVecGet(stress, 1)
	s_y = femVecGet(stress, 2)
	s_z = femVecGet(stress, 3)
	t_yz = femVecGet(stress, 4)
	t_zx = femVecGet(stress, 5)
	t_xy = femVecGet(stress, 6)
	femVecPutAdd(deriv, 1, a-0.5*(s_y+s_z), 0)
	femVecPutAdd(deriv, 2, a-0.5*(s_x+s_z), 0)
	femVecPutAdd(deriv, 3, a-0.5*(s_x+s_y), 0)
	femVecPutAdd(deriv, 4, 2*t_yz, 0)
	femVecPutAdd(deriv, 5, 2*t_zx, 0)
	femVecPutAdd(deriv, 6, 2*t_xy, 0)
	return 0
}

// chen_limit_test2 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:258
func chen_limit_test2(I1 float64, J2 float64, f_c float64, f_bc float64, f_t float64, cczone []int32) int32 {
	// Tests if material is plastic/destroyed or not
	// * @param I1 first stress invariant
	// * @param J2 second  invariant od stress deviator
	// * @param f_c uniaxial compressive stress
	// * @param f_bc biaxial compressive stress
	// * @param f_t uniaxial tension stress
	// * @param cczone AF_YES if we are in C-C zone, AF_NO for other stress zones
	// * @return AF_YES (over limit) or AF_NO (under limit)
	// *
	var sqJ2I1 float64
	var A float64
	var tau float64
	sqJ2I1 = math.Sqrt(J2) + I1/3
	if I1 < 0 && sqJ2I1 < 0 {
		// compression - compression zone
		cczone[0] = 1
		A = math.Abs(chen_Ac(f_c, f_bc, f_t))
		// means tau^2 !
		tau = math.Abs(chen_tau_c(f_c, f_bc, f_t))
		if J2+A/3*I1-tau < 0 {
			return 0
		} else {
			return 1
		}
	} else {
		// all other zones
		cczone[0] = 0
		A = math.Abs(chen_At(f_c, f_bc, f_t))
		// means tau^2 !
		tau = math.Abs(chen_tau_t(f_c, f_bc, f_t))
		if J2-I1*I1/6+A/3*I1-tau < 0 {
			return 0
		} else {
			return 1
		}
	}
	return 0
}

// chen_Dep - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:329
func chen_Dep(deriv []tVector, H float64, De []tMatrix, Dep []tMatrix) int32 {
	// Computes elastoplastic material stiffness  matrix
	// * @param deriv derivatives of the plasticity condition
	// * @param H hardening parameter
	// * @param De elastic matrix
	// * @param Dep elastoplastic matrix (result)
	// * @return status
	// *
	var rv int32
	var size int32 = 3
	var Dtmp tMatrix
	var Df tVector
	var fD tVector
	var fDf float64
	var ff float64
	var mult float64
	size = deriv[0].rows
	if size != 3 && size != 6 {
		noarch.Fprintf(msgout, []byte("[E] %s (%li)!\n\x00"), []byte("Chen Dep: Invalid size of derivatives vector\x00"), size)
		return -9
	}
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Dtmp))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&Df))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&fD))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dtmp))[:], 0, size, size, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&Df))[:], 0, size, size)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&fD))[:], 0, size, size)
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatVecMult(De, deriv, (*[1000000]tVector)(unsafe.Pointer(&Df))[:])
	femVecMatMult(deriv, De, (*[1000000]tVector)(unsafe.Pointer(&fD))[:])
	femVecVecMulttoMat((*[1000000]tVector)(unsafe.Pointer(&Df))[:], (*[1000000]tVector)(unsafe.Pointer(&fD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dtmp))[:])
	fDf = femVecVecMult(deriv, (*[1000000]tVector)(unsafe.Pointer(&Df))[:])
	ff = math.Sqrt(math.Abs(femVecVecMult(deriv, deriv)))
	// is fabs() OK here?
	mult = fDf + math.Abs(H*ff)
	if mult == 0 {
		mult = 1
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero size multiplier in che_Dep\x00"))
	}
	femMatLinComb(1, De, -1/mult, (*[1000000]tMatrix)(unsafe.Pointer(&Dtmp))[:], Dep)
	femMatPrn(De, []byte("D_E\x00"))
	femMatPrn(Dep, []byte("D_EP\x00"))
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dtmp))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&Df))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&fD))[:])
	return rv
}

// fem_chen_D_3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_chen.c:401
func fem_chen_D_3D(ePos int32, e_rep int32, eT int32, mT int32, sigma_unused []tVector, epsilon []tVector, Mode int32, Dep []tMatrix) int32 {
	var rv int32
	var cczone int32 = 1
	var state int32
	var Ex float64
	var nu float64
	var f_yc float64
	var f_ybc float64
	var f_yt float64
	var f_uc float64
	var f_ubc float64
	var f_ut float64
	var A_y float64
	var A_u float64
	var alfa float64
	var tau_y float64
	var tau_u float64
	var beta float64
	var I1 float64
	var J2 float64
	var H float64
	var deriv tVector
	var old_sigma tVector
	var sigma tVector
	var sigma_1 tVector
	var De tMatrix
	var k []float64 = make([]float64, 4)
	var n []float64 = make([]float64, 4)
	var i int32
	var jj int32
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 1, femGetRepVal(ePos, 7, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 2, femGetRepVal(ePos, 8, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 3, femGetRepVal(ePos, 9, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 4, femGetRepVal(ePos, 11, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 5, femGetRepVal(ePos, 12, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 6, femGetRepVal(ePos, 10, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	f_yc = femGetMPValPos(ePos, 12, 0)
	f_ybc = femGetMPValPos(ePos, 13, 0)
	f_yt = femGetMPValPos(ePos, 14, 0)
	f_uc = femGetMPValPos(ePos, 15, 0)
	f_ubc = femGetMPValPos(ePos, 16, 0)
	f_ut = femGetMPValPos(ePos, 17, 0)
	// old
	state = int32(femGetRepVal(ePos, 37, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	H = femGetRepVal(ePos, 38, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	if float64(state) == 0 {
		femD_3D_iso(ePos, Ex, nu, Dep)
	} else {
		femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		if state < 0 {
			// compression
			A_y = chen_Ac(f_yc, f_ybc, f_yt)
			A_u = chen_Ac(f_uc, f_ubc, f_ut)
			tau_y = chen_tau_c(f_yc, f_ybc, f_yt)
			tau_u = chen_tau_c(f_uc, f_ubc, f_ut)
			alfa = chen_alpha(A_y, tau_y, A_u, tau_u)
			beta = chen_beta(A_y, tau_y, A_u, tau_u)
			chen_deriv_c((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], alfa, tau_y, beta)
		} else {
			// tension
			A_y = chen_At(f_yc, f_ybc, f_yt)
			A_u = chen_At(f_uc, f_ubc, f_ut)
			tau_y = chen_tau_t(f_yc, f_ybc, f_yt)
			tau_u = chen_tau_t(f_uc, f_ubc, f_ut)
			alfa = chen_alpha(A_y, tau_y, A_u, tau_u)
			beta = chen_beta(A_y, tau_y, A_u, tau_u)
			I1 = stress3D_I1((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
			chen_deriv_t((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], alfa, tau_y, beta, I1)
		}
		chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
	}
	if Mode == 1 {
		// new
		femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femMatVecMult(Dep, epsilon, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		for i = 1; i <= 6; i++ {
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i), 1)
		}
		I1 = stress3D_I1((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
		J2 = stress3D_J2((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
		femPrinc3D((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
		if chen_limit_test2(I1, J2, f_yc, f_ybc, f_yt, c4goUnsafeConvert_int32(&cczone)) == 1 {
			// plastic
			femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
			if cczone == 1 {
				// compression - compression zone
				A_y = chen_Ac(f_yc, f_ybc, f_yt)
				A_u = chen_Ac(f_uc, f_ubc, f_ut)
				tau_y = chen_tau_c(f_yc, f_ybc, f_yt)
				tau_u = chen_tau_c(f_uc, f_ubc, f_ut)
				alfa = chen_alpha(A_y, tau_y, A_u, tau_u)
				beta = chen_beta(A_y, tau_y, A_u, tau_u)
				chen_deriv_c((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], alfa, tau_y, beta)
				state = -1
			} else {
				// other zones
				A_y = chen_At(f_yc, f_ybc, f_yt)
				A_u = chen_At(f_uc, f_ubc, f_ut)
				tau_y = chen_tau_t(f_yc, f_ybc, f_yt)
				tau_u = chen_tau_t(f_uc, f_ubc, f_ut)
				alfa = chen_alpha(A_y, tau_y, A_u, tau_u)
				beta = chen_beta(A_y, tau_y, A_u, tau_u)
				chen_deriv_t((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], alfa, tau_y, beta, I1)
				state = +1
			}
			{
				// obtain k, n HERE
				for jj = 1; jj <= 3; jj++ {
					k[jj] = femGetMPValPos(ePos, 30, jj)
					n[jj] = femGetMPValPos(ePos, 31, jj)
				}
			}
			H = 1e+06 * 1e-17
			chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
		} else {
			// elastic
			femD_3D_iso(ePos, Ex, nu, Dep)
			state = 0
		}
		femAddPutRepVal(ePos, 37, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(state))
		femAddPutRepVal(ePos, 38, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, H)
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	return rv
}

// femDataNull - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:35
func femDataNull() int32 {
	//
	//   File name: fem_dama.c
	//   Date:      2003/04/07 10:03
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - data manipulations
	//
	//  $Id: fem_dama.c,v 1.8 2004/11/11 21:39:23 jirka Exp $
	//
	// Sets all data fields to NULL or 0 (solution parameters are untouched)
	// * @return AF_OK in all cases ;-)
	//
	// number of nodes
	nLen = 0
	// number of elemnts
	eLen = 0
	// lenght of element nodes field
	eLenL = 0
	// number or real sets
	rsLen = 0
	// number of real value field
	rsLenL = 0
	// number of materials
	mpLen = 0
	// number of materials values
	mpLenL = 0
	// number of nodal loads/b.c.s
	nlLen = 0
	// number of element loads
	elLen = 0
	// number of element loads values
	elLenL = 0
	// NODES
	// node number
	nID = nil
	// x coordinate
	n_x = nil
	// y coordinate
	n_y = nil
	// z coordinate
	n_z = nil
	// ELEMENTS
	// element number
	eID = nil
	// element type number
	eType = nil
	// real set data position
	eRS = nil
	// material data position
	eMP = nil
	// starting point in eNodesL
	eFrom = nil
	// list of nodes
	eNodesL = nil
	// REAL SETS
	// real set number
	rsID = nil
	// element type number
	rsType = nil
	// starting point in rsValL
	rsFrom = nil
	// real set values
	rsValL = nil
	// MATERIAL PROPERTIES
	// material number
	mpID = nil
	// material type number
	mpType = nil
	// starting point in mpValL
	mpFrom = nil
	// real set values
	mpValL = nil
	// NODAL LOADS AND BOUNDARY CONDITIONS
	// node to be used (position)
	nlNode = nil
	// type of load
	nlType = nil
	// direction of load
	nlDir = nil
	// value of load
	nlVal = nil
	// ELEMENT LOADS
	// node to be used (position)
	elElem = nil
	// type of load
	elType = nil
	// starting point in elValL
	elFrom = nil
	// values of load
	elValL = nil
	// GRAVITATION
	// direction (none=0, x=1, y=3, z=3)
	grDir = 0
	// acceleration value (9.81, for example)
	grVal = 0
	return 0
}

// femDataFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:110
func femDataFree() int32 {
	// Frees all data fields (solution parameters are untouched)
	// * @return AF_OK in all cases ;-)
	//
	// number of nodes
	nLen = 0
	// number of elemnts
	eLen = 0
	// lenght of element nodes field
	eLenL = 0
	// number or real sets
	rsLen = 0
	// number of real value field
	rsLenL = 0
	// number of materials
	mpLen = 0
	// number of materials values
	mpLenL = 0
	// number of nodal loads/b.c.s
	nlLen = 0
	// number of element loads
	elLen = 0
	// number of element loads values
	elLenL = 0
	// NODES
	// node number
	femIntFree(nID)
	// x coordinate
	femDblFree(n_x)
	// y coordinate
	femDblFree(n_y)
	// z coordinate
	femDblFree(n_z)
	// ELEMENTS
	// element number
	femIntFree(eID)
	// element type number
	femIntFree(eType)
	// real set data position
	femIntFree(eRS)
	// material data position
	femIntFree(eMP)
	// starting point in eNodesL
	femIntFree(eFrom)
	// list of nodes
	femIntFree(eNodesL)
	// REAL SETS
	// real set number
	femIntFree(rsID)
	// element type number
	femIntFree(rsType)
	// starting point in rsValL
	femIntFree(rsFrom)
	// real set values
	femDblFree(rsValL)
	// MATERIAL PROPERTIES
	// material number
	femIntFree(mpID)
	// material type number
	femIntFree(mpType)
	// starting point in mpValL
	femIntFree(mpFrom)
	// real set values
	femDblFree(mpValL)
	// NODAL LOADS AND BOUNDARY CONDITIONS
	// node to be used (position)
	femIntFree(nlNode)
	// type of load
	femIntFree(nlType)
	// direction of load
	femIntFree(nlDir)
	// value of load
	femDblFree(nlVal)
	// ELEMENT LOADS
	// node to be used (position)
	femIntFree(elElem)
	// type of load
	femIntFree(elType)
	// starting point in elValL
	femIntFree(elFrom)
	// values of load
	femDblFree(elValL)
	// GRAVITATION
	// direction (none=0, x=1, y=3, z=3)
	grDir = 0
	// acceleration value (9.81, for example)
	grVal = 0
	return 0
}

// femResNull - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:184
func femResNull() int32 {
	// NULLs result data fields (solution parameters are untouched)
	// * @return AF_OK in all cases ;-)
	//
	var rv int32
	// number of nodes with reactions
	resRLen = 0
	// number of element results
	resELen = 0
	// RESULTS  - reaction
	// node with reaction(s)
	resRnode = nil
	resRdof = nil
	resRval = nil
	resRval0 = nil
	// RESULTS ON ELEMENTS
	// number of results on element
	resEFrom = nil
	// results on element (values)
	resEVal = nil
	return rv
}

// femResFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:206
func femResFree() int32 {
	// Frees result data fields (solution parameters are untouched)
	// * @return AF_OK in all cases ;-)
	//
	var rv int32
	// number of nodes with reactions
	resRLen = 0
	// number of element results
	resELen = 0
	// RESULTS  - reaction
	// node with reaction(s)
	femIntFree(resRnode)
	// node with reaction(s)
	femIntFree(resRdof)
	femDblFree(resRval)
	femDblFree(resRval0)
	// RESULTS ON ELEMENTS
	// number of results on element
	femIntFree(resEFrom)
	// results on element (values)
	femDblFree(resEVal)
	return rv
}

// femBackResNull - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:233
func femBackResNull() int32 {
	// *************************************************************
	// * *** Backup files for results ********************************
	// * *************************************************************
	// NULLs result data fields (solution parameters are untouched)
	// * @return AF_OK in all cases ;-)
	//
	var rv int32
	// number of nodes with reactions
	resBackRLen = 0
	// number of element results
	resBackELen = 0
	// RESULTS  - reaction
	// node with reaction(s)
	resBackRnode = nil
	resBackRdof = nil
	resBackRval = nil
	resBackRval0 = nil
	// RESULTS ON ELEMENTS
	// number of results on element
	resBackEFrom = nil
	// results on element (values)
	resBackEVal = nil
	return rv
}

// femBackResFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:255
func femBackResFree() int32 {
	// Frees result data fields (solution parameters are untouched)
	// * @return AF_OK in all cases ;-)
	//
	var rv int32
	// number of nodes with reactions
	resBackRLen = 0
	// number of element results
	resBackELen = 0
	// RESULTS  - reaction
	// node with reaction(s)
	femIntFree(resBackRnode)
	// node with reaction(s)
	femIntFree(resBackRdof)
	femDblFree(resBackRval)
	femDblFree(resBackRval0)
	// RESULTS ON ELEMENTS
	// number of results on element
	femIntFree(resBackEFrom)
	// results on element (values)
	femDblFree(resBackEVal)
	return rv
}

// femBackResGet - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:277
func femBackResGet() int32 {
	// Gets backup result date from the original ones
	// * @return AF_OK in all cases ;-)
	//
	var rv int32
	var i int32
	if resBackRLen > 0 || resBackELen > 0 {
		// previously used
		femBackResFree()
	} else {
		// used first time or after free()
		femBackResNull()
	}
	// number of nodes with reactions
	resBackRLen = resRLen
	// number of element results
	resBackELen = resELen
	if len((func() []int32 {
		resBackRnode = femIntAlloc(resBackRLen)
		return resBackRnode
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		resBackRdof = femIntAlloc(resBackRLen)
		return resBackRdof
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		resBackRval0 = femDblAlloc(resBackRLen)
		return resBackRval0
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		resBackRval = femDblAlloc(resBackRLen)
		return resBackRval
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		resBackEFrom = femIntAlloc(eLen)
		return resBackEFrom
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		resBackEVal = femDblAlloc(resBackELen)
		return resBackEVal
	}())) == 0 {
		rv = -4
		goto memFree
	}
	for i = 0; i < resBackRLen; i++ {
		resBackRnode[i] = resRnode[i]
		resBackRdof[i] = resRdof[i]
		resBackRval0[i] = resRval0[i]
		resBackRval[i] = resRval[i]
	}
	for i = 0; i < eLen; i++ {
		resBackEFrom[i] = resEFrom[i]
	}
	for i = 0; i < resBackELen; i++ {
		resBackEVal[i] = resEVal[i]
	}
	return rv
memFree:
	;
	femBackResFree()
	return rv
}

// femBackResPut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:330
func femBackResPut() int32 {
	// Put backup result date from the original
	// * @return AF_OK in all cases ;-)
	//
	var rv int32
	var i int32
	if resBackRLen <= 0 && resBackELen <= 0 {
		noarch.Fprintf(msgout, []byte("[E] Backup results ar not available!\n\x00"))
		return -1
	}
	for i = 0; i < resBackRLen; i++ {
		resRnode[i] = resBackRnode[i]
		resRdof[i] = resBackRdof[i]
		resRval0[i] = resBackRval0[i]
		resRval[i] = resBackRval[i]
	}
	for i = 0; i < eLen; i++ {
		resEFrom[i] = resBackEFrom[i]
	}
	for i = 0; i < resBackELen; i++ {
		resEVal[i] = resBackEVal[i]
	}
	return rv
}

// femGetRSValPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:376
func femGetRSValPos(ePos int32, valType int32, repNum int32) float64 {
	// *********************************************************
	// * Replacement for macros (getting of values from real sets and materials)
	// * *********************************************************
	//
	// Returnes value of real constant
	// @param  ePos element position
	// @param  valType type of value (see predefined constants)
	// @param  repNum repeat number (0 for non-repeating)
	// @return requested value (0 if not found)
	//
	var eT int32
	var valPos int32
	eT = femGetIntPos(ePos, eType, eLen)
	if eT < 0 {
		return float64(0)
	}
	valPos = femGetIntPos(ePos, eRS, eLen)
	if valPos < 0 {
		return float64(0)
	}
	return femGetRepVal(valPos, valType, repNum, rsValL, rsLenL, rsFrom, rsLen, Elem[eT].real_, Elem[eT].rs, Elem[eT].real_rp, Elem[eT].rs_rp)
}

// femGetMPValPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:410
func femGetMPValPos(ePos int32, valType int32, repNum int32) float64 {
	// Returnes value of material property
	// @param  ePos element position
	// @param  valType type of value (see predefined constants)
	// @param  repNum repeat number (0 for non-repeating)
	// @return requested value (0 if not found)
	//
	var mT int32
	var valPos int32
	// note: this is VERY DIFFERENT from RS handling!!
	mT = femGetIntPos(ePos, eMP, eLen)
	if mT < 0 {
		return float64(0)
	}
	valPos = femGetIntPos(mT, mpType, mpLen)
	if valPos < 0 {
		return float64(0)
	}
	return femGetRepVal(mT, valType, repNum, mpValL, mpLenL, mpFrom, mpLen, Mat[valPos].val, Mat[valPos].num, Mat[valPos].val_rp, Mat[valPos].num_rp)
}

// femGetSystemMatType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:442
func femGetSystemMatType(ePos int32) int32 {
	// Returnes SYSTEM id of the material type
	// * @param  element position
	// * @return material id
	// *
	var pos int32
	var type_ int32
	pos = femGetIntPos(ePos, eMP, eLen)
	if pos < 0 || pos > mpLen {
		return 0
	}
	type_ = femGetIntPos(pos, mpType, mpLen)
	return Mat[type_].type_
}

// femGetRSRepNumPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:458
func femGetRSRepNumPos(ePos int32) int32 {
	// Returnes number of repeating values of real constant
	// @param  ePos element position
	// @return number of repeating data sets
	//
	var eT int32
	var valPos int32
	eT = femGetIntPos(ePos, eType, eLen)
	if eT < 0 {
		return 0
	}
	valPos = femGetIntPos(ePos, eRS, eLen)
	if valPos < 0 {
		return 0
	}
	return femGetRepNum(valPos, rsValL, rsLenL, rsFrom, rsLen, Elem[eT].real_, Elem[eT].rs, Elem[eT].real_rp, Elem[eT].rs_rp)
}

// femGetMPRepNumPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dama.c:488
func femGetMPRepNumPos(ePos int32) int32 {
	// Returnes number of repeating sets of material
	// @param  ePos element position
	// @return number of sets
	//
	var mT int32
	var valPos int32
	// note: this is VERY DIFFERENT from RS handling!!
	mT = femGetIntPos(ePos, eMP, eLen)
	if mT < 0 {
		return 0
	}
	valPos = femGetIntPos(mT, mpType, mpLen)
	if valPos < 0 {
		return 0
	}
	return femGetRepNum(mT, mpValL, mpLenL, mpFrom, mpLen, Mat[valPos].val, Mat[valPos].num, Mat[valPos].val_rp, Mat[valPos].num_rp)
}

// solID - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:31
//
//   File name: fem_data.c
//   Date:      2003/04/07 09:13
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - data fields
//
//  $Id: fem_data.c,v 1.6 2004/11/11 21:39:23 jirka Exp $
//
// SOLUTION DATA
// "time node" identifier
var solID int32

// solDepOn - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:32
// dependency on prefious "time node"
var solDepOn int32

// solLinSol - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:33
// linear eq. sys. solve
var solLinSol int32

// solNoLinS - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:34
// non-linear solution method
var solNoLinS int32

// solLinStepMax - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:35
// max. number of steps in linear solution
var solLinStepMax int32 = 1

// solNoLinSteps - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:36
// number of steps in non-linear solution
var solNoLinSteps int32 = 1

// solNoLinIter - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:37
// default max number of iterations in one step
var solNoLinIter int32 = 333

// solNoLinStepMax - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:38
// max. number of steps in non-linear solution
var solNoLinStepMax int32 = 1

// solNoBreakStep - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:39
// "unbreakable" non-linear solution
var solNoBreakStep int32

// solLinPrec - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:40
// linear precission
var solLinPrec float64 = 1e-06

// solNoLinPre - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:41
// nonlinear precission
var solNoLinPre float64 = 1e-06

// solNoLinBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:42
// nonlinear max. residual size
var solNoLinBig float64 = 10

// solSimNum - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:43
// simulation identifier or load multiplier
var solSimNum float64

// solNoLinS_cmd - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:45
//solNoLinS from command line
var solNoLinS_cmd int32 = -1

// solNoLinSteps_cmd - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:46
//solNoLinSteps from command line
var solNoLinSteps_cmd int32 = -1

// solUseBiCGs - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:48
// in non-symetric equation solver is forced to use
var solUseBiCGs int32

// solUseCGSSOR - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:49
// in non-symetric equation solver is forced to use
var solUseCGSSOR int32

// nLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:53
// LENGHTS OF FIELDS:
// number of nodes
var nLen int32

// eLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:54
// number of elements
var eLen int32

// eLenL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:55
// lenght of element nodes field
var eLenL int32

// rsLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:56
// number or real sets
var rsLen int32

// rsLenL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:57
// number of real value field
var rsLenL int32

// mpLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:58
// number of materials
var mpLen int32

// mpLenL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:59
// number of materials values
var mpLenL int32

// nlLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:60
// number of nodal loads/b.c.s
var nlLen int32

// elLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:61
// number of element loads
var elLen int32

// elLenL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:62
// number of element loads values
var elLenL int32

// resRLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:64
// number of nodes with reactions
var resRLen int32

// resELen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:65
// number of element results
var resELen int32

// resBackRLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:67
// number of nodes with reactions (backup)
var resBackRLen int32

// resBackELen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:68
// number of element results (backup)
var resBackELen int32

// nID - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:72
// NODES
// node number
var nID []int32

// n_x - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:73
// x coordinate
var n_x []float64

// n_y - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:74
// y coordinate
var n_y []float64

// n_z - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:75
// z coordinate
var n_z []float64

// eID - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:79
// ELEMENTS
// element number
var eID []int32

// eType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:80
// element type number
var eType []int32

// eRS - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:81
// real set data position
var eRS []int32

// eMP - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:82
// material data position
var eMP []int32

// eFrom - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:83
// starting point in eNodesL
var eFrom []int32

// eNodesL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:85
// list of nodes
var eNodesL []int32

// rsID - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:89
// REAL SETS
// real set number
var rsID []int32

// rsType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:90
// element type number
var rsType []int32

// rsFrom - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:91
// starting point in rsValL
var rsFrom []int32

// rsValL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:93
// real set values
var rsValL []float64

// mpID - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:97
// MATERIAL PROPERTIES
// material number
var mpID []int32

// mpType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:98
// material type number
var mpType []int32

// mpFrom - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:99
// starting point in mpValL
var mpFrom []int32

// mpValL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:101
// real set values
var mpValL []float64

// nlNode - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:105
// NODAL LOADS AND BOUNDARY CONDITIONS
// node to be used (position)
var nlNode []int32

// nlType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:106
// type of load
var nlType []int32

// nlDir - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:107
// direction of load
var nlDir []int32

// nlVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:108
// value of load
var nlVal []float64

// nlTrPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:109
// position in transient data
var nlTrPos []int32

// elElem - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:113
// ELEMENT LOADS
// node to be used (position)
var elElem []int32

// elType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:114
// type and direction of load
var elType []int32

// elFrom - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:115
// starting point in elValL
var elFrom []int32

// elValL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:117
// values of load
var elValL []float64

// elTrPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:118
// position in transient data
var elTrPos []int32

// grDir - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:122
// GRAVITATION
// direction (none=0, x=1, y=3, z=3)
var grDir int32

// grVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:123
// acceleration value (9.81, for example)
var grVal float64

// dynNum - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:127
// DYNAMICS
// number of time steps
var dynNum int32

// dynStp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:128
// time step size
var dynStp float64

// dynAlpha - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:129
// Rayleigh damping coefficient alpha
var dynAlpha float64

// dynBeta - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:130
// Rayleigh damping coefficient beta
var dynBeta float64

// dynAccX - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:131
// acceleration loads for each time step
var dynAccX int32

// dynAccY - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:132
// acceleration loads for each time step
var dynAccY int32

// dynAccZ - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:133
// acceleration loads for each time step
var dynAccZ int32

// transNum - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:136
// REPEATING (TRANSIENT) LOADS
// number of loads
var transNum int32

// transType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:137
// types of loads
var transType []int32

// transPos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:138
// position of loads
var transPos []int32

// transMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:139
// load multipliers
var transMult [][]float64

// transTS - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:140
// time step size position
var transTS int32 = -1

// resRnode - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:143
// RESULTS  - reaction
// node with reaction(s)
var resRnode []int32

// resRdof - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:144
// dof type
var resRdof []int32

// resRval - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:145
//  force
var resRval []float64

// resRval0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:146
//  force from previous iteration (4,5,6,7 type only)
var resRval0 []float64

// resEFrom - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:149
// RESULTS ON ELEMENTS
// number of results on element
var resEFrom []int32

// resEVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:150
// results on element (values)
var resEVal []float64

// resBackRnode - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:154
// BACKUP results
// node with reaction(s)
var resBackRnode []int32

// resBackRdof - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:155
// dof type
var resBackRdof []int32

// resBackRval - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:156
//  force
var resBackRval []float64

// resBackRval0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:157
//  force from previous iteration (4,5,6,7 type only)
var resBackRval0 []float64

// resBackEFrom - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:159
// number of results on element
var resBackEFrom []int32

// resBackEVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_data.c:160
// results on element (values)
var resBackEVal []float64

// dp_deriv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dp.c:37
func dp_deriv(deriv []tVector, stress []tVector, c float64, phi float64) int32 {
	//
	//   File name: fem_dp.c
	//   Date:      2004/01/24 14:53
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM Solver - 3D Drucker-Prager plasticity condition
	//
	//   $Id: fem_dp.c,v 1.3 2004/11/11 21:39:23 jirka Exp $
	//
	// from "fem_chen.c":
	// elasticity condition derivatives:
	var s_x float64
	var s_y float64
	var s_z float64
	var t_xy float64
	var t_yz float64
	var t_zx float64
	var alpha float64
	var J2 float64
	var multJ2 float64
	J2 = stress3D_J2(stress)
	multJ2 = 1 / (2 * math.Sqrt(J2))
	alpha = 2 * math.Sin(phi) / (math.Sqrt(3) * (3 + math.Sin(phi)))
	s_x = femVecGet(stress, 1)
	s_y = femVecGet(stress, 2)
	s_z = femVecGet(stress, 3)
	t_yz = femVecGet(stress, 4)
	t_zx = femVecGet(stress, 5)
	t_xy = femVecGet(stress, 6)
	femVecPutAdd(deriv, 1, alpha+multJ2*math.Abs(2/3*s_x-s_y-s_z), 0)
	femVecPutAdd(deriv, 2, alpha+multJ2*math.Abs(2/3*s_y-s_x-s_z), 0)
	femVecPutAdd(deriv, 3, alpha+multJ2*math.Abs(2/3*s_z-s_y-s_x), 0)
	femVecPutAdd(deriv, 4, alpha+multJ2*math.Abs(2*t_yz), 0)
	femVecPutAdd(deriv, 5, alpha+multJ2*math.Abs(2*t_zx), 0)
	femVecPutAdd(deriv, 6, alpha+multJ2*math.Abs(2*t_xy), 0)
	return 0
}

// fem_dp_D_3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_dp.c:67
func fem_dp_D_3D(ePos int32, e_rep int32, eT int32, mT int32, sigma []tVector, epsilon []tVector, Mode int32, Dep []tMatrix) int32 {
	// Drucker-Prager elastoplastic matrix
	// new code
	var rv int32
	var state int32
	var Ex float64
	var nu float64
	var c float64
	var phi float64
	var E1 float64
	var I1 float64
	var J2 float64
	var alpha float64
	var K float64
	var f float64
	var H float64
	var deriv tVector
	var old_sigma tVector
	var De tMatrix
	var i int32
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 1, femGetRepVal(ePos, 7, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 2, femGetRepVal(ePos, 8, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 3, femGetRepVal(ePos, 9, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 4, femGetRepVal(ePos, 11, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 5, femGetRepVal(ePos, 12, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 6, femGetRepVal(ePos, 10, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	c = femGetMPValPos(ePos, 18, 0)
	phi = femGetMPValPos(ePos, 19, 0)
	E1 = femGetMPValPos(ePos, 20, 0)
	if E1 == Ex {
		// linear solution
		return femD_3D_iso(ePos, Ex, nu, Dep)
	} else {
		// hardening parameter for bilinear behaviour
		H = E1 / (1 - E1/Ex)
	}
	state = int32(femGetRepVal(ePos, 37, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	if state == 0 {
		femD_3D_iso(ePos, Ex, nu, Dep)
	} else {
		femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		dp_deriv((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], c, phi)
		chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
	}
	if Mode == 1 {
		femMatVecMult(Dep, epsilon, sigma)
		for i = 1; i <= 6; i++ {
			femVecPutAdd(sigma, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], i), 1)
		}
		I1 = stress3D_I1((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
		J2 = stress3D_J2((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
		alpha = 2 * math.Sin(phi) / (math.Sqrt(3) * (3 + math.Sin(phi)))
		K = 6 * c * math.Cos(phi) / (math.Sqrt(3) * (3 + math.Sin(phi)))
		f = alpha*I1 + math.Sqrt(math.Abs(J2)) - K
		if f < 0 {
			// elastic
			femD_3D_iso(ePos, Ex, nu, Dep)
			state = 0
		} else {
			// plastic
			femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
			dp_deriv((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], sigma, c, phi)
			chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
			state = 1
		}
		femMatVecMult(Dep, epsilon, sigma)
		for i = 1; i <= 6; i++ {
			femVecPutAdd(sigma, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], i), 1)
		}
		femAddPutRepVal(ePos, 37, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(state))
		femAddPutRepVal(ePos, 38, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, H)
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	return rv
}

// e000_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:28
func e000_stiff(ePos int32, Mode int32, Ke []tMatrix, Fe []tVector, Fre []tVector) int32 {
	//
	//   File name: fem_e000.c
	//   Date:      2003/04/12 15:20
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Element 000 (empty)
	//
	return 0
}

// e000_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:29
func e000_mass(ePos int32, Me []tMatrix) int32 {
	return 0
}

// e000_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:30
func e000_rvals(ePos int32) int32 {
	return 0
}

// e000_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:31
func e000_eload(ePos int32, mode int32, Fe []tVector) int32 {
	return 0
}

// e000_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:32
func e000_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	return 0
}

// e000_res_node - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:33
func e000_res_node(ePos int32, nPos int32, type_ int32, val []float64) int32 {
	return 0
}

// e000_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:34
func e000_volume(ePos int32, val []float64) int32 {
	return 0
}

// e000_therm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:35
func e000_therm(ePos int32, use []int32, Te []tVector, Fe []tVector) int32 {
	use[0] = 0
	return 0
}

// addElem_000 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e000.c:40
func addElem_000() int32 {
	var rv int32
	var type_ int32
	var dim int32
	var nodes int32
	var dofs int32
	var ndof []int32
	var rs int32
	var real_ []int32
	var rs_rp int32
	var real_rp []int32
	var res int32 = 1
	var nres []int32
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e000_stiff
	Elem[type_].mass = e000_mass
	Elem[type_].rvals = e000_rvals
	Elem[type_].eload = e000_eload
	Elem[type_].res_p_loc = e000_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e000_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e001_geom_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:39
func e001_geom_matrix(ePos int32, Mode int32, L float64, K_s []tMatrix) int32 {
	//
	//   File name: fem_e001.c
	//   Date:      2003/04/09 13:11
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Element 001 (2D link)
	//
	// from fem_sb1d.c  - material 008
	var rv int32
	var val float64
	val = 1 / L
	femMatSetZero(K_s)
	femMatPutAdd(K_s, 2, 2, val, 0)
	femMatPutAdd(K_s, 2, 4, -1*val, 0)
	femMatPutAdd(K_s, 4, 2, -1*val, 0)
	femMatPutAdd(K_s, 4, 4, val, 0)
	femMatPrn(K_s, []byte("K_s\x00"))
	return rv
}

// FillTlink2d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:59
func FillTlink2d(c float64, s float64, T []tMatrix) {
	var i int32
	var j int32
	for i = 1; i <= 4; i++ {
		for j = 1; j <= 4; j++ {
			femMatPutAdd(T, i, j, 0, 0)
		}
	}
	femMatPutAdd(T, 1, 1, c, 0)
	femMatPutAdd(T, 1, 2, s, 0)
	femMatPutAdd(T, 2, 1, -s, 0)
	femMatPutAdd(T, 2, 2, c, 0)
	femMatPutAdd(T, 3, 3, c, 0)
	femMatPutAdd(T, 3, 4, s, 0)
	femMatPutAdd(T, 4, 3, -s, 0)
	femMatPutAdd(T, 4, 4, c, 0)
}

// e001_local_stiff_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:83
func e001_local_stiff_matrix(ePos int32, Mode int32, A float64, B float64, D float64, K_e []tMatrix) int32 {
	var rv int32
	// element stifness matrix
	femMatPutAdd(K_e, 1, 1, A, 0)
	femMatPutAdd(K_e, 1, 2, B, 0)
	femMatPutAdd(K_e, 1, 3, -A, 0)
	femMatPutAdd(K_e, 1, 4, -B, 0)
	femMatPutAdd(K_e, 2, 1, B, 0)
	femMatPutAdd(K_e, 2, 2, D, 0)
	femMatPutAdd(K_e, 2, 3, -B, 0)
	femMatPutAdd(K_e, 2, 4, -D, 0)
	femMatPutAdd(K_e, 3, 1, -A, 0)
	femMatPutAdd(K_e, 3, 2, -B, 0)
	femMatPutAdd(K_e, 3, 3, A, 0)
	femMatPutAdd(K_e, 3, 4, B, 0)
	femMatPutAdd(K_e, 4, 1, -B, 0)
	femMatPutAdd(K_e, 4, 2, -D, 0)
	femMatPutAdd(K_e, 4, 3, B, 0)
	femMatPutAdd(K_e, 4, 4, D, 0)
	return rv
}

// e001_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:112
func e001_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	// transformation matrix
	var T tMatrix
	// transformation matrix
	var T_T tMatrix
	// transformation matrix
	var k_0 tMatrix
	// transformation matrix
	var Tk_1 tMatrix
	// transformation matrix
	var k_1 tMatrix
	var F_0 tVector
	var u_e tVector
	var F_1 tVector
	var F_nl tVector
	var u_0 tVector
	var c float64
	var s float64
	var A float64
	var B float64
	var D float64
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var dx float64
	var dy float64
	var L float64
	var Nas float64
	// area
	var Ax float64
	// area
	var Ex float64
	// area
	var Ex0 float64
	// results
	var Fx float64
	var sx float64
	var ex float64
	var Fx1 float64
	var N float64
	var f0_Norm float64
	var f1_Norm float64
	var ft float64
	var Gf float64
	var i int32
	var mtype int32
	mtype = femGetIntPos(femGetIntPos(ePos, eMP, eLen), mpType, mpLen)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 4, 4, 0, nil)
	if fem2ndOrder == 1 {
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:])
		femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 0, 4, 4, 0, nil)
		femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], 0, 4, 4, 0, nil)
		femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:], 0, 4, 4, 0, nil)
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 0, 4, 4)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], 0, 4, 4, 0, nil)
	if mtype == 4 || mtype == 8 {
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_nl))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_nl))[:], 0, 4, 4)
	}
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	noarch.Fprintf(msgout, []byte("E[%li]: x1 = %f, y1 = %f, x2 = %f y2 = %f\n\x00"), eID[ePos], x1, y1, x2, y2)
	dx = x2 - x1
	dy = y2 - y1
	L = math.Sqrt(dy*dy + dx*dx)
	c = dx / L
	s = dy / L
	Ax = femGetRSValPos(ePos, 1, 0)
	if mtype == 4 {
		Ex = femGetRepVal(ePos, 28, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		if Ex <= 1e-17 {
			Ex = femGetMPValPos(ePos, 2, 0)
		}
	} else {
		Ex = femGetMPValPos(ePos, 2, 0)
	}
	noarch.Fprintf(msgout, []byte("Ax = %e, Ex = %e, L=%f c=%f s=%f\n\x00"), Ax, Ex, L, c, s)
	noarch.Fprintf(msgout, []byte("Ex (m=4): %e\n\x00"), Ex)
	Nas = Ex * Ax / L
	A = Nas * c * c
	B = Nas * c * s
	D = Nas * s * s
	femMatSetZero(K_e)
	FillTlink2d(c, s, (*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	if fem2ndOrder == 1 {
		e001_local_stiff_matrix(ePos, Mode, A, B, D, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
		e001_geom_matrix(ePos, Mode, L, (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
		femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:])
		femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
		femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
		N = femGetRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		femMatLinComb(1, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], -1*N, (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], K_e)
	} else {
		e001_local_stiff_matrix(ePos, Mode, A, B, D, K_e)
	}
	femMatPrn(K_e, []byte("K_E\x00"))
	if Mode == 1 {
		// result, F_e, Fr_e
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 4, 4)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 4, 4)
		if fem2ndOrder == 1 || mtype == 4 {
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_0))[:])
			femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_0))[:], 0, 4, 4)
		}
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		// global c.s.
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		FillTlink2d(c, s, (*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
		// residual forces ;-)
		femVecSetZero(Fr_e)
		if fem2ndOrder == 1 {
			// local
			femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&u_0))[:])
			f0_Norm = femVecNorm(F_e)
			femVecClone(F_e, (*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
			femVecClone(F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
			// ------------------------------------------
			e001_local_stiff_matrix(ePos, Mode, A, B, D, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
			e001_geom_matrix(ePos, Mode, L, (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:])
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
			{
				// ------------------------------------------
				for i = 0; float64(i) < 100000; i++ {
					femMatSetZero(K_e)
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:], F_e)
					N = femVecGet(F_e, 1)
					femMatLinComb(1, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], -1*N, (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], K_e)
					femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
					femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
					f1_Norm = femVecNorm((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
					if math.Abs(f0_Norm-f1_Norm) < 0.0001 {
						break
					}
					f0_Norm = f1_Norm
				}
			}
			femVecLinComb(1, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&F_1))[:], Fr_e)
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], F_e)
		}
		// local c.s.
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		Fx = femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1) * -1
		sx = Fx / Ax
		ex = sx / Ex
		noarch.Fprintf(msgout, []byte("ex = %e\n\x00"), ex)
		if mtype == 4 {
			Ex0 = femGetRepVal(ePos, 28, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
			if Ex0 <= 1e-17 {
				Ex0 = femGetMPValPos(ePos, 2, 0)
			}
			noarch.Fprintf(msgout, []byte("ex = %e | EX0 = %e\n\x00"), ex, Ex0)
			Ex = fem_pl1d_E(ePos, Ex0, ex, femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), femGetRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
			noarch.Fprintf(msgout, []byte("Ex = %e <- %e \n\x00"), Ex, Ex0)
		} else {
			Ex = femGetMPValPos(ePos, 2, 0)
		}
		if mtype == 4 {
			Nas = Ex * Ax / L
			A = Nas * c * c
			B = Nas * c * s
			D = Nas * s * s
			// global c.s.
			femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
			femMatSetZero(K_e)
			e001_local_stiff_matrix(ePos, Mode, A, B, D, K_e)
			// global c.s.
			femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&F_nl))[:])
			femVecLinComb(1, F_e, -1, (*[1000000]tVector)(unsafe.Pointer(&F_nl))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
			femVecAddVec(Fr_e, +1, (*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&F_nl))[:], F_e)
		}
		if mtype == 8 {
			// concrete - for testing ONLY (does not work)
			Ex0 = femGetMPValPos(ePos, 2, 0)
			ft = femGetMPValPos(ePos, 7, 0)
			if ex+femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp) > ft/Ex0 {
				// TODO: compute proper ex here:
				Gf = femGetMPValPos(ePos, 9, 0)
				if ex+femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp) > 0 {
					Ex = sb1d_get_Rt_tension(ePos, Ex0, ft, Gf, math.Sqrt(Ax), ex+femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
					if Ex > Ex0 {
						Ex = Ex0
					}
					if Ex < 1e-17 {
						Ex = 1e-17
					}
				} else {
					Ex = Ex0
				}
				Fx = (femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)+ex)*Ex*Ax - femGetRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
				sx = Fx / Ax
				femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 1, -Fx, 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 3, Fx, 0)
				femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:], F_e)
				Fx1 = (femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)+ex)*Ex0*Ax - femGetRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
				noarch.Printf([]byte("Fx1=%e Fx=%e\n\x00"), Fx1, Fx)
				Fx1 = Fx1 - Fx
				noarch.Printf([]byte("dFxr=%e \n\x00"), Fx1)
				femVecSetZero(Fr_e)
				femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 1, -Fx1, 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 3, Fx1, 0)
				femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:], (*[1000000]tVector)(unsafe.Pointer(&F_nl))[:])
				femVecAddVec(Fr_e, +1, (*[1000000]tVector)(unsafe.Pointer(&F_nl))[:])
				femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], []byte("T_T\x00"))
				femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], []byte("F1\x00"))
				femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F_nl))[:], []byte("FNL\x00"))
				femVecPrn(Fr_e, []byte("FrE\x00"))
			} else {
				Ex = Ex0
			}
		}
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, Fx)
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, sx)
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, ex)
		} else {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, Fx)
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, sx)
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, ex)
		}
		femAddPutRepVal(ePos, 28, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, Ex)
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		if fem2ndOrder == 1 || mtype == 4 {
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_0))[:])
		}
	}
	if fem2ndOrder == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Tk_1))[:])
	}
	if mtype == 4 || mtype == 8 {
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_nl))[:])
	}
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	femVecPrn(F_e, []byte("F\x00"))
	femVecPrn(Fr_e, []byte("FR\x00"))
	femMatPrn(K_e, []byte("K\x00"))
	return 0
}

// e001_lenght - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:464
func e001_lenght(ePos int32) float64 {
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var dx float64
	var dy float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	dx = x2 - x1
	dy = y2 - y1
	return math.Sqrt(dy*dy + dx*dx)
}

// e001_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:479
func e001_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var Ax float64
	var ro float64
	var mass float64
	var L float64
	L = e001_lenght(ePos)
	Ax = femGetRSValPos(ePos, 1, 0)
	ro = femGetMPValPos(ePos, 1, 0)
	mass = Ax * L * ro
	noarch.Fprintf(msgout, []byte("Ax = %f, ro = %f, L=%f mass=%f\n\x00"), Ax, ro, L, mass)
	femMatSetZero(M_e)
	femMatPutAdd(M_e, 1, 1, mass/2, 0)
	femMatPutAdd(M_e, 2, 2, mass/2, 0)
	femMatPutAdd(M_e, 3, 3, mass/2, 0)
	femMatPutAdd(M_e, 4, 4, mass/2, 0)
	return rv
}

// e001_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:505
func e001_volume(ePos int32, val []float64) int32 {
	var rv int32
	var Ax float64
	var L float64
	val[0] = 0
	L = e001_lenght(ePos)
	Ax = femGetRSValPos(ePos, 1, 0)
	val[0] = Ax * L
	noarch.Fprintf(msgout, []byte("Ax = %f, L=%f mass=%f\n\x00"), Ax, L, val[0])
	return rv
}

// e001_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:524
func e001_rvals(ePos int32) int32 {
	return 4
}

// e001_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:529
func e001_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e001_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:535
func e001_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var x1 float64
	var x2 float64
	var y1 float64
	var y2 float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	x[0] = 0.5 * (x1 + x2)
	y[0] = 0.5 * (y1 + y2)
	z[0] = 0
	return 0
}

// e001_res_node - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:552
func e001_res_node(ePos int32, nPos int32, type_ int32, val []float64) int32 {
	switch type_ {
	case 1:
		val[0] = femGetRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		return 0
	case 7:
		val[0] = femGetRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		return 0
	case 13:
		val[0] = femGetRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		return 0
	default:
		return -1
		break
	}
	return -1
}

// addElem_001 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e001.c:567
func addElem_001() int32 {
	var rv int32
	var type_ int32 = 1
	var dim int32 = 1
	var nodes int32 = 2
	var dofs int32 = 2
	var ndof []int32 = []int32{1, 2}
	var rs int32 = 4
	var real_ []int32 = []int32{1, 3, 9, 25}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 4
	var nres []int32 = []int32{1, 7, 13, 28}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e001_stiff
	Elem[type_].mass = e001_mass
	Elem[type_].rvals = e001_rvals
	Elem[type_].eload = e001_eload
	Elem[type_].res_p_loc = e001_res_p_loc
	Elem[type_].res_node = e001_res_node
	Elem[type_].volume = e001_volume
	Elem[type_].therm = e000_therm
	return rv
}

// sfr - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:39
func sfr(nnode int32, etasp float64, exitsp float64, shape []tVector, deriv []tMatrix) int32 {
	//
	//   File name: fem_e002.c
	//   Date:      2003/04/09 13:12
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - element 002 (isoparametric plane) definition
	//
	// Evaluates shape functions and their derivatives
	// *  @param deriv matrix with derivatives (2,9)
	// *  @param nnode    number of nodes (4,8,9)
	// *  @param etasp
	// *  @param exitsp
	// *  @param shape    shape funciton (result)[9]
	// *  @param deriv    derivatives (result)[2,9]
	// *  @return state value
	//
	var s float64
	var t float64
	var st float64
	var ss float64
	var tt float64
	var s2 float64
	var t2 float64
	var sst float64
	var stt float64
	var st2 float64
	var s1 float64
	var t1 float64
	var s9 float64
	var t9 float64
	s = exitsp
	t = etasp
	st = s * t
	switch nnode {
	case 4:
		// 4 - node element
		femVecPutAdd(shape, 1, (1-t-s+st)*0.25, 0)
		femVecPutAdd(shape, 2, (1-t+s-st)*0.25, 0)
		femVecPutAdd(shape, 3, (1-t-s+st)*0.25, 0)
		femVecPutAdd(shape, 4, (1-t-s-st)*0.25, 0)
		femMatPutAdd(deriv, 1, 1, (-1+t)*0.25, 0)
		femMatPutAdd(deriv, 1, 2, (+1-t)*0.25, 0)
		femMatPutAdd(deriv, 1, 3, (+1+t)*0.25, 0)
		femMatPutAdd(deriv, 1, 4, (-1-t)*0.25, 0)
		femMatPutAdd(deriv, 2, 1, (-1+s)*0.25, 0)
		femMatPutAdd(deriv, 2, 2, (-1-s)*0.25, 0)
		femMatPutAdd(deriv, 2, 3, (+1+s)*0.25, 0)
		femMatPutAdd(deriv, 2, 4, (+1-s)*0.25, 0)
	case 8:
		// 8 - node element
		s2 = s * 2
		t2 = t * 2
		ss = s * s
		tt = t * t
		st = s * t
		sst = s * s * t
		stt = s * t * t
		st2 = s * t * 2
		femVecPutAdd(shape, 1, (-1+st+ss+tt-sst-stt)*0.25, 0)
		femVecPutAdd(shape, 2, (+1-t-ss+sst)*0.5, 0)
		femVecPutAdd(shape, 3, (-1-st+ss+tt-sst+stt)*0.25, 0)
		femVecPutAdd(shape, 4, (+1+s-tt-stt)*0.5, 0)
		femVecPutAdd(shape, 5, (-1+st+ss+tt+sst+stt)*0.25, 0)
		femVecPutAdd(shape, 6, (+1+t-ss-sst)*0.5, 0)
		femVecPutAdd(shape, 7, (-1-st+ss+tt+sst-stt)*0.25, 0)
		femVecPutAdd(shape, 8, (+1-s-tt+stt)*0.25, 0)
		femMatPutAdd(deriv, 1, 1, (t+s2-st2-tt)*0.25, 0)
		femMatPutAdd(deriv, 1, 2, -s+st, 0)
		femMatPutAdd(deriv, 1, 3, (-t+s2-st2+tt)*0.25, 0)
		femMatPutAdd(deriv, 1, 4, (1-tt)*0.5, 0)
		femMatPutAdd(deriv, 1, 5, (t+s2+st2+tt)*0.25, 0)
		femMatPutAdd(deriv, 1, 6, -s-st, 0)
		femMatPutAdd(deriv, 1, 7, (-t+s2+st2-tt)*0.25, 0)
		femMatPutAdd(deriv, 1, 8, (-1+tt)*0.5, 0)
		femMatPutAdd(deriv, 2, 1, (s+t2-ss-st2)*0.25, 0)
		femMatPutAdd(deriv, 2, 2, (-1+ss)*0.5, 0)
		femMatPutAdd(deriv, 2, 3, (-s+t2-ss+st2)*0.25, 0)
		femMatPutAdd(deriv, 2, 4, -t-st, 0)
		femMatPutAdd(deriv, 2, 5, (s+t2+ss+st2)*0.25, 0)
		femMatPutAdd(deriv, 2, 6, (1-ss)*0.5, 0)
		femMatPutAdd(deriv, 2, 7, (-s+t2+ss-st2)*0.25, 0)
		femMatPutAdd(deriv, 2, 8, -t+st, 0)
	case 9:
		// 9 - node element
		ss = s * s
		st = s * t
		tt = t * t
		s1 = s + 1
		t1 = t + 1
		s2 = s * 2
		t2 = t * 2
		s9 = s - 1
		t9 = t - 1
		femVecPutAdd(shape, 1, 0.25*s9*st*t9, 0)
		femVecPutAdd(shape, 2, 0.5*(1-ss)*t*t9, 0)
		femVecPutAdd(shape, 3, 0.25*s1*st*t9, 0)
		femVecPutAdd(shape, 4, 0.5*s*s1*(1-tt), 0)
		femVecPutAdd(shape, 5, 0.25*s1*st*t1, 0)
		femVecPutAdd(shape, 6, 0.5*(1-ss)*t*t1, 0)
		femVecPutAdd(shape, 7, 0.5*s9*st*t1, 0)
		femVecPutAdd(shape, 8, 0.5*s*s9*(1-tt), 0)
		femVecPutAdd(shape, 8, (1-ss)*(1-tt), 0)
		femMatPutAdd(deriv, 1, 1, 0.25*t*t9*(-1+s2), 0)
		femMatPutAdd(deriv, 1, 2, -st*t9, 0)
		femMatPutAdd(deriv, 1, 3, 0.25*(1+s2)*t*t9, 0)
		femMatPutAdd(deriv, 1, 4, 0.5*(1+s2)*(1-tt), 0)
		femMatPutAdd(deriv, 1, 5, 0.25*(1+s2)*t*t1, 0)
		femMatPutAdd(deriv, 1, 6, -st*t1, 0)
		femMatPutAdd(deriv, 1, 7, 0.25*(-1+s2)*t*t1, 0)
		femMatPutAdd(deriv, 1, 8, 0.5*(-1+s2)*(1-tt), 0)
		femMatPutAdd(deriv, 1, 9, -s2*(1-tt), 0)
		femMatPutAdd(deriv, 2, 1, 0.25*(-1+t2)*s*s9, 0)
		femMatPutAdd(deriv, 2, 2, 0.5*(1-ss)*(-1+t2), 0)
		femMatPutAdd(deriv, 2, 3, 0.25*s*s1*(-1+t2), 0)
		femMatPutAdd(deriv, 2, 4, -st*s1, 0)
		femMatPutAdd(deriv, 2, 5, 0.25*s*s1*(1+t2), 0)
		femMatPutAdd(deriv, 2, 6, 0.5*(1-ss)*(1+t2), 0)
		femMatPutAdd(deriv, 2, 7, 0.25*s*s9*(1+t2), 0)
		femMatPutAdd(deriv, 2, 8, -st*s9, 0)
		femMatPutAdd(deriv, 2, 9, -t2*(1-ss), 0)
		break
	}
	return 0
}

// gaussq - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:157
func gaussq(ngaus int32, posgp []tVector, weigp []tVector) int32 {
	// Sets constant for Gauss integration
	// *  @param ngaus   number of gauss point (2,3)
	// *  @param posgp  point coordinates [4]
	// *  @param weigp   weights [4]
	// *  @return status value
	//
	var kgaus int32
	var igash int32
	var jgash int32
	if ngaus <= 2 {
		femVecPutAdd(posgp, 1, -0.577350569189626, 0)
		femVecPutAdd(weigp, 1, 1, 0)
	} else {
		femVecPutAdd(posgp, 1, -0.774596669241483, 0)
		femVecPutAdd(posgp, 2, 0, 0)
		femVecPutAdd(weigp, 1, 0.555555555555556, 0)
		femVecPutAdd(weigp, 2, 0.888888888888889, 0)
	}
	kgaus = ngaus / 2
	for igash = 1; igash <= kgaus; igash++ {
		jgash = ngaus + 1 - igash
		femVecPutAdd(posgp, jgash, float64(-1)*femVecGet(posgp, igash), 0)
		femVecPutAdd(weigp, jgash, femVecGet(weigp, igash), 0)
	}
	return 0
}

// jacob - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:195
func jacob(cartd []tMatrix, deriv []tMatrix, elcod []tMatrix, djacb []float64, nnode int32) int32 {
	// Evaluates Jacobian matrix and carthesian shape function derivatives
	// *  @param cartd   carthesian s. f. derivatives[2][9]
	// *  @param elcod   coordinates[2][9]
	// *  @param djacb   determinant[?]
	// *  @param nnode   number of nodes
	// *  @return state value
	//
	// long    ielem; - potreba jen pri chybe - pro vyjasneni cisla prvku
	var xjaci [][]float64 = make([][]float64, 3)
	var xjacm [][]float64 = make([][]float64, 3)
	var idime int32
	var inode int32
	var jdime int32
	for idime = 1; idime <= 2; idime++ {
		for jdime = 1; jdime <= 2; jdime++ {
			xjacm[idime][jdime] = 0
			for inode = 1; inode <= nnode; inode++ {
				xjacm[idime][jdime] += femMatGet(deriv, idime, inode) * femMatGet(elcod, jdime, inode)
			}
		}
	}
	djacb[0] = xjacm[1][1]*xjacm[2][2] - xjacm[1][2]*xjacm[2][1]
	if djacb[0] <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s: %e!\n\x00"), []byte("Jacobi matrix: zero determinant found\x00"), djacb[0])
		return -3
	}
	xjaci[1][1] = xjacm[2][2] / djacb[0]
	xjaci[2][2] = xjacm[1][1] / djacb[0]
	xjaci[1][2] = -xjacm[1][2] / djacb[0]
	xjaci[2][1] = -xjacm[2][1] / djacb[0]
	for idime = 1; idime <= 2; idime++ {
		for inode = 1; inode <= nnode; inode++ {
			femMatPutAdd(cartd, idime, inode, 0, 0)
			for jdime = 1; jdime <= 2; jdime++ {
				femMatPutAdd(cartd, idime, inode, xjaci[idime][jdime]*femMatGet(deriv, jdime, inode), 1)
			}
		}
	}
	//fprintf(msgout," %f ",cartd[idime][inode]);
	//fprintf(msgout,"\n");
	return 0
}

// bmatp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:260
func bmatp(cartd []tMatrix, nnode int32, bmatx []tMatrix) int32 {
	// Evaluates strain-displacement matrix
	// *  @param cartd = cartesian derivations [2,10]
	// *  @param nnode = number of nodes (4,8,9)
	// *  @param bmatx = B matrix (result) [2, 18]
	// *  @return state value
	//
	var ngash int32
	var mgash int32
	var inode int32
	for inode = 1; inode <= nnode; inode++ {
		mgash = ngash + 1
		ngash = mgash + 1
		femMatPutAdd(bmatx, 1, mgash, femMatGet(cartd, 1, inode), 0)
		femMatPutAdd(bmatx, 1, ngash, 0, 0)
		femMatPutAdd(bmatx, 2, mgash, 0, 0)
		femMatPutAdd(bmatx, 2, ngash, femMatGet(cartd, 2, inode), 0)
		femMatPutAdd(bmatx, 3, mgash, femMatGet(cartd, 2, inode), 0)
		femMatPutAdd(bmatx, 3, ngash, femMatGet(cartd, 1, inode), 0)
	}
	return 0
}

// dbe - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:289
func dbe(D []tMatrix, bmatx []tMatrix, dbmatx []tMatrix, nat int32) int32 {
	// this doue somenthing
	// *  @param D material stifness matrix [3,3]
	// *  @param  bmatx [3,18]
	// *  @param  dbmatx [3,18]
	// *  @param  nat
	// *  @return state value
	//
	var istre int32
	var ievab int32
	var jstre int32
	for istre = 1; istre <= 3; istre++ {
		for ievab = 1; ievab <= nat; ievab++ {
			femMatPutAdd(dbmatx, istre, ievab, 0, 0)
			for jstre = 1; jstre <= 3; jstre++ {
				femMatPutAdd(dbmatx, istre, ievab, femMatGet(D, istre, jstre)*femMatGet(bmatx, jstre, ievab), 1)
			}
		}
	}
	return 0
}

// mirrorK - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:309
func mirrorK(Ke []tMatrix) {
	var i int32
	var j int32
	for i = 1; i <= Ke[0].rows; i++ {
		for j = 1; j < i; j++ {
			femMatPutAdd(Ke, i, j, femMatGet(Ke, j, i), 0)
		}
	}
}

// stiffp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:346
func stiffp(ePos int32, thick float64, ngaus int32, nnode int32, Ke []tMatrix, re []tVector, Fe []tVector, Fe_r []tVector, Mode int32) int32 {
	// Prepares element sfifness matrix
	// *  @param ePos     element position
	// *  @param eType    element type
	// *  @param mType    material type
	// *  @param optFrom  element options start
	// *  @param optField field with element options
	// *  @param rFrom    element real values start
	// *  @param rFrom    element real values
	// *  @param mFrom    material start
	// *  @param mField   material data
	// *  @param mNum     number of material data
	// *  @param A        element area
	// *  @param nFrom    starting polong in eNodes
	// *  @param eNodes   element nodes description
	// *  @param nField   nodal coordinates
	// *  @param D        material stiffness matrix
	// *  @param thick    element thickness
	// *  @param ngaus    number of gauss polongs (2,3)
	// *  @param nnode    number of nodes (4,8,9)
	// *  @param Ke       element stiffness matrix (result)
	// *  @param nRes     results in nodes (field for results)
	// *  @param Ke       results in longegration polongs (field for results)
	//
	// thickness of element
	// number of gauss points (2,3)
	// number of nodes (4,8,9)
	// element stifness matrix
	// displacement vector
	// force vector
	// residual force vector
	var rv int32
	// element area
	var A float64
	// [10][3];  element coordinates
	var coord tMatrix
	// [3][10];
	var elcod tMatrix
	// [5];
	var posgp tVector
	// [5];
	var weigp tVector
	//[10];
	var shape tVector
	// [3][10];
	var deriv tMatrix
	// [3][10];
	var cartd tMatrix
	// [4][19];
	var bmatx tMatrix
	// [4][19];
	var dbmatx tMatrix
	var djacb float64
	var dvolu float64
	// [4]={0,0,0,0};
	var epsilon tVector
	// [4]={0,0,0,0};
	var sigma tVector
	// [4]={0,0,0,0};  residual
	var sigma_r tVector
	// [4]={0,0,0,0};  previous total
	var sigma_0 tVector
	// [4]={0,0,0,0};  previous total
	var epsilon_0 tVector
	// [4][10];
	var si2 tMatrix
	// [4][10];
	var si2_r tMatrix
	//  [3][3] ;
	var D tMatrix
	//  [3][3] ;
	var D_r tMatrix
	var nat int32
	var i int32
	var j int32
	var igaus int32
	var jgaus int32
	var ievab int32
	var jevab int32
	var istre int32
	var ipoint int32
	// plane stress ;-)
	var ProblemType int32
	var mtype int32
	if thick <= 0 {
		// sets problem type for "D" computation:
		// plane strain
		ProblemType = 1
	} else {
		ProblemType = 0
	}
	// material type:
	mtype = Mat[femGetIntPos(femGetIntPos(ePos, eMP, eLen), mpType, mpLen)].type_
	// number of DOFs
	nat = 2 * nnode
	if nat != Ke[0].rows {
		noarch.Fprintf(msgout, []byte("[E] %s (%li x %li)!\n\x00"), []byte("Invalid size of \"K\" matrix\x00"), nat, Ke[0].rows)
		return -9
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 9, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&elcod))[:], 0, 2, 9, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&posgp))[:], 0, 4, 4)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&weigp))[:], 0, 4, 4)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&shape))[:], 0, 9, 9)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&deriv))[:], 0, 2, 9, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&cartd))[:], 0, 2, 9, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], 0, 3, 18, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&dbmatx))[:], 0, 3, 18, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&si2))[:], 0, 3, 9, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&si2_r))[:], 0, 3, 9, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	// initialization(s):
	femMatSetZero(Ke)
	if Mode == 1 {
		femVecSetZero(Fe)
		if len(Fe_r) != 0 {
			femVecSetZero(Fe_r)
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], 0, 3, 3, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	{
		// coordinates of element nodal points:
		for i = 1; i <= nnode; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			for j = 1; j <= 2; j++ {
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&elcod))[:], j, i, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, j), 0)
			}
		}
	}
	// element area computation
	A = 0.5*(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)) + 0.5*(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2))
	A = A / math.Pow(float64(ngaus), 2)
	// values for gauss:
	gaussq(ngaus, (*[1000000]tVector)(unsafe.Pointer(&posgp))[:], (*[1000000]tVector)(unsafe.Pointer(&weigp))[:])
	ipoint = -1
	{
		// numerical integration loop:
		for igaus = 1; igaus <= ngaus; igaus++ {
			for jgaus = 1; jgaus <= ngaus; jgaus++ {
				ipoint++
				// shape functions, element volume:
				sfr(nnode, femVecGet((*[1000000]tVector)(unsafe.Pointer(&posgp))[:], jgaus), femVecGet((*[1000000]tVector)(unsafe.Pointer(&posgp))[:], igaus), (*[1000000]tVector)(unsafe.Pointer(&shape))[:], (*[1000000]tMatrix)(unsafe.Pointer(&deriv))[:])
				if jacob((*[1000000]tMatrix)(unsafe.Pointer(&cartd))[:], (*[1000000]tMatrix)(unsafe.Pointer(&deriv))[:], (*[1000000]tMatrix)(unsafe.Pointer(&elcod))[:], c4goUnsafeConvert_float64(&djacb), nnode) != 0 {
					// bad element
					rv = -3
					goto memFree
				}
				dvolu = djacb * femVecGet((*[1000000]tVector)(unsafe.Pointer(&weigp))[:], igaus) * femVecGet((*[1000000]tVector)(unsafe.Pointer(&weigp))[:], jgaus)
				if thick > 0 {
					dvolu = dvolu * thick
				}
				// B matrix:
				bmatp((*[1000000]tMatrix)(unsafe.Pointer(&cartd))[:], nnode, (*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:])
				femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], []byte("BMAT\x00"))
				if Mode == 1 {
					femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
					{
						// strain (epsilon)
						for i = 1; i <= 3; i++ {
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], i, 0, 0)
							for j = 1; j <= nat; j++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], i, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], i, j)*femVecGet(re, j), 1)
							}
						}
					}
					if (func() int32 {
						rv = fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], nil, nil, 0, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
						return rv
					}()) != 0 {
						// previous step matrix:
						goto memFree
					}
				} else {
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
					if (func() int32 {
						rv = fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], nil, nil, 0, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
						return rv
					}()) != 0 {
						// create (for mode != NEW) material stiffness matrix:
						goto memFree
					}
				}
				if Mode == 1 {
					if femTangentMatrix == 1 {
						if mtype == 2 {
							// putting of data to iRes field
							// "pseudo sec"
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 1, femGetRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 2, femGetRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 3, femGetRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, femGetRepVal(ePos, 13, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 2, femGetRepVal(ePos, 14, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 3, femGetRepVal(ePos, 16, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							// order is important! - this must be here!
							femAddPutRepVal(ePos, 13, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
							femAddPutRepVal(ePos, 14, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
							femAddPutRepVal(ePos, 16, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
							// e_sum = e_0 + delta_e:
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1), 1)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 2, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2), 1)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 3, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3), 1)
							if (func() int32 {
								rv = fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], nil, nil, 1, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
								return rv
							}()) != 0 {
								goto memFree
							}
							// new sigma
							femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							// sigma_r computation
							femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
							femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
							for i = 1; i <= 3; i++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], i)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i), 1)
							}
							// end of sigma_r computation
							femAddPutRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
							femAddPutRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
							femAddPutRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
							noarch.Fprintf(msgout, []byte("\nSIGMA: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
							noarch.Fprintf(msgout, []byte("\nSIGMA_R: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 3))
						} else {
							if mtype == 8 || mtype == 11 || mtype == 13 {
								// mtype
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 1, femGetRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 2, femGetRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 3, femGetRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
								if (func() int32 {
									rv = fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 1, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
									return rv
								}()) != 0 {
									goto memFree
								}
								femAddPutRepVal(ePos, 13, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
								femAddPutRepVal(ePos, 14, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
								femAddPutRepVal(ePos, 16, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
								femAddPutRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
								femAddPutRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
								femAddPutRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
							} else {
								// mtype != 8
								femAddPutRepVal(ePos, 13, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
								femAddPutRepVal(ePos, 14, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
								femAddPutRepVal(ePos, 16, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
								if (func() int32 {
									rv = fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], nil, nil, 1, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
									return rv
								}()) != 0 {
									goto memFree
								}
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
								for i = 1; i <= 3; i++ {
									femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], i)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i), 0)
								}
								femAddPutRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
								femAddPutRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
								femAddPutRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
								noarch.Fprintf(msgout, []byte("\nSIGMA: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
								femVecPrn((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], []byte("SIGMA_RES\x00"))
							}
						}
					} else {
						// mtype <> 8
						// mtype
						femAddPutRepVal(ePos, 13, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
						femAddPutRepVal(ePos, 14, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
						femAddPutRepVal(ePos, 16, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
						if (func() int32 {
							rv = fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], nil, nil, 1, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
							return rv
						}()) != 0 {
							goto memFree
						}
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
						for i = 1; i <= 3; i++ {
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], i)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i), 0)
						}
						femAddPutRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
						femAddPutRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
						femAddPutRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
						noarch.Fprintf(msgout, []byte("\nSIGMA: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
						noarch.Fprintf(msgout, []byte("\nSIGMA_R: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 3))
					}
					// computed stresses
					femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&si2))[:], 1, ipoint+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), 0)
					femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&si2))[:], 2, ipoint+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), 0)
					femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&si2))[:], 3, ipoint+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3), 0)
					// residual stresses
					femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&si2_r))[:], 1, ipoint+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 1), 0)
					femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&si2_r))[:], 2, ipoint+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 2), 0)
					femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&si2_r))[:], 3, ipoint+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 3), 0)
				}
				dbe((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], (*[1000000]tMatrix)(unsafe.Pointer(&dbmatx))[:], nat)
				{
					// calculate element stiffnesses:
					for ievab = 1; ievab <= nat; ievab++ {
						for jevab = ievab; jevab <= nat; jevab++ {
							for istre = 1; istre <= 3; istre++ {
								femMatPutAdd(Ke, ievab, jevab, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], istre, ievab)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&dbmatx))[:], istre, jevab)*dvolu, 1)
							}
						}
					}
				}
			}
		}
	}
	mirrorK(Ke)
	femMatPrn(Ke, []byte("KE\x00"))
	if Mode == 1 {
		// Nodal forces
		ipoint = 0
		{
			// numerical integration loop:
			for igaus = 1; igaus <= ngaus; igaus++ {
				for jgaus = 1; jgaus <= ngaus; jgaus++ {
					ipoint++
					// shape functions, elemental volume:
					sfr(nnode, femVecGet((*[1000000]tVector)(unsafe.Pointer(&posgp))[:], jgaus), femVecGet((*[1000000]tVector)(unsafe.Pointer(&posgp))[:], igaus), (*[1000000]tVector)(unsafe.Pointer(&shape))[:], (*[1000000]tMatrix)(unsafe.Pointer(&deriv))[:])
					if jacob((*[1000000]tMatrix)(unsafe.Pointer(&cartd))[:], (*[1000000]tMatrix)(unsafe.Pointer(&deriv))[:], (*[1000000]tMatrix)(unsafe.Pointer(&elcod))[:], c4goUnsafeConvert_float64(&djacb), nnode) != 0 {
						// bad element
						rv = -3
						goto memFree
					}
					dvolu = djacb * femVecGet((*[1000000]tVector)(unsafe.Pointer(&weigp))[:], igaus) * femVecGet((*[1000000]tVector)(unsafe.Pointer(&weigp))[:], jgaus)
					if thick > 0 {
						dvolu = dvolu * thick
					}
					// B matrix:
					bmatp((*[1000000]tMatrix)(unsafe.Pointer(&cartd))[:], nnode, (*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:])
					{
						// nodal forces
						for i = 1; i <= nat; i++ {
							{
								// number of stresses
								for istre = 1; istre <= 3; istre++ {
									femVecPutAdd(Fe, i, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], istre, i)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&si2))[:], istre, ipoint)*dvolu, 1)
									{
										//if (Fe_r != NULL)
										femVecPutAdd(Fe_r, i, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:], istre, i)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&si2_r))[:], istre, ipoint)*dvolu, 1)
									}
								}
							}
						}
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&elcod))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&posgp))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&weigp))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&shape))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&deriv))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&cartd))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&bmatx))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&dbmatx))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&si2))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&si2_r))[:])
	if Mode == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
	}
	return rv
}

// e002_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:798
func e002_stiff(ePos int32, Mode int32, K_e []tMatrix, Fe []tVector, Fre []tVector) int32 {
	var rv int32
	var thick float64
	var ngaus int32 = 2
	var nnode int32 = 4
	//long    eT    = 2 ;
	var u_e tVector
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, ngaus*nnode, ngaus*nnode)
		return rv
	}()) != 0 {
		noarch.Fprintf(msgout, []byte("[E] %s %li!\n\x00"), []byte("Out of memory on element\x00"), femGetIntPos(ePos, eID, eLen))
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		return rv
	}
	femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	thick = femGetRSValPos(ePos, 3, 0)
	rv = stiffp(ePos, thick, ngaus, nnode, K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], Fe, Fre, Mode)
	// thickness of element
	// number of gauss points (2,3)
	// number of nodes (4,8,9)
	// element stifness matrix
	// displacement vector
	// force vector
	// residual force vector
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	return rv
}

// e002_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:836
func e002_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var nnode int32 = 4
	var i int32
	var t float64
	var ro float64
	var A float64
	// [10][3];  element coordinates
	var coord tMatrix
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 9, 2, 0, nil)
		return rv
	}()) != 0 {
		return rv
	}
	femMatSetZero(M_e)
	// Geometry (width, area) and material (density) data:
	t = femGetRSValPos(ePos, 3, 0)
	if t <= 0 {
		// plane strain problem
		t = 1
	}
	ro = femGetMPValPos(ePos, 1, 0)
	{
		// coordinates of element nodal points:
		for i = 1; i <= nnode; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			noarch.Fprintf(msgout, []byte("x = %f y= %f\n\x00"), femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 1), femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 2))
		}
	}
	// element area computation
	A = 0.5*(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)) + 0.5*(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2))
	{
		// this is stupid and incorrect but better that nothing:
		for i = 1; i <= nnode*2; i++ {
			femMatPutAdd(M_e, i, i, A*t*ro/float64(nnode), 0)
		}
	}
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	return rv
}

// e002_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:895
func e002_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var nnode int32 = 4
	var i int32
	var t float64
	var A float64
	// [10][3];  element coordinates
	var coord tMatrix
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 9, 2, 0, nil)
		return rv
	}()) != 0 {
		return rv
	}
	// Geometry (width, area) and material (density) data:
	t = femGetRSValPos(ePos, 3, 0)
	{
		// coordinates of element nodal points:
		for i = 1; i <= nnode; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
		}
	}
	// element area computation
	A = 0.5*(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)) + 0.5*(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)+femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2))
	vol[0] = A * t
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	return rv
}

// e002_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:942
func e002_rvals(ePos int32) int32 {
	return 76
}

// e002_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:947
func e002_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e002_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:953
func e002_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	// We assume that there are ALWAYS only 2x2 Gauss points!
	var xx []float64 = make([]float64, 5)
	var yy []float64 = make([]float64, 5)
	var xi []float64 = []float64{0, float64(-1), 1, 1, float64(-1)}
	var yi []float64 = []float64{0, float64(-1), float64(-1), 1, 1}
	var dx float64 = 0.577350569189626
	var dy float64 = 0.577350569189626
	var i int32
	if e002_rvals(ePos) != 64 {
		return -3
	}
	for i = 1; i <= 4; i++ {
		xx[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		yy[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	x[0] = 0
	y[0] = 0
	z[0] = 0
	for i = 1; i <= 4; i++ {
		x[0] += xx[i] * 0.25 * (1 + dx*xi[point]*xi[i]) * (1 + dy*yi[point]*yi[i])
		y[0] += yy[i] * 0.25 * (1 + dx*xi[point]*xi[i]) * (1 + dy*yi[point]*yi[i])
	}
	return 0
}

// e002_res_node - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:984
func e002_res_node(ePos int32, nPos int32, type_ int32, val []float64) int32 {
	var inum int32
	var i int32
	switch nPos {
	case 0:
		inum = 0
	case 1:
		inum = 2
	case 2:
		inum = 3
	case 3:
		inum = 1
	default:
		return -1
	}
	for i = 0; i < Elem[2].res_rp; i++ {
		if type_ == Elem[2].nres_rp[i] {
			val[0] = femGetRepVal(ePos, type_, inum, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
			return 0
		}
	}
	return -1
}

// addElem_002 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e002.c:1010
func addElem_002() int32 {
	var rv int32
	var type_ int32 = 2
	var dim int32 = 2
	var nodes int32 = 4
	var dofs int32 = 2
	var ndof []int32 = []int32{1, 2}
	var rs int32 = 5
	var real_ []int32 = []int32{3, 4, 5, 6, 7}
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 22
	var nres_rp []int32 = []int32{7, 8, 10, 13, 14, 16, 73, 74, 76, 65, 66, 68, 61, 62, 25, 26, 27, 28, 29, 63, 64, 31}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e002_stiff
	Elem[type_].mass = e002_mass
	Elem[type_].rvals = e002_rvals
	Elem[type_].eload = e002_eload
	Elem[type_].res_p_loc = e002_res_p_loc
	Elem[type_].res_node = e002_res_node
	Elem[type_].volume = e002_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e003_geom_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:37
func e003_geom_matrix(ePos int32, Mode int32, L float64, K_s []tMatrix) int32 {
	//
	//   File name: fem_e003.c
	//   Date:      2003/05/18 20:15
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 003 (2D beam)
	//
	//   Note that no element load is used (nodal forces/moments only)
	//
	//  $Id: fem_e003.c,v 1.11 2005/07/11 17:56:16 jirka Exp $
	//
	var rv int32
	femMatSetZero(K_s)
	// bending members part:
	femMatPutAdd(K_s, 2, 2, float64(6/5), 0)
	femMatPutAdd(K_s, 2, 3, L/10, 0)
	femMatPutAdd(K_s, 2, 5, float64(-6/5), 0)
	femMatPutAdd(K_s, 2, 6, L/10, 0)
	femMatPutAdd(K_s, 3, 2, L/10, 0)
	femMatPutAdd(K_s, 3, 3, 2*L*L/15, 0)
	femMatPutAdd(K_s, 3, 5, -L/10, 0)
	femMatPutAdd(K_s, 3, 6, -L*L/30, 0)
	femMatPutAdd(K_s, 5, 2, float64(-6/5), 0)
	femMatPutAdd(K_s, 5, 3, -L/10, 0)
	femMatPutAdd(K_s, 5, 5, float64(6/5), 0)
	femMatPutAdd(K_s, 5, 6, -L/10, 0)
	femMatPutAdd(K_s, 6, 2, L/10, 0)
	femMatPutAdd(K_s, 6, 3, -L*L/30, 0)
	femMatPutAdd(K_s, 6, 5, -L/10, 0)
	femMatPutAdd(K_s, 6, 5, 2*L*L/15, 0)
	femMatPutAdd(K_s, 1, 1, 1, 0)
	femMatPutAdd(K_s, 1, 4, -1, 0)
	femMatPutAdd(K_s, 4, 1, -1, 0)
	femMatPutAdd(K_s, 4, 4, 1, 0)
	femValMatMultSelf(1/L, K_s)
	femMatPrn(K_s, []byte("K_s\x00"))
	return rv
}

// e003_local_stiff_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:76
func e003_local_stiff_matrix(ePos int32, Mode int32, Lx float64, Ex float64, Ax float64, Ix float64, EI float64, kl1 float64, kl2 float64, k_0 []tMatrix) int32 {
	var rv int32
	var i int32
	var j int32
	femMatSetZero(k_0)
	// filling of stiffness matrix:
	femMatPutAdd(k_0, 1, 1, Ax*Ex/Lx, 0)
	femMatPutAdd(k_0, 1, 4, -1*(Ax*Ex)/Lx, 0)
	femMatPutAdd(k_0, 4, 4, Ax*Ex/Lx, 0)
	if kl1 > 0 && kl2 > 0 {
		femMatPutAdd(k_0, 2, 2, 12*Ex*Ix/(Lx*Lx*Lx), 0)
		femMatPutAdd(k_0, 2, 3, 6*Ex*Ix/(Lx*Lx), 0)
		femMatPutAdd(k_0, 2, 5, -12*Ex*Ix/(Lx*Lx*Lx), 0)
		femMatPutAdd(k_0, 2, 6, 6*Ex*Ix/(Lx*Lx), 0)
		femMatPutAdd(k_0, 3, 3, 4*Ex*Ix/Lx, 0)
		femMatPutAdd(k_0, 3, 5, -6*Ex*Ix/(Lx*Lx), 0)
		femMatPutAdd(k_0, 3, 6, 2*Ex*Ix/Lx, 0)
		femMatPutAdd(k_0, 5, 5, 12*Ex*Ix/(Lx*Lx*Lx), 0)
		femMatPutAdd(k_0, 5, 6, -6*Ex*Ix/(Lx*Lx), 0)
		femMatPutAdd(k_0, 6, 6, 4*Ex*Ix/Lx, 0)
	} else {
		if kl1 == 0 && kl2 > 0 {
			// o--|
			femMatPutAdd(k_0, 2, 2, 3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 5, -3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 6, -3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 5, 5, 3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 5, 6, 3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 6, 6, 3*EI/Lx, 0)
		}
		if kl1 > 0 && kl2 == 0 {
			// |--o
			femMatPutAdd(k_0, 2, 2, 3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 3, -3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 5, -3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 3, 2, -3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 3, 3, 3*EI/Lx, 0)
			femMatPutAdd(k_0, 3, 5, 3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 5, 5, 3*EI/(Lx*Lx*Lx), 0)
		}
		if kl1 == 0 && kl2 == 0 {
			// 0-0 - probably a user error
			noarch.Fprintf(msgout, []byte("[W] %s %li!\n\x00"), []byte("Beam with two hinges found - element\x00"), eID[ePos])
		}
	}
	for i = 2; i <= 6; i++ {
		for j = 1; j <= i; j++ {
			femMatPutAdd(k_0, i, j, femMatGet(k_0, j, i), 0)
		}
	}
	femMatPrn(k_0, []byte("K_0\x00"))
	return rv
}

// e003_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:152
func e003_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	// Young's modulus
	var Ex float64
	// area
	var Ax float64
	// moment of inertia
	var Ix float64
	// lenght of beam
	var Lx float64
	var k_0 tMatrix
	var k_g tMatrix
	var k_1 tMatrix
	var Tk_0 tMatrix
	var T tMatrix
	var T_T tMatrix
	var F_0 tVector
	var F_1 tVector
	var u_e tVector
	var u_0 tVector
	var cos_a float64
	var sin_a float64
	var kl1 float64 = 1
	var kl2 float64 = 1
	var N float64
	var EI float64
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if fem2ndOrder == 1 {
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:], 0, 6, 6, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], 0, 6, 6, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	if (func() float64 {
		Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
		return Lx
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		return -3
	}
	cos_a = (x2 - x1) / Lx
	sin_a = (y2 - y1) / Lx
	// geometric properties:
	Ax = femGetRSValPos(ePos, 1, 0)
	Ix = femGetRSValPos(ePos, 9, 0)
	kl1 = femGetRSValPos(ePos, 11, 0)
	kl2 = femGetRSValPos(ePos, 12, 0)
	if kl1 < 0.5 {
		// stiffness of left and right joint:
		kl1 = 0
	} else {
		kl1 = 1
	}
	if kl2 < 0.5 {
		kl2 = 0
	} else {
		kl2 = 1
	}
	// material properties:
	Ex = femGetMPValPos(ePos, 2, 0)
	e003_local_stiff_matrix(ePos, Mode, Lx, Ex, Ax, Ix, Ex*Ix, kl1, kl2, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	// transformation matrix
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 1, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 2, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 1, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 2, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 3, 3, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 4, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 5, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 4, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 5, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 6, 6, 1, 0)
	// transposition of "T"
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	if fem2ndOrder == 1 {
		N = femGetRepVal(ePos, 1, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		e003_geom_matrix(ePos, Mode, Lx, (*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:])
		femMatLinComb(1, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], -1*N, (*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
		// global stiffness matrix:
		femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	} else {
		// global stiffness matrix:
		femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	}
	// finishing of global stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], K_e)
	femMatPrn(K_e, []byte("K_e\x00"))
	if Mode == 1 {
		// ======================================================================
		// result, F_e, Fr_e
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 6, 6)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 6, 6)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 0, 6, 6)
		if fem2ndOrder == 1 {
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_0))[:])
			femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_0))[:], 0, 6, 6)
		}
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], []byte("U_e\x00"))
		// nodal forces:
		// global
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		// to fix problem with moment signs:
		// local
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		// residual forces ;-)
		femVecSetZero(Fr_e)
		femVecPrn(F_e, []byte("F_e\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], []byte("F_0\x00"))
		EI = Ex * Ix
		if femGetIntPos(ePos, eType, eLen) == 3 && femFldItemLen(femGetIntPos(ePos, eRS, eLen), rsFrom, rsLen, rsLenL) > 4 {
			// layered beam
			// recompute stiffness matrix (won't work for 2nd order!):
			// TODO
			e003_local_stiff_matrix(ePos, Mode, Lx, Ex, Ax, Ix, EI, kl1, kl2, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], K_e)
			// global
			femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
			// local
			femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
			femVecLinComb(1, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&F_1))[:], Fr_e)
		}
		if fem2ndOrder == 1 {
		}
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1))
			femAddPutRepVal(ePos, 2, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 2))
			femAddPutRepVal(ePos, 6, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 3))
			femAddPutRepVal(ePos, 1, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 4))
			femAddPutRepVal(ePos, 2, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 5))
			femAddPutRepVal(ePos, 6, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 6))
		} else {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1))
			femAddPutRepVal(ePos, 2, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 2))
			femAddPutRepVal(ePos, 6, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 3))
			femAddPutRepVal(ePos, 1, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 4))
			femAddPutRepVal(ePos, 2, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 5))
			femAddPutRepVal(ePos, 6, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 6))
		}
		//printf("RR %f %f \n",
		//     femGetEResVal(ePos, RES_MZ, 0),
		//     femGetEResVal(ePos, RES_MZ, 1)
		//  );
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
		if fem2ndOrder == 1 {
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_0))[:])
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	if fem2ndOrder == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
	}
	return 0
}

// e003_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:447
func e003_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var Lx float64
	var Ax float64
	var dens float64
	var mass float64
	var sin_a float64
	var cos_a float64
	var i int32
	var j int32
	var Me0 tMatrix
	var Tk_0 tMatrix
	var T tMatrix
	var T_T tMatrix
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 0, 6, 6, 0, nil)
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	if (func() float64 {
		Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
		return Lx
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		return -3
	}
	Ax = femGetRSValPos(ePos, 1, 0)
	dens = femGetMPValPos(ePos, 1, 0)
	femMatSetZero(M_e)
	mass = dens * Ax * Lx / 420
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 1, 1, mass*140, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 1, 4, mass*70, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 2, 2, mass*156, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 2, 3, 22*Lx*mass, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 2, 5, 54*mass, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 2, 6, -13*Lx*mass, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 3, 3, mass*4*Lx*Lx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 3, 5, mass*13*Lx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 3, 6, mass*-3*Lx*Lx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 4, 4, 140*mass, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 5, 5, mass*156, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 5, 6, mass*-22*Lx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], 6, 6, mass*4*Lx*Lx, 0)
	for i = 1; i <= 6; i++ {
		for j = i; j <= 6; j++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], j, i, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], i, j), 0)
		}
	}
	// TODO: transformation
	cos_a = (x2 - x1) / Lx
	sin_a = (y2 - y1) / Lx
	// transformation matrix
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 1, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 2, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 1, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 2, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 3, 3, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 4, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 5, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 4, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 5, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 6, 6, 1, 0)
	// transposition of "T"
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], M_e)
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Me0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	return rv
}

// e003_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:570
func e003_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var Lx float64
	var Ax float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
	Ax = femGetRSValPos(ePos, 1, 0)
	vol[0] = Ax * Lx
	return rv
}

// e003_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:591
func e003_rvals(ePos int32) int32 {
	return 6
}

// e003_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:596
func e003_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e003_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:601
func e003_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	x[0] = 0
	y[0] = 0
	z[0] = 0
	switch point {
	case 0:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	case 1:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
		break
	}
	return 0
}

// addElem_003 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e003.c:621
func addElem_003() int32 {
	var rv int32
	var type_ int32 = 3
	var dim int32 = 5
	var nodes int32 = 2
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 6}
	var rs int32 = 4
	var real_ []int32 = []int32{1, 9, 11, 12}
	var rs_rp int32 = 7
	var real_rp []int32 = []int32{1, 9, 3, 11, 12, 23, 24}
	var res int32 = 3
	var nres []int32 = []int32{1, 2, 6}
	var res_rp int32 = 3
	var nres_rp []int32 = []int32{1, 2, 6}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e003_stiff
	Elem[type_].mass = e003_mass
	Elem[type_].rvals = e003_rvals
	Elem[type_].eload = e003_eload
	Elem[type_].res_p_loc = e003_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e003_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e004_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:35
func e004_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	//
	//   File name: fem_e004.c
	//   Date:      Tue Oct  7 14:18:04 CEST 2004
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 004 (3D - tetrahedron by Kolar et al)
	//
	//  $Id: fem_e004.c,v 1.8 2004/01/11 18:23:25 jirka Exp $
	//
	var rv int32
	// 6x6
	var D tMatrix
	// 6x6
	var D_n tMatrix
	// 12x12
	var S tMatrix
	// 12x12
	var St tMatrix
	// 6x12
	var B tMatrix
	// 12x6
	var Bt tMatrix
	// 12x6
	var StBt tMatrix
	// 12x6
	var StBtD tMatrix
	// 6x12
	var BS tMatrix
	var F_0 tVector
	var u_e tVector
	var epsilon tVector
	var sigma tVector
	var d_sigma tVector
	var volume float64
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var x3 float64
	var y3 float64
	var x4 float64
	var y4 float64
	var z1 float64
	var z2 float64
	var z3 float64
	var z4 float64
	var a1 float64
	var b1 float64
	var c1 float64
	var a2 float64
	var b2 float64
	var c2 float64
	var a3 float64
	var b3 float64
	var c3 float64
	var val1 float64
	var val2 float64
	var eT int32
	var mT int32
	var i int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	femMatSetZero(K_e)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 6, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 12, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], 0, 12, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:], 0, 12, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], 0, 6, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if Mode == 1 {
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D_n))[:])
		if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 12, 12) != 0 {
			goto memFree
		}
		if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 12, 12) != 0 {
			goto memFree
		}
		if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 6, 6) != 0 {
			goto memFree
		}
		if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 6, 6) != 0 {
			goto memFree
		}
		if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 0, 6, 6) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D_n))[:], 0, 6, 6, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	// coordinates
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	x3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_x, nLen)
	y3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_y, nLen)
	z3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_z, nLen)
	x4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_x, nLen)
	y4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_y, nLen)
	z4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_z, nLen)
	noarch.Fprintf(msgout, []byte("E[%li]: x1=%f y1=%f z1=%f, x2=%f y2=%f z2=%f. x3=%f y3=%f z3=%f x4=%f y4=%f z4=%f\n\x00"), eID[ePos], x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)
	a1 = x2 - x1
	a2 = y2 - y1
	a3 = z2 - z1
	b1 = x3 - x1
	b2 = y3 - y1
	b3 = z3 - z1
	c1 = x4 - x1
	c2 = y4 - y1
	c3 = z4 - z1
	if (func() int32 {
		rv = fem_D_3D(ePos, 0, eT, mT, nil, nil, 0, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
		return rv
	}()) != 0 {
		// "D" creation:
		goto memFree
	}
	// "B" matrix:
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 1, 2, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 2, 7, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 3, 12, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 4, 8, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 5, 4, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 5, 10, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 6, 3, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 6, 6, 1, 0)
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	{
		// "S" matrix:
		for i = 0; i < 3; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 2+4*i, x1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 3+4*i, y1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 4+4*i, z1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 2+4*i, x2, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 3+4*i, y2, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 4+4*i, z2, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 2+4*i, x3, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 3+4*i, y3, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 4+4*i, z3, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 2+4*i, x4, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 3+4*i, y4, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 4+4*i, z4, 0)
		}
	}
	if femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&S))[:]) != 0 {
		// hope this works (inversion of "S"):
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inversion of S failed\x00"))
	}
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	// element stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], K_e)
	volume = (a1*b2*c3 + c1*a2*b3 + a3*b1*c2 - (c1*b2*a3 + c3*b1*a2 + a1*b3*c2)) / 6
	femValMatMultSelf(volume, K_e)
	if Mode == 1 {
		// ======================================================================
		// result, F_e, Fr_e
		//
		//   probably epsilon = B* S^-1 * u_e ;-)
		//              6,1 =    6,12 12,12 12,1
		//
		// obtaining of element displacements
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		// nodal forces
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		// strains and stresses:
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		if (func() int32 {
			rv = fem_D_3D(ePos, 0, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], Mode, (*[1000000]tMatrix)(unsafe.Pointer(&D_n))[:])
			return rv
		}()) != 0 {
			// new stiffness matrix:
			goto memFree
		}
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_n))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		{
			// stresses:
			for i = 1; i <= 6; i++ {
				val1 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i)
				val2 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], i)
				val1 -= val2
				// current stress
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i, val2, 0)
				// residual stress
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], i, val1, 0)
			}
		}
		if femTangentMatrix == 1 {
			// saving of results:
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
			femAddPutRepVal(ePos, 8, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
			femAddPutRepVal(ePos, 9, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
			femAddPutRepVal(ePos, 11, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
			femAddPutRepVal(ePos, 12, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
			femAddPutRepVal(ePos, 10, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 6))
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
			femAddPutRepVal(ePos, 14, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
			femAddPutRepVal(ePos, 15, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
			femAddPutRepVal(ePos, 17, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
			femAddPutRepVal(ePos, 18, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5))
			femAddPutRepVal(ePos, 16, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
		} else {
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
			femAddPutRepVal(ePos, 8, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
			femAddPutRepVal(ePos, 9, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
			femAddPutRepVal(ePos, 11, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
			femAddPutRepVal(ePos, 12, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
			femAddPutRepVal(ePos, 10, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
			femAddPutRepVal(ePos, 14, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
			femAddPutRepVal(ePos, 15, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
			femAddPutRepVal(ePos, 17, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
			femAddPutRepVal(ePos, 18, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
			femAddPutRepVal(ePos, 16, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
		}
		// residual forces:
		femVecSetZero(Fr_e)
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], Fr_e)
		femVecPrn(Fr_e, []byte("RESIDUAL FORCES\x00"))
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	if Mode == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D_n))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	return 0
}

// e004_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:302
func e004_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var x3 float64
	var y3 float64
	var x4 float64
	var y4 float64
	var z1 float64
	var z2 float64
	var z3 float64
	var z4 float64
	var a1 float64
	var b1 float64
	var c1 float64
	var a2 float64
	var b2 float64
	var c2 float64
	var a3 float64
	var b3 float64
	var c3 float64
	var volume float64
	var dens float64
	var i int32
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	x3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_x, nLen)
	y3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_y, nLen)
	z3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_z, nLen)
	x4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_x, nLen)
	y4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_y, nLen)
	z4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_z, nLen)
	a1 = x2 - x1
	a2 = y2 - y1
	a3 = z2 - z1
	b1 = x3 - x1
	b2 = y3 - y1
	b3 = z3 - z1
	c1 = x4 - x1
	c2 = y4 - y1
	c3 = z4 - z1
	volume = (a1*b2*c3 + c1*a2*b3 + a3*b1*c2 - (c1*b2*a3 + c3*b1*a2 + a1*b3*c2)) / 6
	noarch.Fprintf(msgout, []byte("volume = %e \n\x00"), volume)
	dens = femGetMPValPos(ePos, 1, 0)
	for i = 1; i <= 12; i++ {
		femMatPutAdd(M_e, i, i, dens*volume/12, 0)
	}
	return rv
}

// e004_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:356
func e004_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var x3 float64
	var y3 float64
	var x4 float64
	var y4 float64
	var z1 float64
	var z2 float64
	var z3 float64
	var z4 float64
	var a1 float64
	var b1 float64
	var c1 float64
	var a2 float64
	var b2 float64
	var c2 float64
	var a3 float64
	var b3 float64
	var c3 float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	x3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_x, nLen)
	y3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_y, nLen)
	z3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_z, nLen)
	x4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_x, nLen)
	y4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_y, nLen)
	z4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_z, nLen)
	a1 = x2 - x1
	a2 = y2 - y1
	a3 = z2 - z1
	b1 = x3 - x1
	b2 = y3 - y1
	b3 = z3 - z1
	c1 = x4 - x1
	c2 = y4 - y1
	c3 = z4 - z1
	vol[0] = (a1*b2*c3 + c1*a2*b3 + a3*b1*c2 - (c1*b2*a3 + c3*b1*a2 + a1*b3*c2)) / 6
	noarch.Fprintf(msgout, []byte("volume = %e \n\x00"), vol[0])
	return rv
}

// e004_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:400
func e004_rvals(ePos int32) int32 {
	return 14
}

// e004_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:405
func e004_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e004_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:410
func e004_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var i int32
	x[0] = 0
	y[0] = 0
	z[0] = 0
	for i = 0; i < 4; i++ {
		x[0] += femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] += femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_y, nLen)
		z[0] += femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_z, nLen)
	}
	x[0] = x[0] / 4
	y[0] = y[0] / 4
	z[0] = z[0] / 4
	return 0
}

// e004_therm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:434
func e004_therm(ePos int32, use []int32, Te []tVector, Fe []tVector) int32 {
	// Computes temperature load for element 011
	var rv int32
	// 6x6
	var D tMatrix
	// 12x12
	var S tMatrix
	// 12x12
	var St tMatrix
	// 6x12
	var B tMatrix
	// 12x6
	var Bt tMatrix
	// 12x6
	var StBt tMatrix
	// 12x6
	var StBtD tMatrix
	var epsilon tVector
	var volume float64
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var x3 float64
	var y3 float64
	var x4 float64
	var y4 float64
	var z1 float64
	var z2 float64
	var z3 float64
	var z4 float64
	var a1 float64
	var b1 float64
	var c1 float64
	var a2 float64
	var b2 float64
	var c2 float64
	var a3 float64
	var b3 float64
	var c3 float64
	var alpha float64
	var temp float64
	var eT int32
	var mT int32
	var i int32
	use[0] = 1
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	alpha = femGetMPValPos(ePos, 38, 0)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 6, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 12, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], 0, 12, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:], 0, 12, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 6, 6) != 0 {
		goto memFree
	}
	// coordinates
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	x3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_x, nLen)
	y3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_y, nLen)
	z3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_z, nLen)
	x4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_x, nLen)
	y4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_y, nLen)
	z4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_z, nLen)
	noarch.Fprintf(msgout, []byte("E[%li]: x1=%f y1=%f z1=%f, x2=%f y2=%f z2=%f. x3=%f y3=%f z3=%f x4=%f y4=%f z4=%f\n\x00"), eID[ePos], x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)
	a1 = x2 - x1
	a2 = y2 - y1
	a3 = z2 - z1
	b1 = x3 - x1
	b2 = y3 - y1
	b3 = z3 - z1
	c1 = x4 - x1
	c2 = y4 - y1
	c3 = z4 - z1
	if (func() int32 {
		rv = fem_D_3D(ePos, 0, eT, mT, nil, nil, 0, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
		return rv
	}()) != 0 {
		// "D" creation:
		goto memFree
	}
	// "B" matrix:
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 1, 2, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 2, 7, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 3, 12, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 4, 8, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 5, 4, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 5, 10, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 6, 3, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 6, 6, 1, 0)
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	{
		// "S" matrix:
		for i = 0; i < 3; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 2+4*i, x1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 3+4*i, y1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1+i, 4+4*i, z1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 2+4*i, x2, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 3+4*i, y2, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4+i, 4+4*i, z2, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 2+4*i, x3, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 3+4*i, y3, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 7+i, 4+4*i, z3, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 1+4*i, 1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 2+4*i, x4, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 3+4*i, y4, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 10+i, 4+4*i, z4, 0)
		}
	}
	if femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&S))[:]) != 0 {
		// hope this works (inversion of "S"):
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inversion of S failed\x00"))
	}
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	volume = (a1*b2*c3 + c1*a2*b3 + a3*b1*c2 - (c1*b2*a3 + c3*b1*a2 + a1*b3*c2)) / 6
	// set temperature strains:
	temp = (femVecGet(Te, 1) + femVecGet(Te, 2) + femVecGet(Te, 3) + femVecGet(Te, 4)) / 4
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1, alpha*temp, 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2, alpha*temp, 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3, 0, 0)
	// stiffness matrix is computed
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], Fe)
	femValVecMultSelf(volume, Fe)
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	return rv
}

// addElem_004 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e004.c:592
func addElem_004() int32 {
	var rv int32
	var type_ int32 = 4
	var dim int32 = 3
	var nodes int32 = 4
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 3}
	var rs int32
	var real_ []int32
	var rs_rp int32
	var real_rp []int32
	var res int32 = 14
	var nres []int32 = []int32{7, 8, 9, 11, 12, 10, 13, 14, 15, 17, 18, 16, 37, 38}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e004_stiff
	Elem[type_].mass = e004_mass
	Elem[type_].rvals = e004_rvals
	Elem[type_].eload = e004_eload
	Elem[type_].res_p_loc = e004_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e004_volume
	Elem[type_].therm = e004_therm
	return rv
}

// p_5_nodes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:34
//
//   File name: fem_e005.c
//   Date:      2003/11/12 20:44
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - element 005 (isoparametric Mindlin's slab) definition
//
//	 $Id: fem_e005.c,v 1.5 2004/12/31 00:31:06 jirka Exp $
//
//
// nodes of slab
var p_5_nodes []int32 = []int32{1, 2, 3, 4}

// fem_D_slab - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:36
func fem_D_slab(ePos int32, t float64, mode int32, Dmat []tMatrix) int32 {
	var Ex float64
	var nu float64
	var G float64
	var D float64
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	G = Ex / (2 * (1 + nu))
	D = Ex * math.Pow(t, 3) / (12 * (1 - nu*nu))
	femMatSetZero(Dmat)
	femMatPutAdd(Dmat, 1, 1, D, 0)
	femMatPutAdd(Dmat, 1, 2, D*nu, 0)
	femMatPutAdd(Dmat, 2, 1, D*nu, 0)
	femMatPutAdd(Dmat, 2, 2, D, 0)
	femMatPutAdd(Dmat, 3, 3, 0.5*((1-nu)*D), 0)
	femMatPutAdd(Dmat, 4, 4, 1.2*G*t, 0)
	femMatPutAdd(Dmat, 5, 5, 1.2*G*t, 0)
	return 0
}

// e005_fill_coords - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:62
func e005_fill_coords(coord []tMatrix) {
	// prepares coordinates of points
	femMatPutAdd(coord, 1, 1, -1, 0)
	femMatPutAdd(coord, 1, 2, -1, 0)
	femMatPutAdd(coord, 1, 3, 0, 0)
	femMatPutAdd(coord, 2, 1, 1, 0)
	femMatPutAdd(coord, 2, 2, -1, 0)
	femMatPutAdd(coord, 2, 3, 0, 0)
	femMatPutAdd(coord, 3, 1, 1, 0)
	femMatPutAdd(coord, 3, 2, 1, 0)
	femMatPutAdd(coord, 3, 3, 0, 0)
	femMatPutAdd(coord, 4, 1, -1, 0)
	femMatPutAdd(coord, 4, 2, 1, 0)
	femMatPutAdd(coord, 4, 3, 0, 0)
}

// e005_jac_det - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:86
func e005_jac_det(jac []tMatrix, detj []float64) (c4goDefaultReturn int32) {
	// determinant of Jacobi matrix
	// * @param jac Jacobi matrix
	// * @param detj determinant (result)
	// * @return status
	//
	detj[0] = femMatGet(jac, 1, 1)*femMatGet(jac, 2, 2) - femMatGet(jac, 2, 1)*femMatGet(jac, 1, 2)
	if detj[0] <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid element found\x00"))
		detj[0] = 0
		return -3
	} else {
		return 0
	}
	return
}

// e005_p_a - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:112
func e005_p_a(coord []tMatrix, deriv int32, point int32, x float64, y float64) (c4goDefaultReturn float64) {
	// note: deriv = 0 => no derivation (value of function)!
	// *       deriv = 1 => d/dx
	// *       deriv = 2 => d/dy
	// *       deriv = 3 => d/dz
	//
	var xv float64
	var yv float64
	xv = femMatGet(coord, point, 1)
	yv = femMatGet(coord, point, 2)
	switch deriv {
	case 0:
		return 0.25 * (1 + xv*x) * (1 + yv*y)
	case 1:
		// d/dx)
		return 0.25 * xv * (1 + yv*y)
	case 2:
		// d/dy)
		return 0.25 * yv * (1 + xv*x)
	default:
		return 0
	}
	return
}

// e005_deriv_p - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:155
func e005_deriv_p(coord []tMatrix, deriv int32, dir int32, x float64, y float64, xyz []tMatrix) float64 {
	// Computes coordinates od d(p)/d(something)
	// * @param coord matrix of -1,0,1 brick coordinates
	// * @param deriv derivation type (0=none,1=d/dx,2=d/dy,3=d/dz)
	// * @param dir coordinate type (1=x,2=y,3=z)
	// * @param x x of [-1,1]
	// * @param y y of [-1,1]
	// * @param z z of [-1,1]
	// * @param xyz matrix of real brick coordinates (NULL if  you want only the derivatives)
	// * @return coordinate/derivative value
	// *
	var val float64
	var val_i float64
	var i int32
	val = 0
	for i = 0; i < 4; i++ {
		val_i = e005_p_a(coord, deriv, p_5_nodes[i], x, y)
		if len(xyz) != 0 {
			val_i *= femMatGet(xyz, p_5_nodes[i], dir)
		}
		val += val_i
	}
	return val
}

// e005_deriv_p_one - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:180
func e005_deriv_p_one(coord []tMatrix, deriv int32, number int32, x float64, y float64) float64 {
	// Computes coordinates of d(p)/d(something) of ONE P_x
	// * @param coord matrix of -1,0,1 brick coordinates
	// * @param deriv derivation type (0=none,1=d/dx,2=d/dy,3=d/dz)
	// * @param number number of node (1..20)
	// * @return coordinate/derivative value
	// *
	return e005_p_a(coord, deriv, number, x, y)
}

// e005_fill_J - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:186
func e005_fill_J(jac []tMatrix, coord []tMatrix, x float64, y float64, xyz []tMatrix) int32 {
	var i int32
	var j int32
	femMatSetZero(jac)
	for i = 1; i <= 2; i++ {
		for j = 1; j <= 2; j++ {
			femMatPutAdd(jac, i, j, e005_deriv_p(coord, i, j, x, y, xyz), 1)
		}
	}
	return 0
}

// e005_fill_H - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:204
func e005_fill_H(H []tMatrix, ijac []tMatrix, coord []tMatrix, x float64, y float64) int32 {
	var hdx float64
	var hdy float64
	var hhh float64
	var pos int32
	var i int32
	femMatSetZero(H)
	for i = 0; i < 4; i++ {
		hdx = femMatGet(ijac, 1, 1)*e005_deriv_p_one(coord, 1, i+1, x, y) + femMatGet(ijac, 1, 2)*e005_deriv_p_one(coord, 2, i+1, x, y)
		hdy = femMatGet(ijac, 2, 1)*e005_deriv_p_one(coord, 1, i+1, x, y) + femMatGet(ijac, 2, 2)*e005_deriv_p_one(coord, 2, i+1, x, y)
		hhh = e005_deriv_p_one(coord, 0, i+1, x, y)
		pos = 3 * i
		femMatPutAdd(H, 1, 2+pos, hdx, 0)
		femMatPutAdd(H, 2, 3+pos, hdy, 0)
		femMatPutAdd(H, 3, 2+pos, hdy, 0)
		femMatPutAdd(H, 3, 3+pos, hdx, 0)
		femMatPutAdd(H, 4, 1+pos, -1*hdx, 0)
		femMatPutAdd(H, 4, 2+pos, hhh, 0)
		femMatPutAdd(H, 5, 1+pos, -(1)*hdy, 0)
		femMatPutAdd(H, 5, 3+pos, hhh, 0)
	}
	return 0
}

// e005_fill_N - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:235
func e005_fill_N(H []tMatrix, coord []tMatrix, x float64, y float64) int32 {
	var hii float64
	var pos int32
	var i int32
	femMatSetZero(H)
	for i = 0; i < 4; i++ {
		hii = e005_deriv_p_one(coord, 0, i+1, x, y)
		pos = 3 * i
		femMatPutAdd(H, 1, 1+pos, hii, 0)
		femMatPutAdd(H, 2, 2+pos, hii, 0)
		femMatPutAdd(H, 3, 3+pos, hii, 0)
	}
	return 0
}

// e005_init_gauss - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:256
func e005_init_gauss(ipoints int32, gauss []tMatrix) int32 {
	switch ipoints {
	case 2:
		femMatPutAdd(gauss, 1, 1, -0.577350269189626, 0)
		femMatPutAdd(gauss, 1, 2, 1, 0)
		femMatPutAdd(gauss, 2, 1, 0.577350269189626, 0)
		femMatPutAdd(gauss, 2, 2, 1, 0)
	case 3:
		femMatPutAdd(gauss, 1, 1, -0.774596669241483, 0)
		femMatPutAdd(gauss, 1, 2, 0.555555555555556, 0)
		femMatPutAdd(gauss, 2, 1, 0, 0)
		femMatPutAdd(gauss, 2, 2, 0.888888888888889, 0)
		femMatPutAdd(gauss, 3, 1, 0.774596669241483, 0)
		femMatPutAdd(gauss, 3, 2, 0.555555555555556, 0)
	case 4:
		femMatPutAdd(gauss, 1, 1, -0.861136311594053, 0)
		femMatPutAdd(gauss, 1, 2, 0.347854845137454, 0)
		femMatPutAdd(gauss, 2, 1, -0.339981043584856, 0)
		femMatPutAdd(gauss, 2, 2, 0.652145154862546, 0)
		femMatPutAdd(gauss, 3, 1, 0.339981043584856, 0)
		femMatPutAdd(gauss, 3, 2, 0.652145154862546, 0)
		femMatPutAdd(gauss, 4, 1, 0.861136311594053, 0)
		femMatPutAdd(gauss, 4, 2, 0.347854845137454, 0)
	default:
		noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Invalid number of integration points\x00"), ipoints)
		return -3
		break
	}
	return 0
}

// e005_test_ij - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:303
func e005_test_ij(val int32, ii int32, jj int32) int32 {
	var vals []int32 = make([]int32, 4)
	var i int32
	var iiok int32
	var jjok int32
	vals[0] = val
	for i = 1; i < 4; i++ {
		vals[i] = i*3 + val
	}
	for i = 0; i < 4; i++ {
		if ii == vals[i] {
			iiok = 1
			break
		}
	}
	if iiok != 1 {
		return 0
	}
	for i = 0; i < 4; i++ {
		if jj == vals[i] {
			jjok = 1
			return 1
		}
	}
	return 0
}

// e005_shape_mat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:331
func e005_shape_mat(ePos int32, mult_val float64, M_e []tMatrix, all int32, pos_winkler int32) int32 {
	var rv int32
	var coord tMatrix
	var xyz tMatrix
	var jac tMatrix
	var H tMatrix
	var HT tMatrix
	var M_i tMatrix
	var gauss tMatrix
	var detj float64
	var ipoints int32 = 2
	var x float64
	var y float64
	var weight_x float64
	var weight_y float64
	var mult float64 = 1
	var ipos int32
	var eT int32
	var mT int32
	var i int32
	var j int32
	var ii int32
	var jj int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 4, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 4, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 3, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 12, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e005_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e005_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= 4; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
		}
	}
	// numerical integration:
	ipos = -1
	{
		// -----------------------
		for i = 1; i <= ipoints; i++ {
			for j = 1; j <= ipoints; j++ {
				ipos++
				// int. point coordinates:
				x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
				y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
				weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
				weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
				// jacobi matrix:
				e005_fill_J((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, (*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
				if (func() int32 {
					rv = e005_jac_det((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], c4goUnsafeConvert_float64(&detj))
					return rv
				}()) != 0 {
					// determinant
					goto memFree
				}
				if (func() int32 {
					rv = e005_fill_N((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y)
					return rv
				}()) != 0 {
					goto memFree
				}
				femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
				femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
				// 60,6 x 6,60 = 60,60
				femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
				mult = mult_val * detj * weight_x * weight_y
				for ii = 1; ii <= 12; ii++ {
					for jj = 1; jj <= 12; jj++ {
						if all != 1 {
							if e005_test_ij(pos_winkler, ii, jj) == 1 {
								femMatPutAdd(M_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], ii, jj), 1)
							}
						} else {
							femMatPutAdd(M_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], ii, jj), 1)
						}
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	return rv
}

// e005_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:459
func e005_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var coord tMatrix
	var xyz tMatrix
	var jac tMatrix
	var ijac tMatrix
	var H tMatrix
	var HT tMatrix
	var D tMatrix
	var D_r tMatrix
	var HTD tMatrix
	var K_i tMatrix
	var gauss tMatrix
	var epsilon tVector
	var sigma tVector
	var sigma_0 tVector
	var epsilon_0 tVector
	var d_sigma tVector
	var u_e tVector
	var F_0 tVector
	var thick float64
	var winkler float64
	var detj float64
	// DO NOT USE different number than 2 !!!
	var ipoints int32 = 2
	var x float64
	var y float64
	var weight_x float64
	var weight_y float64
	var mult float64 = 1
	var ipos int32
	var eT int32
	var mT int32
	var i int32
	var j int32
	var ii int32
	var jj int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	thick = femGetRSValPos(ePos, 3, 0)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&ijac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 8, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 8, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&ijac))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 5, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 12, 5, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:], 0, 12, 5, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 5, 5, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if Mode == 1 {
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 12, 12)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 5, 5)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 5, 5)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 0, 5, 5)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 0, 5, 5)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 0, 5, 5)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 12, 12)
			return rv
		}()) != 0 {
			goto memFree
		}
		femVecSetZero(F_e)
		if len(Fr_e) != 0 {
			femVecSetZero(Fr_e)
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], 0, 5, 5, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
		// displacements:
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e005_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e005_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= 4; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
		}
	}
	femMatSetZero(K_e)
	// numerical integration:
	ipos = -1
	{
		// -----------------------
		for i = 1; i <= ipoints; i++ {
			for j = 1; j <= ipoints; j++ {
				ipos++
				// int. point coordinates:
				x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
				y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
				weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
				weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
				// jacobi matrix:
				e005_fill_J((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, (*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
				if (func() int32 {
					rv = e005_jac_det((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], c4goUnsafeConvert_float64(&detj))
					return rv
				}()) != 0 {
					// determinant
					goto memFree
				}
				// integration multiplier
				mult = detj * weight_x * weight_y
				if femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:]) != 0 {
					// inversion - "jac" will be a inverse matrix
					noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inversion of Jascobi matric failed\x00"))
					goto memFree
				}
				if (func() int32 {
					rv = e005_fill_H((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y)
					return rv
				}()) != 0 {
					goto memFree
				}
				femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
				if Mode == 1 {
					femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
					if (func() int32 {
						rv = fem_D_slab(ePos, thick, 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
						return rv
					}()) != 0 {
						goto memFree
					}
					femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
					femAddPutRepVal(ePos, 48, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
					femAddPutRepVal(ePos, 49, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
					femAddPutRepVal(ePos, 50, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
					femAddPutRepVal(ePos, 51, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
					femAddPutRepVal(ePos, 52, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
					femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
					for ii = 1; ii <= 12; ii++ {
						femVecPutAdd(F_e, ii, mult*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], ii), 1)
					}
					femVecSetZero(Fr_e)
				} else {
					if (func() int32 {
						rv = fem_D_slab(ePos, thick, 0, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
						return rv
					}()) != 0 {
						// "D" computation should be usefull here ;-)
						goto memFree
					}
				}
				femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
				femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
				// 60,6 x 6,6 = 60,6
				femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
				// 60,6 z 6,60  = 60,60
				femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
				for ii = 1; ii <= 12; ii++ {
					for jj = 1; jj <= 12; jj++ {
						femMatPutAdd(K_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:], ii, jj), 1)
					}
				}
			}
		}
	}
	if Mode != 1 {
		// Winkler's foundation
		winkler = femGetRSValPos(ePos, 13, 0)
		if winkler > 0 {
			e005_shape_mat(ePos, winkler, K_e, 0, 1)
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&ijac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if Mode == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
	}
	//femMatPrn(K_e,"K_e");
	return rv
}

// e005_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:713
func e005_mass(ePos int32, M_e []tMatrix) int32 {
	var ro float64
	var width float64
	femMatSetZero(M_e)
	ro = femGetMPValPos(ePos, 1, 0)
	width = femGetRSValPos(ePos, 3, 0)
	return e005_shape_mat(ePos, ro*width, M_e, 1, 0)
}

// e005_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:726
func e005_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var width float64
	var e float64
	var f float64
	var fi float64
	var Li []float64 = make([]float64, 5)
	var i int32
	var j int32
	var coord tMatrix
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 4, 3, 0, nil)
		return rv
	}()) != 0 {
		rv = -4
		goto memFree
	}
	e005_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	for i = 1; i <= 4; i++ {
		j = i + 1
		if j > 4 {
			j = 1
		}
		Li[i] = math.Sqrt(math.Pow(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], j, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 2), 2) + math.Pow(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], j, 1)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], i, 1), 2))
	}
	e = math.Sqrt(math.Pow(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 2), 2) + math.Pow(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 3, 1)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 1, 1), 2))
	f = math.Sqrt(math.Pow(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 2)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 2), 2) + math.Pow(femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 4, 1)-femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 2, 1), 2))
	width = femGetRSValPos(ePos, 3, 0)
	fi = math.Acos(Li[1]*Li[1]+e*e-Li[2]*Li[2])/(2*Li[1]*e) + math.Acos(Li[1]*Li[1]+f*f-Li[4]*Li[4])/(2*Li[1]*f)
	vol[0] = 0.5 * e * f * math.Sin(fi)
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	return rv
}

// e005_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:777
func e005_rvals(ePos int32) int32 {
	return 5 * 2 * 2
}

// e005_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:782
func e005_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e005_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:787
func e005_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var xx []float64 = make([]float64, 5)
	var yy []float64 = make([]float64, 5)
	var xi []float64 = []float64{0, float64(-1), 1, 1, float64(-1)}
	var yi []float64 = []float64{0, float64(-1), float64(-1), 1, 1}
	var dx float64 = 0.577350569189626
	var dy float64 = 0.577350569189626
	var i int32
	if e005_rvals(ePos) != 5*2*2 {
		return -3
	}
	for i = 1; i <= 4; i++ {
		xx[i] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
		yy[i] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	x[0] = 0
	y[0] = 0
	z[0] = 0
	for i = 1; i <= 4; i++ {
		x[0] += xx[i] * 0.25 * (1 + dx*xi[point]*xi[i] + dy*yi[point]*yi[i])
		y[0] += yy[i] * 0.25 * (1 + dx*xi[point]*xi[i] + dy*yi[point]*yi[i])
	}
	return 0
}

// addElem_005 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e005.c:818
func addElem_005() int32 {
	var rv int32
	var type_ int32 = 5
	// slab
	var dim int32 = 4
	var nodes int32 = 4
	var dofs int32 = 3
	var ndof []int32 = []int32{3, 5, 4}
	var rs int32 = 2
	var real_ []int32 = []int32{3, 13}
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 5
	var nres_rp []int32 = []int32{48, 49, 50, 51, 52}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e005_stiff
	Elem[type_].mass = e005_mass
	Elem[type_].rvals = e005_rvals
	Elem[type_].eload = e005_eload
	Elem[type_].res_p_loc = e005_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e005_volume
	Elem[type_].therm = e000_therm
	return rv
}

// addElem_006 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e006.c:37
func addElem_006() int32 {
	//
	//   File name: fem_e006.c
	//   Date:      2003/04/09 13:11
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Element 006 (2D link)
	//
	var rv int32
	var type_ int32 = 6
	var dim int32 = 1
	var nodes int32 = 2
	var dofs int32 = 2
	var ndof []int32 = []int32{1, 2}
	var rs int32 = 3
	var real_ []int32 = []int32{1, 9, 10}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 3
	var nres []int32 = []int32{1, 7, 13}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e001_stiff
	Elem[type_].mass = e001_mass
	Elem[type_].rvals = e001_rvals
	Elem[type_].eload = e001_eload
	Elem[type_].res_p_loc = e001_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e001_volume
	Elem[type_].therm = e000_therm
	return rv
}

// FillTlink3d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:30
func FillTlink3d(a float64, b float64, c float64, T []tMatrix) {
	//
	//   File name: fem_e007.c
	//   Date:      2003/04/09 13:11
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Element 007 (3D link)
	//
	femMatSetZero(T)
	femMatPutAdd(T, 1, 1, a, 0)
	femMatPutAdd(T, 1, 2, b, 0)
	femMatPutAdd(T, 1, 3, c, 0)
	femMatPutAdd(T, 2, 4, a, 0)
	femMatPutAdd(T, 2, 5, b, 0)
	femMatPutAdd(T, 2, 6, c, 0)
}

// e007_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:43
func e007_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	// transformation matrix
	var T tMatrix
	var F_0 tVector
	var u_e tVector
	var x1 float64
	var y1 float64
	var z1 float64
	var x2 float64
	var y2 float64
	var z2 float64
	var dx float64
	var dy float64
	var dz float64
	var L float64
	var Nas float64
	var a float64
	var b float64
	var c float64
	// area
	var Ax float64
	// area
	var Ex float64
	// results
	var Fx float64
	var sx float64
	var ex float64
	var i int32
	var j int32
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 2, 6, 0, nil)
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	noarch.Fprintf(msgout, []byte("E[%li]: x1 = %f, y1 = %f, x2 = %f y2 = %f\n\x00"), eID[ePos], x1, y1, x2, y2)
	dx = x2 - x1
	dy = y2 - y1
	dz = z2 - z1
	L = math.Sqrt(dy*dy + dx*dx + dz*dz)
	a = dx / L
	b = dy / L
	c = dz / L
	Ax = femGetRSValPos(ePos, 1, 0)
	Ex = femGetMPValPos(ePos, 2, 0)
	noarch.Fprintf(msgout, []byte("Ax = %e, Ex = %e, L=%f a=%f b=%f c=%f\n\x00"), Ax, Ex, L, a, b, c)
	Nas = Ex * Ax / L
	femMatSetZero(K_e)
	femMatPutAdd(K_e, 1, 1, a*a*Nas, 0)
	femMatPutAdd(K_e, 1, 2, a*b*Nas, 0)
	femMatPutAdd(K_e, 1, 3, a*c*Nas, 0)
	femMatPutAdd(K_e, 2, 1, a*b*Nas, 0)
	femMatPutAdd(K_e, 2, 2, b*b*Nas, 0)
	femMatPutAdd(K_e, 2, 3, b*c*Nas, 0)
	femMatPutAdd(K_e, 3, 1, a*c*Nas, 0)
	femMatPutAdd(K_e, 3, 2, b*c*Nas, 0)
	femMatPutAdd(K_e, 3, 3, c*c*Nas, 0)
	for i = 1; i <= 3; i++ {
		for j = 1; j <= 3; j++ {
			femMatPutAdd(K_e, i+3, j, -1*femMatGet(K_e, i, j), 0)
			femMatPutAdd(K_e, i+3, j+3, femMatGet(K_e, i, j), 0)
			femMatPutAdd(K_e, i, j+3, -1*femMatGet(K_e, i, j), 0)
		}
	}
	if Mode == 1 {
		// result, F_e, Fr_e
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 2, 2)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 6, 6)
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		// global c.s.
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		FillTlink3d(a, b, c, (*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
		// residual forces ;-)
		femVecSetZero(Fr_e)
		// local c.s.
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		Fx = femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1) * -1
		sx = Fx / Ax
		ex = sx / Ex
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, Fx)
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, sx)
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, ex)
		} else {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, Fx)
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, sx)
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, ex)
		}
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	return 0
}

// e007_length - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:158
func e007_length(ePos int32) float64 {
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var z1 float64
	var z2 float64
	var dx float64
	var dy float64
	var dz float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	dx = x2 - x1
	dy = y2 - y1
	dz = z2 - z1
	return math.Sqrt(dy*dy + dx*dx + dz*dz)
}

// e007_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:176
func e007_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var Ax float64
	var ro float64
	var mass float64
	var L float64
	L = e007_length(ePos)
	Ax = femGetRSValPos(ePos, 1, 0)
	ro = femGetMPValPos(ePos, 1, 0)
	mass = Ax * L * ro
	noarch.Fprintf(msgout, []byte("Ax = %f, ro = %f, L=%f mass=%f\n\x00"), Ax, ro, L, mass)
	femMatSetZero(M_e)
	femMatPutAdd(M_e, 1, 1, mass/2, 0)
	femMatPutAdd(M_e, 2, 2, mass/2, 0)
	femMatPutAdd(M_e, 3, 3, mass/2, 0)
	femMatPutAdd(M_e, 4, 4, mass/2, 0)
	femMatPutAdd(M_e, 5, 5, mass/2, 0)
	femMatPutAdd(M_e, 5, 5, mass/2, 0)
	return rv
}

// e007_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:205
func e007_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var Ax float64
	var L float64
	L = e007_length(ePos)
	Ax = femGetRSValPos(ePos, 1, 0)
	vol[0] = Ax * L
	return rv
}

// e007_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:218
func e007_rvals(ePos int32) int32 {
	return 3
}

// e007_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:223
func e007_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var x1 float64
	var x2 float64
	var y1 float64
	var y2 float64
	var z1 float64
	var z2 float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	x[0] = 0.5 * (x1 + x2)
	y[0] = 0.5 * (y1 + y2)
	z[0] = 0.5 * (z1 + z2)
	return 0
}

// e007_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:242
func e007_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// addElem_007 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e007.c:247
func addElem_007() int32 {
	var rv int32
	var type_ int32 = 7
	var dim int32 = 1
	var nodes int32 = 2
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 3}
	var rs int32 = 7
	var real_ []int32 = []int32{1, 9, 10, 3, 2, 25, 26}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 3
	var nres []int32 = []int32{1, 7, 13}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e007_stiff
	Elem[type_].mass = e007_mass
	Elem[type_].rvals = e007_rvals
	Elem[type_].eload = e007_eload
	Elem[type_].res_p_loc = e007_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e007_volume
	Elem[type_].therm = e000_therm
	return rv
}

// p_a_nodes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:31
//
//   File name: fem_e008.c
//   Date:      2004/03/07 15:54
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2004 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - Element 008 (structural brick - 20 nodes)
//
//
// nodes of brick
var p_a_nodes []int32 = []int32{1, 3, 5, 7, 13, 15, 17, 19}

// p_b_nodes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:32
var p_b_nodes []int32 = []int32{2, 6, 14, 18}

// p_c_nodes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:33
var p_c_nodes []int32 = []int32{4, 8, 16, 20}

// p_d_nodes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:34
var p_d_nodes []int32 = []int32{9, 10, 11, 12}

// e008_fill_coords - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:37
func e008_fill_coords(coord []tMatrix) {
	// prepares coordinates of points
	femMatPutAdd(coord, 1, 1, -1, 0)
	femMatPutAdd(coord, 1, 2, -1, 0)
	femMatPutAdd(coord, 1, 3, -1, 0)
	femMatPutAdd(coord, 2, 1, 0, 0)
	femMatPutAdd(coord, 2, 2, -1, 0)
	femMatPutAdd(coord, 2, 3, -1, 0)
	femMatPutAdd(coord, 3, 1, 1, 0)
	femMatPutAdd(coord, 3, 2, -1, 0)
	femMatPutAdd(coord, 3, 3, -1, 0)
	femMatPutAdd(coord, 4, 1, 1, 0)
	femMatPutAdd(coord, 4, 2, 0, 0)
	femMatPutAdd(coord, 4, 3, -1, 0)
	femMatPutAdd(coord, 5, 1, 1, 0)
	femMatPutAdd(coord, 5, 2, 1, 0)
	femMatPutAdd(coord, 5, 3, -1, 0)
	femMatPutAdd(coord, 6, 1, 0, 0)
	femMatPutAdd(coord, 6, 2, 1, 0)
	femMatPutAdd(coord, 6, 3, -1, 0)
	femMatPutAdd(coord, 7, 1, -1, 0)
	femMatPutAdd(coord, 7, 2, 1, 0)
	femMatPutAdd(coord, 7, 3, -1, 0)
	femMatPutAdd(coord, 8, 1, -1, 0)
	femMatPutAdd(coord, 8, 2, 0, 0)
	femMatPutAdd(coord, 8, 3, -1, 0)
	femMatPutAdd(coord, 9, 1, -1, 0)
	femMatPutAdd(coord, 9, 2, -1, 0)
	femMatPutAdd(coord, 9, 3, 0, 0)
	femMatPutAdd(coord, 10, 1, 1, 0)
	femMatPutAdd(coord, 10, 2, -1, 0)
	femMatPutAdd(coord, 10, 3, 0, 0)
	femMatPutAdd(coord, 11, 1, 1, 0)
	femMatPutAdd(coord, 11, 2, 1, 0)
	femMatPutAdd(coord, 11, 3, 0, 0)
	femMatPutAdd(coord, 12, 1, -1, 0)
	femMatPutAdd(coord, 12, 2, 1, 0)
	femMatPutAdd(coord, 12, 3, 0, 0)
	femMatPutAdd(coord, 13, 1, -1, 0)
	femMatPutAdd(coord, 13, 2, -1, 0)
	femMatPutAdd(coord, 13, 3, 1, 0)
	femMatPutAdd(coord, 14, 1, 0, 0)
	femMatPutAdd(coord, 14, 2, -1, 0)
	femMatPutAdd(coord, 14, 3, 1, 0)
	femMatPutAdd(coord, 15, 1, 1, 0)
	femMatPutAdd(coord, 15, 2, -1, 0)
	femMatPutAdd(coord, 15, 3, 1, 0)
	femMatPutAdd(coord, 16, 1, 1, 0)
	femMatPutAdd(coord, 16, 2, 0, 0)
	femMatPutAdd(coord, 16, 3, 1, 0)
	femMatPutAdd(coord, 17, 1, 1, 0)
	femMatPutAdd(coord, 17, 2, 1, 0)
	femMatPutAdd(coord, 17, 3, 1, 0)
	femMatPutAdd(coord, 18, 1, 0, 0)
	femMatPutAdd(coord, 18, 2, 1, 0)
	femMatPutAdd(coord, 18, 3, 1, 0)
	femMatPutAdd(coord, 19, 1, -1, 0)
	femMatPutAdd(coord, 19, 2, 1, 0)
	femMatPutAdd(coord, 19, 3, 1, 0)
	femMatPutAdd(coord, 20, 1, -1, 0)
	femMatPutAdd(coord, 20, 2, 0, 0)
	femMatPutAdd(coord, 20, 3, 1, 0)
}

// e008_jac_det - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:125
func e008_jac_det(jac []tMatrix, detj []float64) (c4goDefaultReturn int32) {
	// determinant of Jacobi matrix
	// * @param jac Jacobi matrix
	// * @param detj determinant (result)
	// * @return status
	//
	detj[0] = femMatGet(jac, 1, 1)*femMatGet(jac, 2, 2)*femMatGet(jac, 3, 3) + femMatGet(jac, 2, 1)*femMatGet(jac, 3, 2)*femMatGet(jac, 1, 3) + femMatGet(jac, 1, 2)*femMatGet(jac, 2, 3)*femMatGet(jac, 3, 1) + -femMatGet(jac, 3, 1)*femMatGet(jac, 2, 2)*femMatGet(jac, 1, 3) - femMatGet(jac, 1, 1)*femMatGet(jac, 2, 3)*femMatGet(jac, 3, 2) - femMatGet(jac, 3, 3)*femMatGet(jac, 2, 1)*femMatGet(jac, 1, 2)
	if detj[0] <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid element found\x00"))
		detj[0] = 0
		return -3
	} else {
		return 0
	}
	return
}

// e008_p_a - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:155
func e008_p_a(coord []tMatrix, deriv int32, point int32, x float64, y float64, z float64) (c4goDefaultReturn float64) {
	// note: deriv = 0 => no derivation (value of function)!
	// *       deriv = 1 => d/dx
	// *       deriv = 2 => d/dy
	// *       deriv = 3 => d/dz
	//
	var xv float64
	var yv float64
	var zv float64
	xv = femMatGet(coord, point, 1)
	yv = femMatGet(coord, point, 2)
	zv = femMatGet(coord, point, 3)
	switch deriv {
	case 0:
		return 0.125 * (1 + xv*x) * (1 + yv*y) * (1 + zv*z) * (xv*x + yv*y + zv*z - 2)
	case 1:
		// d/dx)
		return 0.125 * (1 + yv*y) * (1 + zv*z) * (xv + 2*xv*xv*x + xv*yv*y + xv*zv*z - 2*xv)
	case 2:
		// d/dy)
		return 0.125 * (1 + xv*x) * (1 + zv*z) * (yv + 2*yv*yv*y + yv*xv*x + yv*zv*z - 2*yv)
	case 3:
		// d/dz)
		return 0.125 * (1 + xv*x) * (1 + yv*y) * (zv + 2*zv*zv*z + zv*xv*x + zv*yv*y - 2*zv)
	default:
		return 0
	}
	return
}

// e008_p_b - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:197
func e008_p_b(coord []tMatrix, deriv int32, point int32, x float64, y float64, z float64) (c4goDefaultReturn float64) {
	var xv float64
	var yv float64
	var zv float64
	xv = femMatGet(coord, point, 1)
	yv = femMatGet(coord, point, 2)
	zv = femMatGet(coord, point, 3)
	switch deriv {
	case 0:
		return 0.25 * (1 - x*x) * (1 + yv*y) * (1 + zv*z)
	case 1:
		// d/dx
		return -0.5 * x * (1 + yv*y) * (1 + zv*z)
	case 2:
		// d/dy
		return 0.25 * yv * (1 - x*x) * (1 + zv*z)
	case 3:
		// d/dy
		return 0.25 * zv * (1 - x*x) * (1 + yv*y)
	default:
		return 0
	}
	return
}

// e008_p_c - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:224
func e008_p_c(coord []tMatrix, deriv int32, point int32, x float64, y float64, z float64) (c4goDefaultReturn float64) {
	var xv float64
	var yv float64
	var zv float64
	xv = femMatGet(coord, point, 1)
	yv = femMatGet(coord, point, 2)
	zv = femMatGet(coord, point, 3)
	switch deriv {
	case 0:
		return 0.25 * (1 + xv*x) * (1 - y*y) * (1 + zv*z)
	case 1:
		// d/dx
		return 0.25 * xv * (1 - y*y) * (1 + zv*z)
	case 2:
		// d/dy
		return -0.5 * y * (1 + xv*x) * (1 + zv*z)
	case 3:
		// d/dy
		return 0.25 * zv * (1 + xv*x) * (1 - y*y)
	default:
		return 0
	}
	return
}

// e008_p_d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:250
func e008_p_d(coord []tMatrix, deriv int32, point int32, x float64, y float64, z float64) (c4goDefaultReturn float64) {
	var xv float64
	var yv float64
	var zv float64
	xv = femMatGet(coord, point, 1)
	yv = femMatGet(coord, point, 2)
	zv = femMatGet(coord, point, 3)
	switch deriv {
	case 0:
		return 0.25 * (1 + xv*x) * (1 + yv*y) * (1 - z*z)
	case 1:
		// d/dx
		return 0.25 * xv * (1 + yv*y) * (1 - z*z)
	case 2:
		// d/dy
		return 0.25 * yv * (1 + xv*x) * (1 - z*z)
	case 3:
		// d/dy
		return -0.5 * z * (1 + xv*x) * (1 + yv*y)
	default:
		return 0
	}
	return
}

// e008_deriv_p - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:286
func e008_deriv_p(coord []tMatrix, deriv int32, dir int32, x float64, y float64, z float64, xyz []tMatrix) float64 {
	// Computes coordinates od d(p)/d(something)
	// * @param coord matrix of -1,0,1 brick coordinates
	// * @param deriv derivation type (0=none,1=d/dx,2=d/dy,3=d/dz)
	// * @param dir coordinate type (1=x,2=y,3=z)
	// * @param x x of [-1,1]
	// * @param y y of [-1,1]
	// * @param z z of [-1,1]
	// * @param xyz matrix of real brick coordinates (NULL if  you want only the derivatives)
	// * @return coordinate/derivative value
	// *
	var val float64
	var val_i float64
	var i int32
	val = 0
	for i = 0; i < 8; i++ {
		val_i = e008_p_a(coord, deriv, p_a_nodes[i], x, y, z)
		if len(xyz) != 0 {
			val_i *= femMatGet(xyz, p_a_nodes[i], dir)
		}
		val += val_i
	}
	for i = 0; i < 4; i++ {
		val_i = e008_p_b(coord, deriv, p_b_nodes[i], x, y, z)
		if len(xyz) != 0 {
			val_i *= femMatGet(xyz, p_b_nodes[i], dir)
		}
		val += val_i
	}
	for i = 0; i < 4; i++ {
		val_i = e008_p_c(coord, deriv, p_c_nodes[i], x, y, z)
		if len(xyz) != 0 {
			val_i *= femMatGet(xyz, p_c_nodes[i], dir)
		}
		val += val_i
	}
	for i = 0; i < 4; i++ {
		val_i = e008_p_d(coord, deriv, p_d_nodes[i], x, y, z)
		if len(xyz) != 0 {
			val_i *= femMatGet(xyz, p_d_nodes[i], dir)
		}
		val += val_i
	}
	return val
}

// e008_deriv_p_one - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:332
func e008_deriv_p_one(coord []tMatrix, deriv int32, number int32, x float64, y float64, z float64) float64 {
	// Computes coordinates of d(p)/d(something) of ONE P_x
	// * @param coord matrix of -1,0,1 brick coordinates
	// * @param deriv derivation type (0=none,1=d/dx,2=d/dy,3=d/dz)
	// * @param number number of node (1..20)
	// * @return coordinate/derivative value
	// *
	var val float64
	var i int32
	val = 0
	for i = 0; i < 8; i++ {
		if number == p_a_nodes[i] {
			return e008_p_a(coord, deriv, p_a_nodes[i], x, y, z)
		}
	}
	for i = 0; i < 4; i++ {
		if number == p_b_nodes[i] {
			return e008_p_b(coord, deriv, p_b_nodes[i], x, y, z)
		}
	}
	for i = 0; i < 4; i++ {
		if number == p_c_nodes[i] {
			return e008_p_c(coord, deriv, p_c_nodes[i], x, y, z)
		}
	}
	for i = 0; i < 4; i++ {
		if number == p_d_nodes[i] {
			return e008_p_d(coord, deriv, p_d_nodes[i], x, y, z)
		}
	}
	return val
}

// e008_fill_J - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:374
func e008_fill_J(jac []tMatrix, coord []tMatrix, x float64, y float64, z float64, xyz []tMatrix) int32 {
	var i int32
	var j int32
	femMatSetZero(jac)
	for i = 1; i <= 3; i++ {
		for j = 1; j <= 3; j++ {
			femMatPutAdd(jac, i, j, e008_deriv_p(coord, i, j, x, y, z, xyz), 1)
		}
	}
	return 0
}

// e008_fill_H - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:392
func e008_fill_H(H []tMatrix, ijac []tMatrix, coord []tMatrix, x float64, y float64, z float64) int32 {
	var h11 float64
	var h22 float64
	var h33 float64
	var pos int32
	var i int32
	var j int32
	h11 = 0
	h22 = 0
	h33 = 0
	femMatSetZero(H)
	for i = 0; i < 20; i++ {
		h11 = 0
		h22 = 0
		h33 = 0
		for j = 1; j <= 3; j++ {
			h11 += femMatGet(ijac, 1, j) * e008_deriv_p_one(coord, j, i+1, x, y, z)
			h22 += femMatGet(ijac, 2, j) * e008_deriv_p_one(coord, j, i+1, x, y, z)
			h33 += femMatGet(ijac, 3, j) * e008_deriv_p_one(coord, j, i+1, x, y, z)
		}
		pos = 3 * i
		femMatPutAdd(H, 1, 1+pos, h11, 0)
		femMatPutAdd(H, 2, 2+pos, h22, 0)
		femMatPutAdd(H, 3, 3+pos, h33, 0)
		femMatPutAdd(H, 6, 1+pos, h22, 0)
		femMatPutAdd(H, 6, 2+pos, h11, 0)
		femMatPutAdd(H, 4, 2+pos, h33, 0)
		femMatPutAdd(H, 4, 3+pos, h22, 0)
		femMatPutAdd(H, 5, 1+pos, h33, 0)
		femMatPutAdd(H, 5, 3+pos, h11, 0)
	}
	return 0
}

// e008_fill_N - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:447
func e008_fill_N(H []tMatrix, coord []tMatrix, x float64, y float64, z float64) int32 {
	var h11 float64
	var h22 float64
	var h33 float64
	var pos int32
	var i int32
	femMatSetZero(H)
	for i = 0; i < 20; i++ {
		h11 = e008_deriv_p_one(coord, 0, i+1, x, y, z)
		h22 = e008_deriv_p_one(coord, 0, i+1, x, y, z)
		h33 = e008_deriv_p_one(coord, 0, i+1, x, y, z)
		pos = 3 * i
		femMatPutAdd(H, 1, 1+pos, h11, 0)
		femMatPutAdd(H, 2, 2+pos, h22, 0)
		femMatPutAdd(H, 3, 3+pos, h33, 0)
	}
	return 0
}

// e008_init_gauss - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:470
func e008_init_gauss(ipoints int32, gauss []tMatrix) int32 {
	switch ipoints {
	case 2:
		femMatPutAdd(gauss, 1, 1, -0.577350269189626, 0)
		femMatPutAdd(gauss, 1, 2, 1, 0)
		femMatPutAdd(gauss, 2, 1, 0.577350269189626, 0)
		femMatPutAdd(gauss, 2, 2, 1, 0)
	case 3:
		femMatPutAdd(gauss, 1, 1, -0.774596669241483, 0)
		femMatPutAdd(gauss, 1, 2, 0.555555555555556, 0)
		femMatPutAdd(gauss, 2, 1, 0, 0)
		femMatPutAdd(gauss, 2, 2, 0.888888888888889, 0)
		femMatPutAdd(gauss, 3, 1, 0.774596669241483, 0)
		femMatPutAdd(gauss, 3, 2, 0.555555555555556, 0)
	case 4:
		femMatPutAdd(gauss, 1, 1, -0.861136311594053, 0)
		femMatPutAdd(gauss, 1, 2, 0.347854845137454, 0)
		femMatPutAdd(gauss, 2, 1, -0.339981043584856, 0)
		femMatPutAdd(gauss, 2, 2, 0.652145154862546, 0)
		femMatPutAdd(gauss, 3, 1, 0.339981043584856, 0)
		femMatPutAdd(gauss, 3, 2, 0.652145154862546, 0)
		femMatPutAdd(gauss, 4, 1, 0.861136311594053, 0)
		femMatPutAdd(gauss, 4, 2, 0.347854845137454, 0)
	default:
		noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Invalid number of integration points\x00"), ipoints)
		return -3
		break
	}
	return 0
}

// e008_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:518
func e008_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var coord tMatrix
	var xyz tMatrix
	var jac tMatrix
	var H tMatrix
	var HT tMatrix
	var D tMatrix
	var D_r tMatrix
	var HTD tMatrix
	var K_i tMatrix
	var gauss tMatrix
	var epsilon tVector
	var sigma tVector
	var sigma_0 tVector
	var epsilon_0 tVector
	var d_sigma tVector
	var u_e tVector
	var F_0 tVector
	var detj float64
	var ipoints int32 = 3
	var x float64
	var y float64
	var z float64
	var weight_x float64
	var weight_y float64
	var weight_z float64
	var mult float64 = 1
	var ipos int32
	var eT int32
	var mT int32
	var i int32
	var j int32
	var k int32
	var ii int32
	var jj int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 20, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 20, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 6, 60, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 60, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:], 0, 60, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:], 0, 60, 60, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if Mode == 1 {
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 60, 60)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 60, 60)
			return rv
		}()) != 0 {
			goto memFree
		}
		femVecSetZero(F_e)
		if len(Fr_e) != 0 {
			femVecSetZero(Fr_e)
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], 0, 6, 6, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
		// displacements:
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e008_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e008_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= 20; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 3, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_z, nLen), 0)
		}
	}
	femMatSetZero(K_e)
	// numerical integration:
	ipos = -1
	{
		// -----------------------
		for i = 1; i <= ipoints; i++ {
			for j = 1; j <= ipoints; j++ {
				for k = 1; k <= ipoints; k++ {
					ipos++
					// int. point coordinates:
					x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
					y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
					z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 1)
					weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
					weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
					weight_z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 2)
					// jacobi matrix:
					e008_fill_J((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z, (*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
					if (func() int32 {
						rv = e008_jac_det((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], c4goUnsafeConvert_float64(&detj))
						return rv
					}()) != 0 {
						// determinant
						goto memFree
					}
					// integration multiplier
					mult = detj * weight_x * weight_y * weight_z
					if femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:]) != 0 {
						// inversion - "jac" will be a inverse matrix
						noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inversion of Jascobi matric failed\x00"))
						goto memFree
					}
					if (func() int32 {
						rv = e008_fill_H((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z)
						return rv
					}()) != 0 {
						goto memFree
					}
					femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
					if Mode == 1 {
						femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
						if (func() int32 {
							rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, (*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
							return rv
						}()) != 0 {
							goto memFree
						}
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
						if femTangentMatrix == 1 {
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, femGetRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 2, femGetRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 3, femGetRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 4, femGetRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 5, femGetRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 6, femGetRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 1, femGetRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 2, femGetRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 3, femGetRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 4, femGetRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 5, femGetRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 6, femGetRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							for ii = 1; ii <= 6; ii++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], ii), 0)
							}
							if (func() int32 {
								rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 0, (*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
								return rv
							}()) != 0 {
								goto memFree
							}
							femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
							femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
							for ii = 1; ii <= 6; ii++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii), 0)
							}
							if (func() int32 {
								rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
								return rv
							}()) != 0 {
								goto memFree
							}
							femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							for ii = 1; ii <= 6; ii++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii), 0)
							}
							femAddPutRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
							femAddPutRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
							femAddPutRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
							femAddPutRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
							femAddPutRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5))
							femAddPutRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
							femAddPutRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
							femAddPutRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
							femAddPutRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
							femAddPutRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
							femAddPutRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
							femAddPutRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 6))
						} else {
							if (func() int32 {
								rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
								return rv
							}()) != 0 {
								// secant matrix - untested!
								goto memFree
							}
							femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							for ii = 1; ii <= 6; ii++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii), 0)
							}
							femAddPutRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
							femAddPutRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
							femAddPutRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
							femAddPutRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
							femAddPutRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5))
							femAddPutRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
							femAddPutRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
							femAddPutRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
							femAddPutRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
							femAddPutRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
							femAddPutRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
							femAddPutRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 6))
						}
						femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						for ii = 1; ii <= 60; ii++ {
							femVecPutAdd(F_e, ii, mult*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], ii), 1)
						}
						femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						for ii = 1; ii <= 60; ii++ {
							femVecPutAdd(Fr_e, ii, mult*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], ii), 1)
						}
					} else {
						if (func() int32 {
							rv = fem_D_3D(ePos, ipos+1, eT, mT, nil, nil, 0, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
							return rv
						}()) != 0 {
							// "D" computation should be usefull here ;-)
							goto memFree
						}
					}
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
					// 60,6 x 6,6 = 60,6
					femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
					// 60,6 z 6,60  = 60,60
					femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
					for ii = 1; ii <= 60; ii++ {
						for jj = 1; jj <= 60; jj++ {
							femMatPutAdd(K_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:], ii, jj), 1)
						}
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if Mode == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
	}
	//femMatPrn(K_e,"K_e");
	return rv
}

// e008_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:829
func e008_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var ro float64
	var coord tMatrix
	var xyz tMatrix
	var jac tMatrix
	var H tMatrix
	var HT tMatrix
	var M_i tMatrix
	var gauss tMatrix
	var detj float64
	var ipoints int32 = 3
	var x float64
	var y float64
	var z float64
	var weight_x float64
	var weight_y float64
	var weight_z float64
	var mult float64 = 1
	var ipos int32
	var eT int32
	var mT int32
	var i int32
	var j int32
	var k int32
	var ii int32
	var jj int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	ro = femGetMPValPos(ePos, 1, 0)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 20, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 20, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 3, 60, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 60, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], 0, 60, 60, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e008_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e008_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= 20; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 3, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_z, nLen), 0)
		}
	}
	femMatSetZero(M_e)
	// numerical integration:
	ipos = -1
	{
		// -----------------------
		for i = 1; i <= ipoints; i++ {
			for j = 1; j <= ipoints; j++ {
				for k = 1; k <= ipoints; k++ {
					ipos++
					// int. point coordinates:
					x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
					y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
					z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 1)
					weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
					weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
					weight_z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 2)
					// jacobi matrix:
					e008_fill_J((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z, (*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
					if (func() int32 {
						rv = e008_jac_det((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], c4goUnsafeConvert_float64(&detj))
						return rv
					}()) != 0 {
						// determinant
						goto memFree
					}
					if (func() int32 {
						rv = e008_fill_N((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z)
						return rv
					}()) != 0 {
						goto memFree
					}
					femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
					// 60,6 x 6,60 = 60,60
					femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
					mult = ro * detj * weight_x * weight_y * weight_z
					for ii = 1; ii <= 60; ii++ {
						for jj = 1; jj <= 60; jj++ {
							femMatPutAdd(M_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], ii, jj), 1)
						}
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	return rv
}

// e008_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:959
func e008_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var ro float64
	var M_i tMatrix
	var F_0 tVector
	var F_1 tVector
	var i int32
	ro = femGetMPValPos(ePos, 1, 0)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], 0, 60, 60, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 60, 60)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 0, 60, 60)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 0; i < 20; i++ {
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1+3*i, 1, 0)
	}
	e008_mass(ePos, (*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	vol[0] = 0
	for i = 0; i < 20; i++ {
		vol[0] += femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 1+3*i)
	}
	vol[0] = vol[0] / ro
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	return rv
}

// e008_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:994
func e008_rvals(ePos int32) int32 {
	return 14 * 27
}

// e008_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:999
func e008_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e008_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:1005
func e008_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var rv int32
	var coord tMatrix
	var xyz tMatrix
	var gauss tMatrix
	var ipoints int32 = 3
	var xn float64
	var yn float64
	var zn float64
	var ipos int32
	var eT int32
	var i int32
	var j int32
	var k int32
	var kk int32
	var nodes int32
	eT = femGetIntPos(ePos, eType, eLen)
	nodes = Elem[eT].nodes
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, nodes, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, nodes, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e008_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e008_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= nodes; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 3, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_z, nLen), 0)
		}
	}
	x[0] = 0
	y[0] = 0
	z[0] = 0
	ipos = -1
	for i = 1; i <= ipoints; i++ {
		for j = 1; j <= ipoints; j++ {
			for k = 1; k <= ipoints; k++ {
				ipos++
				if ipos < point {
					continue
				}
				if ipos > point {
					break
				}
				// int. point coordinates:
				xn = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
				yn = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
				zn = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 1)
				{
					// number of nodes...
					for kk = 1; kk <= 20; kk++ {
						x[0] += femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], kk, 1) * e008_deriv_p_one((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, kk, xn, yn, zn)
						y[0] += femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], kk, 2) * e008_deriv_p_one((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, kk, xn, yn, zn)
						z[0] += femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], kk, 3) * e008_deriv_p_one((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, kk, xn, yn, zn)
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	return rv
}

// addElem_008 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e008.c:1088
func addElem_008() int32 {
	var rv int32
	var type_ int32 = 8
	var dim int32 = 3
	var nodes int32 = 20
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 3}
	var rs int32
	var real_ []int32
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 14
	var nres_rp []int32 = []int32{7, 8, 9, 11, 12, 10, 13, 14, 15, 17, 18, 16, 37, 38}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e008_stiff
	Elem[type_].mass = e008_mass
	Elem[type_].rvals = e008_rvals
	Elem[type_].eload = e008_eload
	Elem[type_].res_p_loc = e008_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e008_volume
	Elem[type_].therm = e000_therm
	return rv
}

// p_nodes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:33
//
//   File name: fem_e009.c
//   Date:      Thu Mar 18 19:13:39 CET 2004
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2004 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - Element 009 (structural brick - 8 nodes)
//
// nodes of brick
var p_nodes []int32 = []int32{1, 2, 3, 4, 5, 6, 7, 8}

// e009_fill_coords - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:36
func e009_fill_coords(coord []tMatrix) {
	// prepares coordinates of points
	femMatPutAdd(coord, 1, 1, -1, 0)
	femMatPutAdd(coord, 1, 2, -1, 0)
	femMatPutAdd(coord, 1, 3, -1, 0)
	femMatPutAdd(coord, 2, 1, 1, 0)
	femMatPutAdd(coord, 2, 2, -1, 0)
	femMatPutAdd(coord, 2, 3, -1, 0)
	femMatPutAdd(coord, 3, 1, 1, 0)
	femMatPutAdd(coord, 3, 2, 1, 0)
	femMatPutAdd(coord, 3, 3, -1, 0)
	femMatPutAdd(coord, 4, 1, -1, 0)
	femMatPutAdd(coord, 4, 2, 1, 0)
	femMatPutAdd(coord, 4, 3, -1, 0)
	femMatPutAdd(coord, 5, 1, -1, 0)
	femMatPutAdd(coord, 5, 2, -1, 0)
	femMatPutAdd(coord, 5, 3, 1, 0)
	femMatPutAdd(coord, 6, 1, 1, 0)
	femMatPutAdd(coord, 6, 2, -1, 0)
	femMatPutAdd(coord, 6, 3, 1, 0)
	femMatPutAdd(coord, 7, 1, 1, 0)
	femMatPutAdd(coord, 7, 2, 1, 0)
	femMatPutAdd(coord, 7, 3, 1, 0)
	femMatPutAdd(coord, 8, 1, -1, 0)
	femMatPutAdd(coord, 8, 2, 1, 0)
	femMatPutAdd(coord, 8, 3, 1, 0)
}

// e009_jac_det - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:76
func e009_jac_det(jac []tMatrix, detj []float64) (c4goDefaultReturn int32) {
	// determinant of Jacobi matrix
	// * @param jac Jacobi matrix
	// * @param detj determinant (result)
	// * @return status
	//
	detj[0] = femMatGet(jac, 1, 1)*femMatGet(jac, 2, 2)*femMatGet(jac, 3, 3) + femMatGet(jac, 2, 1)*femMatGet(jac, 3, 2)*femMatGet(jac, 1, 3) + femMatGet(jac, 1, 2)*femMatGet(jac, 2, 3)*femMatGet(jac, 3, 1) + -femMatGet(jac, 3, 1)*femMatGet(jac, 2, 2)*femMatGet(jac, 1, 3) - femMatGet(jac, 1, 1)*femMatGet(jac, 2, 3)*femMatGet(jac, 3, 2) - femMatGet(jac, 3, 3)*femMatGet(jac, 2, 1)*femMatGet(jac, 1, 2)
	if detj[0] <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid element found\x00"))
		detj[0] = 0
		return -3
	} else {
		return 0
	}
	return
}

// e009_p_a - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:106
func e009_p_a(coord []tMatrix, deriv int32, point int32, x float64, y float64, z float64) (c4goDefaultReturn float64) {
	// note: deriv = 0 => no derivation (value of function)!
	// *       deriv = 1 => d/dx
	// *       deriv = 2 => d/dy
	// *       deriv = 3 => d/dz
	//
	var xv float64
	var yv float64
	var zv float64
	xv = femMatGet(coord, point, 1)
	yv = femMatGet(coord, point, 2)
	zv = femMatGet(coord, point, 3)
	switch deriv {
	case 0:
		return 0.125 * (1 + xv*x) * (1 + yv*y) * (1 + zv*z)
	case 1:
		// d/dx)
		return 0.125 * xv * (1 + yv*y) * (1 + zv*z)
	case 2:
		// d/dy)
		return 0.125 * yv * (1 + xv*x) * (1 + zv*z)
	case 3:
		// d/dz)
		return 0.125 * zv * (1 + xv*x) * (1 + yv*y)
	default:
		return 0
	}
	return
}

// e009_deriv_p - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:159
func e009_deriv_p(coord []tMatrix, deriv int32, dir int32, x float64, y float64, z float64, xyz []tMatrix) float64 {
	// Computes coordinates od d(p)/d(something)
	// * @param coord matrix of -1,0,1 brick coordinates
	// * @param deriv derivation type (0=none,1=d/dx,2=d/dy,3=d/dz)
	// * @param dir coordinate type (1=x,2=y,3=z)
	// * @param x x of [-1,1]
	// * @param y y of [-1,1]
	// * @param z z of [-1,1]
	// * @param xyz matrix of real brick coordinates (NULL if  you want only the derivatives)
	// * @return coordinate/derivative value
	// *
	var val float64
	var val_i float64
	var i int32
	val = 0
	for i = 0; i < 8; i++ {
		val_i = e009_p_a(coord, deriv, p_nodes[i], x, y, z)
		if len(xyz) != 0 {
			val_i *= femMatGet(xyz, p_nodes[i], dir)
		}
		val += val_i
	}
	return val
}

// e009_deriv_p_one - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:184
func e009_deriv_p_one(coord []tMatrix, deriv int32, number int32, x float64, y float64, z float64) float64 {
	// Computes coordinates of d(p)/d(something) of ONE P_x
	// * @param coord matrix of -1,0,1 brick coordinates
	// * @param deriv derivation type (0=none,1=d/dx,2=d/dy,3=d/dz)
	// * @param number number of node (1..20)
	// * @return coordinate/derivative value
	// *
	return e009_p_a(coord, deriv, number, x, y, z)
}

// e009_fill_J - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:189
func e009_fill_J(jac []tMatrix, coord []tMatrix, x float64, y float64, z float64, xyz []tMatrix) int32 {
	var i int32
	var j int32
	femMatSetZero(jac)
	for i = 1; i <= 3; i++ {
		for j = 1; j <= 3; j++ {
			femMatPutAdd(jac, i, j, e009_deriv_p(coord, i, j, x, y, z, xyz), 1)
		}
	}
	return 0
}

// e009_fill_H - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:207
func e009_fill_H(H []tMatrix, ijac []tMatrix, coord []tMatrix, x float64, y float64, z float64) int32 {
	var h11 float64
	var h22 float64
	var h33 float64
	var pos int32
	var i int32
	var j int32
	h11 = 0
	h22 = 0
	h33 = 0
	femMatSetZero(H)
	for i = 0; i < 8; i++ {
		h11 = 0
		h22 = 0
		h33 = 0
		for j = 1; j <= 3; j++ {
			h11 += femMatGet(ijac, 1, j) * e009_deriv_p_one(coord, j, i+1, x, y, z)
			h22 += femMatGet(ijac, 2, j) * e009_deriv_p_one(coord, j, i+1, x, y, z)
			h33 += femMatGet(ijac, 3, j) * e009_deriv_p_one(coord, j, i+1, x, y, z)
		}
		pos = 3 * i
		femMatPutAdd(H, 1, 1+pos, h11, 0)
		femMatPutAdd(H, 2, 2+pos, h22, 0)
		femMatPutAdd(H, 3, 3+pos, h33, 0)
		femMatPutAdd(H, 6, 1+pos, h22, 0)
		femMatPutAdd(H, 6, 2+pos, h11, 0)
		femMatPutAdd(H, 4, 2+pos, h33, 0)
		femMatPutAdd(H, 4, 3+pos, h22, 0)
		femMatPutAdd(H, 5, 1+pos, h33, 0)
		femMatPutAdd(H, 5, 3+pos, h11, 0)
	}
	return 0
}

// e009_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:261
func e009_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var coord tMatrix
	var xyz tMatrix
	var jac tMatrix
	var H tMatrix
	var HT tMatrix
	var D tMatrix
	var D_r tMatrix
	var HTD tMatrix
	var K_i tMatrix
	var gauss tMatrix
	var epsilon tVector
	var sigma tVector
	var d_sigma tVector
	var u_e tVector
	var F_0 tVector
	var sigma_0 tVector
	var epsilon_0 tVector
	var detj float64
	var ipoints int32 = 3
	var x float64
	var y float64
	var z float64
	var weight_x float64
	var weight_y float64
	var weight_z float64
	var mult float64 = 1
	var ipos int32
	var eT int32
	var mT int32
	var mtype int32
	var i int32
	var j int32
	var k int32
	var ii int32
	var jj int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	mtype = Mat[femGetIntPos(mT, mpType, mpLen)].type_
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 8, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 8, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 6, 24, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 24, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:], 0, 24, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:], 0, 24, 24, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if Mode == 1 {
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 24, 24)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 24, 24)
			return rv
		}()) != 0 {
			goto memFree
		}
		femVecSetZero(F_e)
		if len(Fr_e) != 0 {
			femVecSetZero(Fr_e)
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], 0, 6, 6, 0, nil)
			return rv
		}()) != 0 {
			goto memFree
		}
		// displacements:
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e008_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e009_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= 8; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 3, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_z, nLen), 0)
		}
	}
	femMatSetZero(K_e)
	// numerical integration:
	ipos = -1
	{
		// -----------------------
		for i = 1; i <= ipoints; i++ {
			for j = 1; j <= ipoints; j++ {
				for k = 1; k <= ipoints; k++ {
					ipos++
					// int. point coordinates:
					x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
					y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
					z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 1)
					weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
					weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
					weight_z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 2)
					// jacobi matrix:
					e009_fill_J((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z, (*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
					if (func() int32 {
						rv = e009_jac_det((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], c4goUnsafeConvert_float64(&detj))
						return rv
					}()) != 0 {
						// determinant
						goto memFree
					}
					if detj <= 0 {
						noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Jacobi matric determinan is negative\x00"))
						goto memFree
					}
					// integrational multiplier
					mult = detj * weight_x * weight_y * weight_z
					if femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:]) != 0 {
						// inversion - "jac" will be a inverse matrix
						noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inversion of Jacobi matric failed\x00"))
						goto memFree
					}
					if (func() int32 {
						rv = e009_fill_H((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z)
						return rv
					}()) != 0 {
						goto memFree
					}
					femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
					if Mode == 1 {
						femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
						if (func() int32 {
							rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, (*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
							return rv
						}()) != 0 {
							goto memFree
						}
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
						if femTangentMatrix == 1 {
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, femGetRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 2, femGetRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 3, femGetRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 4, femGetRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 5, femGetRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 6, femGetRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 1, femGetRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 2, femGetRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 3, femGetRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 4, femGetRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 5, femGetRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], 6, femGetRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
							if mtype == 2 || mtype == 3 {
								if (func() int32 {
									rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
									return rv
								}()) != 0 {
									// "pseudo sec"
									// start of NEW CODE ---------------------------------------
									goto memFree
								}
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								for ii = 1; ii <= 6; ii++ {
									femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], ii), 1)
									femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii), 0)
								}
								// order is important! - this must be here!
								femAddPutRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
								femAddPutRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
								femAddPutRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
								femAddPutRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
								femAddPutRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5))
								femAddPutRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
								// e_sum = e_0 + delta_e:
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1), 1)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 2, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2), 1)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 3, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3), 1)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 4, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4), 1)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 5, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5), 1)
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 6, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6), 1)
								if (func() int32 {
									rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
									return rv
								}()) != 0 {
									// sigma_0 is USELESS here!
									goto memFree
								}
								// new sigma
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								// d_sigma (residual stress) computation
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
								for ii = 1; ii <= 6; ii++ {
									femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii), 1)
								}
								// end of d_sigma computation
								femAddPutRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
								femAddPutRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
								femAddPutRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
								femAddPutRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
								femAddPutRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
								femAddPutRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 6))
								noarch.Fprintf(msgout, []byte("\nSIGMA: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
								noarch.Fprintf(msgout, []byte("\nSIGMA_R: %f %f %f\n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 3))
							} else {
								{
									// end of NEW CODE -----------------------------------------
									// mtype
									for ii = 1; ii <= 6; ii++ {
										femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], ii), 0)
									}
								}
								if (func() int32 {
									rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 0, (*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
									return rv
								}()) != 0 {
									goto memFree
								}
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
								for ii = 1; ii <= 6; ii++ {
									femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii), 0)
								}
								if (func() int32 {
									rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:], 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
									return rv
								}()) != 0 {
									goto memFree
								}
								femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
								for ii = 1; ii <= 6; ii++ {
									femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii), 0)
								}
								femAddPutRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
								femAddPutRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
								femAddPutRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
								femAddPutRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
								femAddPutRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5))
								femAddPutRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
								femAddPutRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
								femAddPutRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
								femAddPutRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
								femAddPutRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
								femAddPutRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
								femAddPutRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 6))
							}
						} else {
							if (func() int32 {
								rv = fem_D_3D(ePos, ipos+1, eT, mT, (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
								return rv
							}()) != 0 {
								//mtype
								// secant matrix - untested!
								goto memFree
							}
							femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
							for ii = 1; ii <= 6; ii++ {
								femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], ii), 0)
							}
							femAddPutRepVal(ePos, 13, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
							femAddPutRepVal(ePos, 14, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
							femAddPutRepVal(ePos, 15, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
							femAddPutRepVal(ePos, 17, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 4))
							femAddPutRepVal(ePos, 18, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 5))
							femAddPutRepVal(ePos, 16, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 6))
							femAddPutRepVal(ePos, 7, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
							femAddPutRepVal(ePos, 8, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
							femAddPutRepVal(ePos, 9, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
							femAddPutRepVal(ePos, 11, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 4))
							femAddPutRepVal(ePos, 12, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 5))
							femAddPutRepVal(ePos, 10, ipos+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 6))
						}
						femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						for ii = 1; ii <= 24; ii++ {
							femVecPutAdd(F_e, ii, mult*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], ii), 1)
						}
						femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
						for ii = 1; ii <= 24; ii++ {
							femVecPutAdd(Fr_e, ii, mult*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], ii), 1)
						}
					} else {
						if (func() int32 {
							rv = fem_D_3D(ePos, ipos+1, eT, mT, nil, nil, 0, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
							return rv
						}()) != 0 {
							// "D" computation should be usefull here ;-)
							goto memFree
						}
					}
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
					// 24,6 x 6,6 = 24,6
					femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
					// 24,6 z 6,24  = 24,24
					femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
					for ii = 1; ii <= 24; ii++ {
						for jj = 1; jj <= 24; jj++ {
							femMatPutAdd(K_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:], ii, jj), 1)
						}
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HTD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if Mode == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D_r))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_0))[:])
	}
	return rv
}

// e009_fill_N - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:637
func e009_fill_N(H []tMatrix, coord []tMatrix, x float64, y float64, z float64) int32 {
	var h11 float64
	var h22 float64
	var h33 float64
	var pos int32
	var i int32
	femMatSetZero(H)
	for i = 0; i < 8; i++ {
		h11 = e009_deriv_p_one(coord, 0, i+1, x, y, z)
		h22 = e009_deriv_p_one(coord, 0, i+1, x, y, z)
		h33 = e009_deriv_p_one(coord, 0, i+1, x, y, z)
		pos = 3 * i
		femMatPutAdd(H, 1, 1+pos, h11, 0)
		femMatPutAdd(H, 2, 2+pos, h22, 0)
		femMatPutAdd(H, 3, 3+pos, h33, 0)
	}
	return 0
}

// e009_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:660
func e009_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var ro float64
	var coord tMatrix
	var xyz tMatrix
	var jac tMatrix
	var H tMatrix
	var HT tMatrix
	var M_i tMatrix
	var gauss tMatrix
	var detj float64
	var ipoints int32 = 3
	var x float64
	var y float64
	var z float64
	var weight_x float64
	var weight_y float64
	var weight_z float64
	var mult float64 = 1
	var ipos int32
	var eT int32
	var mT int32
	var i int32
	var j int32
	var k int32
	var ii int32
	var jj int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	ro = femGetMPValPos(ePos, 1, 0)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], 0, 8, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 8, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 3, 24, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 24, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], 0, 24, 24, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e008_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		// gauss data
		goto memFree
	}
	// -1..1 coords:
	e009_fill_coords((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	{
		// real coordinates:
		for i = 1; i <= 8; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 3, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_z, nLen), 0)
		}
	}
	femMatSetZero(M_e)
	// numerical integration:
	ipos = -1
	{
		// -----------------------
		for i = 1; i <= ipoints; i++ {
			for j = 1; j <= ipoints; j++ {
				for k = 1; k <= ipoints; k++ {
					ipos++
					// int. point coordinates:
					x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
					y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
					z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 1)
					weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
					weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
					weight_z = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], k, 2)
					// jacobi matrix:
					e009_fill_J((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z, (*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
					if (func() int32 {
						rv = e009_jac_det((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:], c4goUnsafeConvert_float64(&detj))
						return rv
					}()) != 0 {
						// determinant
						goto memFree
					}
					if (func() int32 {
						rv = e009_fill_N((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&coord))[:], x, y, z)
						return rv
					}()) != 0 {
						goto memFree
					}
					femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
					femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
					// 24,6 x 6,24 = 24,24
					femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
					mult = ro * detj * weight_x * weight_y * weight_z
					for ii = 1; ii <= 24; ii++ {
						for jj = 1; jj <= 24; jj++ {
							femMatPutAdd(M_e, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], ii, jj), 1)
						}
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&coord))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&jac))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	return rv
}

// e009_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:790
func e009_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var ro float64
	var M_i tMatrix
	var F_0 tVector
	var F_1 tVector
	var i int32
	ro = femGetMPValPos(ePos, 1, 0)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], 0, 24, 24, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 24, 24)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 0, 24, 24)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 0; i < 8; i++ {
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1+3*i, 1, 0)
	}
	e009_mass(ePos, (*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], (*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	vol[0] = 0
	for i = 0; i < 8; i++ {
		vol[0] += femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_1))[:], 1+3*i)
	}
	vol[0] = vol[0] / ro
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_1))[:])
	return rv
}

// e009_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:825
func e009_rvals(ePos int32) int32 {
	return 14 * 27
}

// e009_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:830
func e009_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e009_res_node - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:835
func e009_res_node(ePos int32, nPos int32, type_ int32, val []float64) int32 {
	var inum int32
	var i int32
	switch nPos {
	case 0:
		inum = 0
	case 1:
		inum = 6
	case 2:
		inum = 24
	case 3:
		inum = 18
	case 4:
		inum = 2
	case 5:
		inum = 8
	case 6:
		inum = 26
	case 7:
		inum = 20
	default:
		return -1
	}
	for i = 0; i < Elem[9].res_rp; i++ {
		if type_ == Elem[9].nres_rp[i] {
			val[0] = femGetRepVal(ePos, type_, inum, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
			return 0
		}
	}
	return -1
}

// addElem_009 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e009.c:866
func addElem_009() int32 {
	var rv int32
	var type_ int32 = 9
	var dim int32 = 3
	var nodes int32 = 8
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 3}
	var rs int32
	var real_ []int32
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 20
	var nres_rp []int32 = []int32{7, 8, 9, 11, 12, 10, 13, 14, 15, 17, 18, 16, 73, 74, 75, 77, 78, 76, 37, 38}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e009_stiff
	Elem[type_].mass = e009_mass
	Elem[type_].rvals = e009_rvals
	Elem[type_].eload = e009_eload
	Elem[type_].res_p_loc = e008_res_p_loc
	Elem[type_].res_node = e009_res_node
	Elem[type_].volume = e009_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e010_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e010.c:41
func e010_rvals(ePos int32) int32 {
	//
	//   File name: fem_e009.c
	//   Date:      Sun May 16 14:18:29 CET 2004
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 010 (structural brick - 8 nodes)
	//   Orientation of cracks is saved inside results.
	//
	//   $Id: fem_e010.c,v 1.3 2004/12/31 00:31:06 jirka Exp $
	//
	return 26 * 27
}

// e010_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e010.c:47
func e010_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var winkler float64
	rv = e009_stiff(ePos, Mode, K_e, F_e, Fr_e)
	if Mode != 1 {
		// Winkler's foundation (only 1-2-3-4 side and it MUST BE in x-y plane!)
		winkler = femGetRSValPos(ePos, 13, 0)
		if winkler > 0 {
			e005_shape_mat(ePos, winkler, K_e, 0, 3)
		}
	}
	return rv
}

// addElem_010 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e010.c:68
func addElem_010() int32 {
	var rv int32
	var type_ int32 = 10
	var dim int32 = 3
	var nodes int32 = 8
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 3}
	var rs int32 = 1
	var real_ []int32 = []int32{13}
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 32
	var nres_rp []int32 = []int32{7, 8, 9, 11, 12, 10, 13, 14, 15, 17, 18, 16, 73, 74, 75, 77, 78, 76, 37, 38, 28, 29, 31, 39, 40, 41, 42, 43, 44, 45, 46, 47}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e010_stiff
	Elem[type_].mass = e009_mass
	Elem[type_].rvals = e010_rvals
	Elem[type_].eload = e009_eload
	Elem[type_].res_p_loc = e008_res_p_loc
	Elem[type_].res_node = e009_res_node
	Elem[type_].volume = e009_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e01_compute_B - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:35
func e01_compute_B(x []float64, y []float64, A float64, B []tMatrix) int32 {
	//
	//   File name: fem_e011.c
	//   Date:      2004/10/22 23:40
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - element 011 constant strain/ plane element
	//               linear solution ONLY
	//  $Id: fem_e011.c,v 1.2 2005/07/11 17:56:16 jirka Exp $
	//
	// from fem_ccr2.c
	femMatSetZero(B)
	femMatPutAdd(B, 1, 1, y[2]-y[3], 0)
	femMatPutAdd(B, 1, 3, y[3]-y[1], 0)
	femMatPutAdd(B, 1, 5, y[1]-y[2], 0)
	femMatPutAdd(B, 2, 2, x[3]-x[2], 0)
	femMatPutAdd(B, 2, 4, x[1]-x[3], 0)
	femMatPutAdd(B, 2, 6, x[2]-x[1], 0)
	femMatPutAdd(B, 3, 1, x[3]-x[2], 0)
	femMatPutAdd(B, 3, 2, y[2]-y[3], 0)
	femMatPutAdd(B, 3, 3, x[1]-x[3], 0)
	femMatPutAdd(B, 3, 4, y[3]-y[1], 0)
	femMatPutAdd(B, 3, 5, x[2]-x[1], 0)
	femMatPutAdd(B, 3, 6, y[1]-y[2], 0)
	femValMatMultSelf(1/(2*A), B)
	return 0
}

// e011_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:59
func e011_stiff(ePos int32, Mode int32, K_e []tMatrix, Fe []tVector, Fre []tVector) int32 {
	var rv int32
	// plane stress ;-)
	var ProblemType int32
	var thick float64
	var A float64
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	var i int32
	//[3][6]
	var B tMatrix
	//[6][3]
	var Bt tMatrix
	//[3][3]
	var D tMatrix
	//[6][3]
	var BtD tMatrix
	//[6]
	var u_e tVector
	//[6]
	var epsilon tVector
	//[6]
	var sigma tVector
	//[6]
	var sigma_1 tVector
	var phi float64
	switch eType[ePos] {
	case 11:
		// sets problem type for "D" computation:
		// plane stress
		ProblemType = 0
	default:
		// plane stress
		ProblemType = 0
		break
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 3, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 6, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], 0, 6, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	thick = femGetRSValPos(ePos, 3, 0)
	if thick <= 0 {
		// plane strain
		ProblemType = 1
	}
	for i = 1; i <= 3; i++ {
		x[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	A = 0.5 * (x[1]*y[2] - x[2]*y[1] + x[2]*y[3] - x[3]*y[2] + x[3]*y[1] - x[1]*y[3])
	e01_compute_B(x, y, A, (*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	if (func() int32 {
		rv = D_PlaneHookIso(ePos, 0, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	// stiffness matrix is computed
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&B))[:], K_e)
	femValMatMultSelf(thick*A, K_e)
	if Mode == 1 {
		// results are computed
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
			femAddPutRepVal(ePos, 8, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
			femAddPutRepVal(ePos, 10, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
			femAddPutRepVal(ePos, 14, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
			femAddPutRepVal(ePos, 16, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
		} else {
			femAddPutRepVal(ePos, 7, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 1))
			femAddPutRepVal(ePos, 8, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 2))
			femAddPutRepVal(ePos, 10, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 3))
			femAddPutRepVal(ePos, 13, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1))
			femAddPutRepVal(ePos, 14, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2))
			femAddPutRepVal(ePos, 16, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3))
		}
		if Mat[femGetIntPos(femGetIntPos(ePos, eMP, eLen), mpType, mpLen)].type_ == 2 {
			// for material 2 compute CEB-FIP
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 0, 3, 3)
				return rv
			}()) == 0 {
				femGetPrincStress2D((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], c4goUnsafeConvert_float64(&phi))
				femAddPutRepVal(ePos, 63, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femCEB_FIP_Test(femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2), femGetMPValPos(ePos, 8, 0), femGetMPValPos(ePos, 7, 0)))
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
			}
		}
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], Fe)
		femVecSetZero(Fre)
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	return rv
}

// e011_therm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:192
func e011_therm(ePos int32, use []int32, Te []tVector, Fe []tVector) int32 {
	// Computes temperature load for element 011
	var rv int32
	//  0 = plane stress
	var ProblemType int32
	var thick float64
	var temp float64
	// thermal expansion coeff.
	var alpha float64
	var A float64
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	var i int32
	//[3][6]
	var B tMatrix
	//[6][3]
	var Bt tMatrix
	//[3][3]
	var D tMatrix
	//[6][3]
	var BtD tMatrix
	//[6]
	var epsilon tVector
	use[0] = 1
	switch eType[ePos] {
	case 11:
		// sets problem type for "D" computation:
		// plane stress
		ProblemType = 0
	default:
		// plane stress
		ProblemType = 0
		break
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 3, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 6, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], 0, 6, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	thick = femGetRSValPos(ePos, 3, 0)
	alpha = femGetMPValPos(ePos, 38, 0)
	if thick <= 0 {
		// plane strain
		ProblemType = 1
	}
	for i = 1; i <= 3; i++ {
		x[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	A = 0.5 * (x[1]*y[2] - x[2]*y[1] + x[2]*y[3] - x[3]*y[2] + x[3]*y[1] - x[1]*y[3])
	e01_compute_B(x, y, A, (*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	if (func() int32 {
		rv = D_PlaneHookIso(ePos, 0, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, ProblemType, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if thick <= 0 {
		// set temperature strains:
		thick = 1
	}
	temp = (femVecGet(Te, 1) + femVecGet(Te, 2) + femVecGet(Te, 3)) / 3
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1, alpha*temp, 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2, alpha*temp, 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3, 0, 0)
	// stiffness matrix is computed
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], Fe)
	femValVecMultSelf(thick*A, Fe)
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	return rv
}

// e011_area - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:275
func e011_area(ePos int32) float64 {
	// It should work - according to Zienkiewicz ;-)
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	var i int32
	for i = 1; i <= 3; i++ {
		x[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	return 0.5 * (x[1]*y[2] - x[2]*y[1] + x[2]*y[3] - x[3]*y[2] + x[3]*y[1] - x[1]*y[3])
}

// e011_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:291
func e011_mass(ePos int32, M_e []tMatrix) int32 {
	// It should work - according to Zienkiewicz ;-)
	var rv int32
	var t float64
	var ro float64
	var A float64
	var mult float64
	femMatSetZero(M_e)
	// Geometry (width, area) and material (density) data:
	t = femGetRSValPos(ePos, 3, 0)
	ro = femGetMPValPos(ePos, 1, 0)
	A = e011_area(ePos)
	// Multiplier:
	mult = ro * t * A / 3
	femMatPutAdd(M_e, 1, 1, mult*0.5, 0)
	femMatPutAdd(M_e, 1, 3, mult*0.25, 0)
	femMatPutAdd(M_e, 1, 5, mult*0.25, 0)
	femMatPutAdd(M_e, 2, 2, mult*0.5, 0)
	femMatPutAdd(M_e, 2, 4, mult*0.25, 0)
	femMatPutAdd(M_e, 2, 6, mult*0.25, 0)
	femMatPutAdd(M_e, 3, 1, mult*0.25, 0)
	femMatPutAdd(M_e, 3, 3, mult*0.5, 0)
	femMatPutAdd(M_e, 3, 5, mult*0.25, 0)
	femMatPutAdd(M_e, 4, 2, mult*0.25, 0)
	femMatPutAdd(M_e, 4, 4, mult*0.5, 0)
	femMatPutAdd(M_e, 4, 6, mult*0.25, 0)
	femMatPutAdd(M_e, 5, 1, mult*0.25, 0)
	femMatPutAdd(M_e, 5, 3, mult*0.25, 0)
	femMatPutAdd(M_e, 5, 5, mult*0.5, 0)
	femMatPutAdd(M_e, 6, 2, mult*0.25, 0)
	femMatPutAdd(M_e, 6, 4, mult*0.25, 0)
	femMatPutAdd(M_e, 6, 6, mult*0.5, 0)
	return rv
}

// e011_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:334
func e011_volume(ePos int32, vol []float64) int32 {
	var rv int32
	var t float64
	var A float64
	t = femGetRSValPos(ePos, 3, 0)
	A = e011_area(ePos)
	vol[0] = t * A
	return rv
}

// e011_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:347
func e011_rvals(ePos int32) int32 {
	return 7
}

// e011_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:352
func e011_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e011_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:358
func e011_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var i int32
	x[0] = 0
	y[0] = 0
	z[0] = 0
	for i = 3; i < 4; i++ {
		x[0] += femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] += femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	x[0] = x[0] / 3
	y[0] = y[0] / 3
	return 0
}

// addElem_011 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e011.c:378
func addElem_011() int32 {
	var rv int32
	var type_ int32 = 11
	var dim int32 = 2
	var nodes int32 = 3
	var dofs int32 = 2
	var ndof []int32 = []int32{1, 2}
	var rs int32 = 1
	var real_ []int32 = []int32{3}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 7
	var nres []int32 = []int32{7, 8, 10, 13, 14, 16, 63}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e011_stiff
	Elem[type_].mass = e011_mass
	Elem[type_].rvals = e011_rvals
	Elem[type_].eload = e011_eload
	Elem[type_].res_p_loc = e011_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e011_volume
	Elem[type_].therm = e011_therm
	return rv
}

// e012_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e012.c:36
func e012_rvals(ePos int32) int32 {
	//
	//   File name: fem_e008.c
	//   Date:      Sun May 16 14:18:29 CET 2004
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 012 (structural brick - 20 nodes)
	//   Orientation of crack is saved inside results.
	//
	return 26 * 27
}

// addElem_012 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e012.c:42
func addElem_012() int32 {
	var rv int32
	var type_ int32 = 12
	var dim int32 = 3
	var nodes int32 = 20
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 3}
	var rs int32
	var real_ []int32
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 32
	var nres_rp []int32 = []int32{7, 8, 9, 11, 12, 10, 13, 14, 15, 17, 18, 16, 73, 74, 75, 77, 78, 76, 37, 38, 28, 29, 31, 39, 40, 41, 42, 43, 44, 45, 46, 47}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e008_stiff
	Elem[type_].mass = e008_mass
	Elem[type_].rvals = e012_rvals
	Elem[type_].eload = e008_eload
	Elem[type_].res_p_loc = e008_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e008_volume
	Elem[type_].therm = e000_therm
	return rv
}

// addElem_013 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e013.c:42
func addElem_013() int32 {
	//
	//   File name: fem_e013.c
	//   Date:      2005/03/02 20:42
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 013 (2D beam with stiffness curve)
	//
	//   Note that no element load is used (nodal forces/moments only)
	//
	//  $Id$
	//
	var rv int32
	var type_ int32 = 13
	var dim int32 = 5
	var nodes int32 = 2
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 6}
	var rs int32 = 4
	var real_ []int32 = []int32{1, 9, 11, 12}
	var rs_rp int32 = 3
	// EI curve data
	var real_rp []int32 = []int32{14, 15, 16}
	var res int32 = 4
	var nres []int32 = []int32{1, 2, 6, 60}
	var res_rp int32 = 4
	var nres_rp []int32 = []int32{1, 2, 6, 60}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e003_stiff
	Elem[type_].mass = e003_mass
	Elem[type_].rvals = e003_rvals
	Elem[type_].eload = e003_eload
	Elem[type_].res_p_loc = e003_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e003_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e014_local_stiff_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:32
func e014_local_stiff_matrix(ePos int32, Mode int32, Lx float64, Ex float64, Gx float64, Ax float64, Ix float64, Iy float64, Iz float64, k_0 []tMatrix) int32 {
	//
	//   File name: fem_e014.c
	//   Date:      2005/06/03 18:10
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2005 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM solver: 3D beam
	//
	var rv int32
	var i int32
	var j int32
	femMatSetZero(k_0)
	// X - torsion:
	femMatPutAdd(k_0, 4, 4, Gx*Ix/Lx, 0)
	femMatPutAdd(k_0, 10, 10, Gx*Ix/Lx, 0)
	femMatPutAdd(k_0, 4, 10, -(Gx*Ix)/Lx, 0)
	femMatPutAdd(k_0, 10, 4, -(Gx*Ix)/Lx, 0)
	// X - normal:
	femMatPutAdd(k_0, 1, 1, Ex*Ax/Lx, 0)
	femMatPutAdd(k_0, 7, 7, Ex*Ax/Lx, 0)
	femMatPutAdd(k_0, 1, 7, -(Ex*Ax)/Lx, 0)
	femMatPutAdd(k_0, 1, 7, -(Ex*Ax)/Lx, 0)
	// Y - bending
	femMatPutAdd(k_0, 2, 2, 12*Ex*Iy/(Lx*Lx*Lx), 0)
	femMatPutAdd(k_0, 2, 6, -6*Ex*Iy/(Lx*Lx), 0)
	femMatPutAdd(k_0, 2, 8, -12*Ex*Iy/(Lx*Lx*Lx), 0)
	femMatPutAdd(k_0, 2, 12, -6*Ex*Iy/(Lx*Lx), 0)
	femMatPutAdd(k_0, 6, 6, 4*Ex*Iy/Lx, 0)
	femMatPutAdd(k_0, 6, 8, 6*Ex*Iy/(Lx*Lx), 0)
	femMatPutAdd(k_0, 6, 12, 2*Ex*Iy/Lx, 0)
	femMatPutAdd(k_0, 8, 8, 12*Ex*Iy/(Lx*Lx*Lx), 0)
	femMatPutAdd(k_0, 8, 12, 6*Ex*Iy/(Lx*Lx), 0)
	femMatPutAdd(k_0, 12, 12, 4*Ex*Iy/Lx, 0)
	// Z - bending
	femMatPutAdd(k_0, 3, 3, 12*Ex*Iz/(Lx*Lx*Lx), 0)
	femMatPutAdd(k_0, 3, 5, -6*Ex*Iz/(Lx*Lx), 0)
	femMatPutAdd(k_0, 3, 9, -12*Ex*Iz/(Lx*Lx*Lx), 0)
	femMatPutAdd(k_0, 3, 11, -6*Ex*Iz/(Lx*Lx), 0)
	femMatPutAdd(k_0, 5, 5, 4*Ex*Iz/Lx, 0)
	femMatPutAdd(k_0, 5, 9, 6*Ex*Iz/(Lx*Lx), 0)
	femMatPutAdd(k_0, 5, 11, 2*Ex*Iz/Lx, 0)
	femMatPutAdd(k_0, 9, 9, 12*Ex*Iz/(Lx*Lx*Lx), 0)
	femMatPutAdd(k_0, 9, 11, 6*Ex*Iz/(Lx*Lx), 0)
	femMatPutAdd(k_0, 11, 11, 4*Ex*Iz/Lx, 0)
	for i = 2; i <= 12; i++ {
		for j = 1; j <= i; j++ {
			femMatPutAdd(k_0, i, j, femMatGet(k_0, j, i), 0)
		}
	}
	femMatPrn(k_0, []byte("K0\x00"))
	return rv
}

// e014_T_mat2 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:106
func e014_T_mat2(xa float64, ya float64, za float64, xb float64, yb float64, zb float64, T []tMatrix, TT []tMatrix) int32 {
	var i int32
	var j int32
	var a []float64 = make([]float64, 4)
	var b []float64 = make([]float64, 4)
	var c []float64 = make([]float64, 4)
	var xc float64
	var yc float64
	var zc float64
	var dx float64
	var dy float64
	var dz float64
	var L float64
	var A float64
	var B float64
	var C float64
	var D float64
	dx = xb - xa
	dy = yb - ya
	dz = zb - za
	L = math.Sqrt(math.Pow(dx, 2) + math.Pow(dy, 2) + math.Pow(dz, 2))
	if math.Abs(ya-yb)*(xa-xb) < 1e-17 {
		// "c" point:
		// collumn in x-y plane
		xc = xb + L
		yc = yb
		zc = zb
	} else {
		// normal
		xc = xb
		yc = yb
		zc = zb + L
	}
	a[1] = (xb - xa) / L
	a[2] = (yb - ya) / L
	a[3] = (zb - za) / L
	A = (yc-ya)*(zb-za) - (yb-ya)*(zc-za)
	B = (zc-za)*(xb-xa) - (zb-za)*(xc-xa)
	C = (xc-xa)*(yb-ya) - (xb-xa)*(yc-ya)
	D = math.Sqrt(A*A + B*B + C*C)
	a[2] = A / D
	b[2] = B / D
	c[2] = C / D
	a[3] = b[1]*c[2] - b[2]*c[1]
	b[3] = a[2]*c[1] - a[1]*c[2]
	c[3] = a[1]*b[2] - b[1]*a[2]
	for i = 0; i < 4; i++ {
		for j = 1; j <= 3; j++ {
			femMatPutAdd(T, j+i*3, 1+i*3, a[j], 0)
			femMatPutAdd(T, j+i*3, 2+i*3, b[j], 0)
			femMatPutAdd(T, j+i*3, 3+i*3, c[j], 0)
		}
	}
	femMatTran(T, TT)
	return 0
}

// e014_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:269
func e014_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var Lx float64
	var Ex float64
	var Gx float64
	var Ax float64
	var pr float64
	var Ix float64
	var Iy float64
	var Iz float64
	var x1 float64
	var y1 float64
	var z1 float64
	var x2 float64
	var y2 float64
	var z2 float64
	var klx1 int32
	var kly1 int32
	var klz1 int32
	var klx2 int32
	var kly2 int32
	var klz2 int32
	var k_0 tMatrix
	var T tMatrix
	var TT tMatrix
	var Tk_0 tMatrix
	var u_e tVector
	var F_0 tVector
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&TT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TT))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	// geometric properties:
	Ax = femGetRSValPos(ePos, 1, 0)
	Ix = femGetRSValPos(ePos, 8, 0)
	Iy = femGetRSValPos(ePos, 9, 0)
	Iz = femGetRSValPos(ePos, 10, 0)
	klx1 = int32(femGetRSValPos(ePos, 17, 0))
	kly1 = int32(femGetRSValPos(ePos, 18, 0))
	klz1 = int32(femGetRSValPos(ePos, 19, 0))
	klx2 = int32(femGetRSValPos(ePos, 20, 0))
	kly2 = int32(femGetRSValPos(ePos, 21, 0))
	klz2 = int32(femGetRSValPos(ePos, 22, 0))
	// material properties:
	Ex = femGetMPValPos(ePos, 2, 0)
	pr = femGetMPValPos(ePos, 5, 0)
	Gx = Ex / (2 * (1 + pr))
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	Lx = math.Sqrt(math.Pow(x1-x2, 2) + math.Pow(y1-y2, 2) + math.Pow(z1-z2, 2))
	if Lx <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		rv = -3
		goto memFree
	}
	e014_local_stiff_matrix(ePos, Mode, Lx, Ex, Gx, Ax, Ix, Iy, Iz, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], []byte("K_0\x00"))
	if (func() int32 {
		rv = e014_T_mat2(x1, y1, z1, x2, y2, z2, (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TT))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], []byte("T\x00"))
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], K_e)
	femMatPrn(K_e, []byte("K_e\x00"))
	if Mode == 1 {
		// ======================================================================
		// result, F_e, Fr_e
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 12, 12)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 12, 12)
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		// global
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		// local
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		// residual forces ;-)
		femVecSetZero(Fr_e)
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1))
			femAddPutRepVal(ePos, 2, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 2))
			femAddPutRepVal(ePos, 3, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 3))
			femAddPutRepVal(ePos, 4, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 4))
			femAddPutRepVal(ePos, 5, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 5))
			femAddPutRepVal(ePos, 6, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 6))
			femAddPutRepVal(ePos, 1, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 7))
			femAddPutRepVal(ePos, 2, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 8))
			femAddPutRepVal(ePos, 3, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 9))
			femAddPutRepVal(ePos, 4, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 10))
			femAddPutRepVal(ePos, 5, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 11))
			femAddPutRepVal(ePos, 6, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 12))
		} else {
			femAddPutRepVal(ePos, 1, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1))
			femAddPutRepVal(ePos, 2, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 2))
			femAddPutRepVal(ePos, 3, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 3))
			femAddPutRepVal(ePos, 4, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 4))
			femAddPutRepVal(ePos, 5, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 5))
			femAddPutRepVal(ePos, 6, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 6))
			femAddPutRepVal(ePos, 1, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 7))
			femAddPutRepVal(ePos, 2, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 8))
			femAddPutRepVal(ePos, 3, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 9))
			femAddPutRepVal(ePos, 4, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 10))
			femAddPutRepVal(ePos, 5, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 11))
			femAddPutRepVal(ePos, 6, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 12))
		}
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	return rv
}

// e014_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:409
func e014_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	return rv
}

// e014_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:417
func e014_rvals(ePos int32) int32 {
	return 12
}

// e014_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:422
func e014_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e014_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:427
func e014_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	x[0] = 0
	y[0] = 0
	z[0] = 0
	switch point {
	case 0:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
		z[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	case 1:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
		z[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
		break
	}
	return 0
}

// addElem_014 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e014.c:449
func addElem_014() int32 {
	var rv int32
	var type_ int32 = 14
	var dim int32 = 5
	var nodes int32 = 2
	var dofs int32 = 6
	var ndof []int32 = []int32{1, 2, 3, 4, 5, 6}
	var rs int32 = 4
	var real_ []int32 = []int32{1, 8, 9, 10}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 6
	var nres []int32 = []int32{1, 2, 3, 4, 5, 6}
	var res_rp int32 = 6
	var nres_rp []int32 = []int32{1, 2, 3, 4, 5, 6}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e014_stiff
	Elem[type_].mass = e014_mass
	Elem[type_].rvals = e014_rvals
	Elem[type_].eload = e014_eload
	Elem[type_].res_p_loc = e014_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e007_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e015_get_L - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e015.c:35
func e015_get_L(x1 float64, y1 float64, x2 float64, y2 float64) float64 {
	//
	//   File name: fem_e015.c
	//   Date:      2006/10/30 19:07
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2006 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - element 015 constant strain/ plane element
	//               linear solution ONLY
	//                Cosserat continuum
	//
	return math.Sqrt(math.Pow(y2*y2-y1*y1, 2) + math.Pow(x2*x2-x1*x1, 2))
}

// e015_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e015.c:40
func e015_stiff(ePos int32, Mode int32, K_e []tMatrix, Fe []tVector, Fre []tVector) int32 {
	var rv int32
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	var l1 float64
	var l2 float64
	var l3 float64
	var l12 float64
	var l23 float64
	var l31 float64
	var D tMatrix
	var DD tMatrix
	var i int32
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&DD))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 4, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&DD))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= 3; i++ {
		x[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	l1 = e015_get_L(x[2], y[2], x[3], y[3])
	l2 = e015_get_L(x[1], y[1], x[3], y[3])
	l3 = e015_get_L(x[1], y[1], x[2], y[2])
	l12 = l1*l1 + l2*l2 - l3*l3
	l23 = l2*l2 + l3*l3 - l1*l1
	l31 = l3*l3 + l1*l1 - l2*l2
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&DD))[:])
	return rv
}

// e015_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e015.c:81
func e015_mass(ePos int32, M_e []tMatrix) int32 {
	// It should work - according to Zienkiewicz ;-)
	// * Actually, it's for basic triangle, not for Cosserat one
	// *
	var rv int32
	var i int32
	var t float64
	var ro float64
	var A float64
	var mult float64
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	femMatSetZero(M_e)
	// Geometry (width, area) and material (density) data:
	t = femGetRSValPos(ePos, 3, 0)
	ro = femGetMPValPos(ePos, 1, 0)
	for i = 1; i <= 3; i++ {
		x[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	A = 0.5 * (x[1]*y[2] - x[2]*y[1] + x[2]*y[3] - x[3]*y[2] + x[3]*y[1] - x[1]*y[3])
	// Multiplier:
	mult = ro * t * A / 3
	femMatPutAdd(M_e, 1, 1, mult*0.5, 0)
	femMatPutAdd(M_e, 1, 4, mult*0.25, 0)
	femMatPutAdd(M_e, 1, 7, mult*0.25, 0)
	femMatPutAdd(M_e, 2, 2, mult*0.5, 0)
	femMatPutAdd(M_e, 2, 5, mult*0.25, 0)
	femMatPutAdd(M_e, 2, 8, mult*0.25, 0)
	femMatPutAdd(M_e, 4, 1, mult*0.25, 0)
	femMatPutAdd(M_e, 4, 4, mult*0.5, 0)
	femMatPutAdd(M_e, 4, 7, mult*0.25, 0)
	femMatPutAdd(M_e, 5, 2, mult*0.25, 0)
	femMatPutAdd(M_e, 5, 5, mult*0.5, 0)
	femMatPutAdd(M_e, 5, 8, mult*0.25, 0)
	femMatPutAdd(M_e, 7, 1, mult*0.25, 0)
	femMatPutAdd(M_e, 7, 4, mult*0.25, 0)
	femMatPutAdd(M_e, 7, 7, mult*0.5, 0)
	femMatPutAdd(M_e, 8, 2, mult*0.25, 0)
	femMatPutAdd(M_e, 8, 5, mult*0.25, 0)
	femMatPutAdd(M_e, 8, 8, mult*0.5, 0)
	return rv
}

// e015_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e015.c:134
func e015_rvals(ePos int32) int32 {
	return 6
}

// e015_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e015.c:139
func e015_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// addElem_015 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e015.c:144
func addElem_015() int32 {
	var rv int32
	var type_ int32 = 15
	var dim int32 = 2
	var nodes int32 = 3
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 6}
	var rs int32 = 1
	var real_ []int32 = []int32{3}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 6
	var nres []int32 = []int32{7, 8, 10, 13, 14, 16}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e015_stiff
	Elem[type_].mass = e015_mass
	Elem[type_].rvals = e015_rvals
	Elem[type_].eload = e015_eload
	Elem[type_].res_p_loc = e011_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e011_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e016_local_stiff_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:54
func e016_local_stiff_matrix(ePos int32, Mode int32, Lx float64, Ex float64, Ax float64, EI float64, kl1 float64, kl2 float64, k_0 []tMatrix) int32 {
	//
	//   File name: fem_e016.c
	//   Date:      2007/07/18 16:15
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2007  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 016 (2D beam with layers)
	//
	//   PLEASE REMEBER:
	//   * layers are numbert from BOTTOM
	//   * there have to be always AT LEAST ONE LAYER
	//
	//   Note that no element load is used (nodal forces/moments only)
	//
	var rv int32
	var i int32
	var j int32
	femMatSetZero(k_0)
	// filling of stiffness matrix:
	femMatPutAdd(k_0, 1, 1, Ax*Ex/Lx, 0)
	femMatPutAdd(k_0, 1, 4, -1*(Ax*Ex)/Lx, 0)
	femMatPutAdd(k_0, 4, 4, Ax*Ex/Lx, 0)
	if kl1 > 0 && kl2 > 0 {
		femMatPutAdd(k_0, 2, 2, 12*EI/(Lx*Lx*Lx), 0)
		femMatPutAdd(k_0, 2, 3, kl1*(-6*EI)/(Lx*Lx), 0)
		femMatPutAdd(k_0, 2, 5, -12*EI/(Lx*Lx*Lx), 0)
		femMatPutAdd(k_0, 2, 6, kl2*(-6*EI)/(Lx*Lx), 0)
		femMatPutAdd(k_0, 3, 3, kl1*(4*EI)/Lx, 0)
		femMatPutAdd(k_0, 3, 5, 6*EI/(Lx*Lx), 0)
		femMatPutAdd(k_0, 3, 6, kl1*kl2*(2*EI)/Lx, 0)
		femMatPutAdd(k_0, 5, 5, 12*EI/(Lx*Lx*Lx), 0)
		femMatPutAdd(k_0, 5, 6, kl2*(6*EI)/(Lx*Lx), 0)
		femMatPutAdd(k_0, 6, 6, kl2*(4*EI)/Lx, 0)
	} else {
		if kl1 == 0 && kl2 > 0 {
			// o--|
			femMatPutAdd(k_0, 2, 2, 3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 5, -3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 6, -3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 5, 5, 3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 5, 6, 3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 6, 6, 3*EI/Lx, 0)
		}
		if kl1 > 0 && kl2 == 0 {
			// |--o
			femMatPutAdd(k_0, 2, 2, 3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 3, -3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 2, 5, -3*EI/(Lx*Lx*Lx), 0)
			femMatPutAdd(k_0, 3, 2, -3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 3, 3, 3*EI/Lx, 0)
			femMatPutAdd(k_0, 3, 5, 3*EI/(Lx*Lx), 0)
			femMatPutAdd(k_0, 5, 5, 3*EI/(Lx*Lx*Lx), 0)
		}
		if kl1 == 0 && kl2 == 0 {
			// 0-0 - probably a user error
			noarch.Fprintf(msgout, []byte("[W] %s %li!\n\x00"), []byte("Beam with two hinges found - element\x00"), eID[ePos])
		}
	}
	for i = 2; i <= 6; i++ {
		for j = 1; j <= i; j++ {
			femMatPutAdd(k_0, i, j, femMatGet(k_0, j, i), 0)
		}
	}
	femMatPrn(k_0, []byte("K_0\x00"))
	return rv
}

// e016_compute_EI - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:130
func e016_compute_EI(ePos int32, Mode int32, epsilon_top float64, epsilon_bot float64, yy []float64, htop []float64, hbot []float64, Ax []float64, Ix []float64) float64 {
	var EI float64
	var lnum int32
	var i int32
	var stat int32
	var y float64
	var A float64
	var S float64
	var b float64
	var h float64
	var E float64
	var I float64
	var E0 float64
	var epsilon float64
	var epsilon_prev float64
	var e_ten float64
	var e_com float64
	var Gf float64
	var smax float64
	E0 = femGetMPValPos(ePos, 2, 0)
	Ax[0] = 0
	Ix[0] = 0
	// get center of gravity
	S = 0
	A = 0
	y = 0
	if (func() int32 {
		lnum = femGetRSRepNumPos(ePos)
		return lnum
	}()) < 1 {
		noarch.Fprintf(msgout, []byte("[W] %s %li!\n\x00"), []byte("No layers on beam\x00"), femGetIntPos(ePos, eID, eLen))
		return 0
	}
	for i = 1; i <= lnum; i++ {
		b = femGetRSValPos(ePos, 2, i)
		h = femGetRSValPos(ePos, 3, i)
		A += b * h
		S += A * (0.5*h + y)
		y += h
	}
	if A <= 0 {
		noarch.Fprintf(msgout, []byte("[W] %s %li!\n\x00"), []byte("Empty layers on beam\x00"), femGetIntPos(ePos, eID, eLen))
		return 0
	}
	yy[0] = S / A
	htop[0] = math.Abs(yy[0] - y)
	hbot[0] = math.Abs(y)
	Ax[0] = A
	// Compute EI
	EI = 0
	E = 0
	I = 0
	if Mode == 1 {
		e_ten = femGetMPValPos(ePos, 7, 0) / E0
		e_com = femGetMPValPos(ePos, 8, 0) / E0
		Gf = femGetMPValPos(ePos, 9, 0)
		smax = femGetMPValPos(ePos, 11, 0)
	}
	for i = 1; i <= lnum; i++ {
		b = femGetRSValPos(ePos, 2, i)
		h = femGetRSValPos(ePos, 3, i)
		I = 1/12*b*math.Pow(h, 3) + b*h*(y+0.5*h)
		Ix[0] += I
		E = 0
		if Mode == 1 {
			if y+0.5*h <= yy[0] {
				// new
				// bottom
				epsilon = epsilon_bot * math.Abs((y+0.5*h)/yy[0])
			} else {
				// up
				epsilon = epsilon_top * math.Abs((y+0.5*h-hbot[0])/htop[0])
			}
			if femGetIntPos(ePos, mpType, mpLen) == 8 {
				epsilon_prev = femGetRepVal(ePos, 13, i, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
				stat = sb1d_get_check_epsilon(epsilon, epsilon_prev, e_ten, e_com)
				femAddPutRepVal(ePos, 29, int32(I), resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(stat))
				switch stat {
				case 2:
					// inelastic tension
					// TODO !!!
					E = sb1d_get_Rt_tension(ePos, E0, smax, Gf/b, h, epsilon)
					// is it OK ?
				case 3:
					// inelastic compression
					E = E0
				case -1:
					if (func() float64 {
						E = femGetRepVal(ePos, 28, i, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
						return E
					}()) <= 0 {
						// inelastic tension unloading
						// TODO add something better here !!! TODO
						E = E0
					}
				case -3:
					// inelastic compression unloading
					E = E0
				case 1:
					fallthrough
				case 0:
					fallthrough
				default:
					// elastic
					E = E0
					break
				}
			} else {
				E = E0
			}
			femAddPutRepVal(ePos, 28, int32(I), resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, E)
		} else {
			// old
			stat = int32(femGetRepVal(ePos, 29, i, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
			if float64(stat) == 0 {
				E = E0
			} else {
				E = femGetRepVal(ePos, 28, i, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
			}
		}
		EI += E * I
		y += h
	}
	return EI
}

// e016_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:300
func e016_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	// Young's modulus
	var Ex float64
	// area
	var Ax float64
	// moment of inertia
	var Ix float64
	// lenght of beam
	var Lx float64
	var k_0 tMatrix
	var Tk_0 tMatrix
	var T tMatrix
	var T_T tMatrix
	var F_0 tVector
	var F_1 tVector
	var u_e tVector
	var cos_a float64
	var sin_a float64
	var kl1 float64 = 1
	var kl2 float64 = 1
	var EI float64
	// cross-section parameters
	var htop float64
	var hbot float64
	var yy float64
	var Mx float64
	var e_top float64
	var e_bot float64
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	if (func() float64 {
		Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
		return Lx
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		return -3
	}
	cos_a = (x2 - x1) / Lx
	sin_a = (y2 - y1) / Lx
	// geometric properties:
	Ax = femGetRSValPos(ePos, 1, 0)
	Ix = femGetRSValPos(ePos, 9, 0)
	kl1 = femGetRSValPos(ePos, 11, 0)
	kl2 = femGetRSValPos(ePos, 12, 0)
	if kl1 < 0.5 {
		// stiffness of left and right joint:
		kl1 = 0
	} else {
		kl1 = 1
	}
	if kl2 < 0.5 {
		kl2 = 0
	} else {
		kl2 = 1
	}
	// material properties:
	Ex = femGetMPValPos(ePos, 2, 0)
	EI = e016_compute_EI(ePos, 0, 0, 0, c4goUnsafeConvert_float64(&yy), c4goUnsafeConvert_float64(&htop), c4goUnsafeConvert_float64(&hbot), c4goUnsafeConvert_float64(&Ax), c4goUnsafeConvert_float64(&Ix))
	e016_local_stiff_matrix(ePos, Mode, Lx, Ex, Ax, EI, kl1, kl2, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	// transformation matrix
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 1, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 2, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 1, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 2, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 3, 3, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 4, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 5, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 4, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 5, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 6, 6, 1, 0)
	// transposition of "T"
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	// global stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	// finishing of global stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], K_e)
	femMatPrn(K_e, []byte("K_e\x00"))
	if Mode == 1 {
		// ======================================================================
		// result, F_e, Fr_e
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 6, 6)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 6, 6)
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], []byte("U_e\x00"))
		// nodal forces:
		// global
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		// to fix problem with moment signs:
		Mx = 0.5 * (femVecGet(F_e, 3) + femVecGet(F_e, 6))
		e_top = Mx * htop / EI
		e_bot = Mx * -hbot / EI
		noarch.Fprintf(msgout, []byte("e(%li) top=%e bot=%e\n\x00"), femGetIntPos(ePos, eID, eLen), e_top, e_bot)
		// local
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		// residual forces ;-)
		femVecSetZero(Fr_e)
		femVecPrn(F_e, []byte("F_e\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], []byte("F_0\x00"))
		EI = Ex * Ix
		// layered beam
		// TODO: compute epsilon _top and _bot here!!!
		EI = e016_compute_EI(ePos, Mode, e_top, e_bot, c4goUnsafeConvert_float64(&yy), c4goUnsafeConvert_float64(&htop), c4goUnsafeConvert_float64(&hbot), c4goUnsafeConvert_float64(&Ax), c4goUnsafeConvert_float64(&Ix))
		e016_local_stiff_matrix(ePos, Mode, Lx, Ex, Ax, EI, kl1, kl2, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
		femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
		femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], K_e)
		// global
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		// local
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecLinComb(1, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&F_1))[:], Fr_e)
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	return 0
}

// e016_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:494
func e016_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var Lx float64
	var Ax float64
	var dens float64
	var mass float64
	var i int32
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	if (func() float64 {
		Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
		return Lx
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		return -3
	}
	Ax = femGetRSValPos(ePos, 1, 0)
	dens = femGetMPValPos(ePos, 1, 0)
	mass = dens * Ax * Lx
	noarch.Fprintf(msgout, []byte("mass = %e \n\x00"), mass)
	for i = 1; i < 3; i++ {
		femMatPutAdd(M_e, i, i, mass/4, 0)
		femMatPutAdd(M_e, i+3, i+3, mass/4, 0)
	}
	return rv
}

// e016_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:537
func e016_rvals(ePos int32) int32 {
	return 3 + femGetRSRepNumPos(ePos)*4
}

// e016_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:542
func e016_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e016_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:547
func e016_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	x[0] = 0
	y[0] = 0
	z[0] = 0
	switch point {
	case 0:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	case 1:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
		break
	}
	return 0
}

// addElem_016 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e016.c:567
func addElem_016() int32 {
	var rv int32
	var type_ int32 = 16
	var dim int32 = 5
	var nodes int32 = 2
	var dofs int32 = 3
	var ndof []int32 = []int32{1, 2, 6}
	var rs int32 = 2
	var real_ []int32 = []int32{11, 12}
	var rs_rp int32 = 4
	var real_rp []int32 = []int32{2, 3, 23, 24}
	var res int32 = 3
	// in element centroid
	var nres []int32 = []int32{1, 2, 6}
	var res_rp int32 = 4
	// dtto but in layers
	var nres_rp []int32 = []int32{13, 7, 28, 29}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e016_stiff
	Elem[type_].mass = e016_mass
	Elem[type_].rvals = e016_rvals
	Elem[type_].eload = e016_eload
	Elem[type_].res_p_loc = e016_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e003_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e017_local_stiff_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:36
func e017_local_stiff_matrix(ePos int32, Mode int32, Lx float64, Ex float64, Gx float64, Ax float64, Ix float64, Itx float64, k_0 []tMatrix) int32 {
	//
	//   File name: fem_e017.c
	//   Date:      2017/05/18 20:15
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2017  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 017 (2D grille)
	//
	//   Note that no element load is used (nodal forces/moments only)
	//
	var rv int32
	var i int32
	var j int32
	femMatSetZero(k_0)
	// filling of stiffness matrix:
	femMatPutAdd(k_0, 1, 1, 12*Ex*Ix/math.Pow(Lx, 3), 0)
	femMatPutAdd(k_0, 1, 3, -6*Ex*Ix/math.Pow(Lx, 2), 0)
	femMatPutAdd(k_0, 1, 4, -12*Ex*Ix/math.Pow(Lx, 3), 0)
	femMatPutAdd(k_0, 1, 6, -6*Ex*Ix/math.Pow(Lx, 2), 0)
	femMatPutAdd(k_0, 2, 2, Gx*Itx/Lx, 0)
	femMatPutAdd(k_0, 2, 5, -Gx*Itx/Lx, 0)
	femMatPutAdd(k_0, 3, 3, 4*Ex*Ix/Lx, 0)
	femMatPutAdd(k_0, 3, 4, 6*Ex*Ix/math.Pow(Lx, 2), 0)
	femMatPutAdd(k_0, 3, 6, 2*Ex*Ix/Lx, 0)
	femMatPutAdd(k_0, 4, 4, 12*Ex*Ix/math.Pow(Lx, 3), 0)
	femMatPutAdd(k_0, 4, 6, 6*Ex*Ix/math.Pow(Lx, 2), 0)
	femMatPutAdd(k_0, 5, 5, Gx*Itx/Lx, 0)
	femMatPutAdd(k_0, 6, 6, 4*Ex*Ix/Lx, 0)
	for i = 2; i <= 6; i++ {
		for j = 1; j <= i; j++ {
			femMatPutAdd(k_0, i, j, femMatGet(k_0, j, i), 0)
		}
	}
	femMatPrn(k_0, []byte("K_0\x00"))
	return rv
}

// e017_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:84
func e017_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	// Young's modulus
	var Ex float64
	// shear modulus
	var Gx float64
	// area
	var Ax float64
	// moment of inertia
	var Ix float64
	// moment in torsion
	var Itx float64
	// lenght of beam
	var Lx float64
	// Winkler constant
	var Wink float64
	// width for winkler
	var width float64
	var k_0 tMatrix
	var k_g tMatrix
	var k_1 tMatrix
	var Tk_0 tMatrix
	var T tMatrix
	var T_T tMatrix
	var F_0 tVector
	var u_e tVector
	var cos_a float64
	var sin_a float64
	var nu float64
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	if (func() float64 {
		Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
		return Lx
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		return -3
	}
	cos_a = (x2 - x1) / Lx
	sin_a = (y2 - y1) / Lx
	// geometric properties:
	Ax = femGetRSValPos(ePos, 1, 0)
	Ix = femGetRSValPos(ePos, 9, 0)
	Itx = femGetRSValPos(ePos, 8, 0)
	Wink = femGetRSValPos(ePos, 13, 0)
	width = femGetRSValPos(ePos, 2, 0)
	// material properties:
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	Gx = Ex / (2 * (1 + nu))
	e017_local_stiff_matrix(ePos, Mode, Lx, Ex, Gx, Ax, Ix, Itx, (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	if Wink*width > 0 {
		femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 1, 1, 0.5*Wink*width*Lx, 0)
		femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], 4, 4, 0.5*Wink*width*Lx, 0)
	}
	// transformation matrix
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 1, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 1, 2, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 1, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 2, 2, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 3, 3, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 4, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 4, 5, sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 4, -sin_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 5, 5, cos_a, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], 6, 6, 1, 0)
	// transposition of "T"
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	// global stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:], (*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	// finishing of global stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&T))[:], K_e)
	femMatPrn(K_e, []byte("K_e\x00"))
	if Mode == 1 {
		// ======================================================================
		// result, F_e, Fr_e
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, 6, 6)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 6, 6)
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], []byte("U_e\x00"))
		// nodal forces:
		// global
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		// to fix problem with moment signs:
		// local
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&T))[:], F_e, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		// residual forces ;-)
		femVecSetZero(Fr_e)
		femVecPrn(F_e, []byte("F_e\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], []byte("F_0\x00"))
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 3, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1))
			femAddPutRepVal(ePos, 4, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 2))
			femAddPutRepVal(ePos, 5, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 3))
			femAddPutRepVal(ePos, 3, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 4))
			femAddPutRepVal(ePos, 4, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 5))
			femAddPutRepVal(ePos, 5, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 6))
		} else {
			femAddPutRepVal(ePos, 3, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 1))
			femAddPutRepVal(ePos, 4, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 2))
			femAddPutRepVal(ePos, 5, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 3))
			femAddPutRepVal(ePos, 3, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 4))
			femAddPutRepVal(ePos, 4, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 5))
			femAddPutRepVal(ePos, 5, 1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 6))
		}
		//printf("RR %f %f \n",
		//     femGetEResVal(ePos, RES_MZ, 0),
		//     femGetEResVal(ePos, RES_MZ, 1)
		//  );
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Tk_0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&T_T))[:])
	if fem2ndOrder == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_g))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&k_1))[:])
	}
	return 0
}

// e017_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:269
func e017_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var Lx float64
	var Ax float64
	var dens float64
	var mass float64
	var i int32
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	if (func() float64 {
		Lx = math.Sqrt(math.Pow(y2-y1, 2) + math.Pow(x2-x1, 2))
		return Lx
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Zero element lenght\x00"))
		return -3
	}
	Ax = femGetRSValPos(ePos, 1, 0)
	dens = femGetMPValPos(ePos, 1, 0)
	mass = dens * Ax * Lx
	noarch.Fprintf(msgout, []byte("mass = %e \n\x00"), mass)
	for i = 1; i < 3; i++ {
		femMatPutAdd(M_e, i, i, mass/2, 0)
		femMatPutAdd(M_e, i+3, i+3, mass/2, 0)
	}
	femMatPutAdd(M_e, 3, 3, mass*Lx*Lx/24, 0)
	femMatPutAdd(M_e, 6, 6, mass*Lx*Lx/24, 0)
	return rv
}

// e017_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:317
func e017_rvals(ePos int32) int32 {
	return 6
}

// e017_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:322
func e017_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e017_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:327
func e017_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	x[0] = 0
	y[0] = 0
	z[0] = 0
	switch point {
	case 0:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	case 1:
		x[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[0] = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
		break
	}
	return 0
}

// addElem_017 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e017.c:347
func addElem_017() int32 {
	var rv int32
	var type_ int32 = 17
	var dim int32 = 5
	var nodes int32 = 2
	var dofs int32 = 3
	var ndof []int32 = []int32{3, 4, 5}
	var rs int32 = 5
	var real_ []int32 = []int32{1, 8, 9, 13, 2}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 3
	var nres []int32 = []int32{3, 4, 5}
	var res_rp int32 = 3
	var nres_rp []int32 = []int32{3, 4, 5}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e017_stiff
	Elem[type_].mass = e017_mass
	Elem[type_].rvals = e017_rvals
	Elem[type_].eload = e017_eload
	Elem[type_].res_p_loc = e017_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e003_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e018_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e018.c:34
func e018_stiff(ePos int32, Mode int32, K_e []tMatrix, Fe []tVector, Fre []tVector) int32 {
	//
	//   File name: fem_e018.c
	//   Date:      2011/06/07 18:21
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2011 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - element 018 temperature plane element
	//
	var rv int32
	var A float64
	var thick float64
	var mult float64
	var kxx float64
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	var i int32
	//[3][2]
	var B tMatrix
	//[2][3]
	var Bt tMatrix
	//[3][3]
	var S tMatrix
	//[3][3]
	var St tMatrix
	//[2][2]
	var D tMatrix
	//[6][3]
	var BtD tMatrix
	//[3][2]
	var StBt tMatrix
	//[2][3]
	var BS tMatrix
	//[3]
	var u_e tVector
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 2, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 3, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], 0, 3, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], 0, 2, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], 0, 3, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= 3; i++ {
		x[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen)
		y[i] = femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen)
	}
	A = e011_area(ePos)
	thick = femGetRSValPos(ePos, 3, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 1, 1, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 2, 2, 1, 0)
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 1, y[2]-y[3], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 2, y[3]-y[1], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 3, y[1]-y[2], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 1, x[3]-x[2], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 2, x[1]-x[3], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 3, x[2]-x[1], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 1, x[2]*y[3]-x[3]*y[2], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 2, x[3]*y[1]-x[1]*y[3], 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 3, x[1]*y[2]-x[2]*y[1], 0)
	mult = 1 / (x[1]*y[2] + x[3]*y[1] + x[2]*y[3] - x[3]*y[2] - x[2]*y[1] - x[1]*y[3])
	femValMatMultSelf(mult, (*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	kxx = femGetMPValPos(ePos, 37, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 1, 1, kxx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 2, 2, kxx, 0)
	// stiffness matrix is computed
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], K_e)
	femValMatMultSelf(A*thick, K_e)
	// Control prints:
	femMatPrn(K_e, []byte("Ke local:\x00"))
	if Mode == 1 {
		// results are computed
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u))[:], []byte("u global:\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], []byte("u local:\x00"))
		mult = (femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 1) + femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 2) + femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 3)) / 3
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 71, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, mult)
		} else {
			femAddPutRepVal(ePos, 71, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, mult)
		}
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], Fe)
		femVecSetZero(Fre)
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	return rv
}

// e018_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e018.c:160
func e018_mass(ePos int32, M_e []tMatrix) int32 {
	// Thermal capacity matrix:
	var rv int32
	var t float64
	var ro float64
	var A float64
	var C float64
	var mult float64
	femMatSetZero(M_e)
	// Material data:
	t = femGetRSValPos(ePos, 3, 0)
	ro = femGetMPValPos(ePos, 1, 0)
	C = femGetMPValPos(ePos, 39, 0)
	A = e011_area(ePos)
	// Multiplier:
	mult = 1 / 9 * (ro * A * C * t)
	femMatPutAdd(M_e, 1, 1, mult, 0)
	femMatPutAdd(M_e, 1, 2, mult, 0)
	femMatPutAdd(M_e, 1, 3, mult, 0)
	femMatPutAdd(M_e, 2, 1, mult, 0)
	femMatPutAdd(M_e, 2, 2, mult, 0)
	femMatPutAdd(M_e, 2, 3, mult, 0)
	femMatPutAdd(M_e, 3, 1, mult, 0)
	femMatPutAdd(M_e, 3, 2, mult, 0)
	femMatPutAdd(M_e, 3, 3, mult, 0)
	return rv
}

// e018_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e018.c:192
func e018_rvals(ePos int32) int32 {
	return 1
}

// e018_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e018.c:194
func e018_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// addElem_018 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e018.c:196
func addElem_018() int32 {
	var rv int32
	var type_ int32 = 18
	var dim int32
	var nodes int32 = 3
	var dofs int32 = 1
	var ndof []int32 = []int32{7}
	var rs int32 = 1
	var real_ []int32 = []int32{3}
	var rs_rp int32
	var real_rp []int32
	var res int32 = 1
	var nres []int32 = []int32{71}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e018_stiff
	Elem[type_].mass = e018_mass
	Elem[type_].rvals = e018_rvals
	Elem[type_].eload = e018_eload
	Elem[type_].res_p_loc = e011_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e011_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e019_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e019.c:35
func e019_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	//
	//   File name: fem_e019.c
	//   Date:      Mon Jun 27 19:20:04 CEST 2011
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2011  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - Element 019 (3D - thermal tetrahedron)
	//
	var rv int32
	// 6x6
	var D tMatrix
	// 12x12
	var S tMatrix
	// 12x12
	var St tMatrix
	// 6x12
	var B tMatrix
	// 12x6
	var Bt tMatrix
	// 12x6
	var StBt tMatrix
	// 12x6
	var StBtD tMatrix
	// 6x12
	var BS tMatrix
	var u_e tVector
	var volume float64
	var x1 float64
	var y1 float64
	var x2 float64
	var y2 float64
	var x3 float64
	var y3 float64
	var x4 float64
	var y4 float64
	var z1 float64
	var z2 float64
	var z3 float64
	var z4 float64
	var a1 float64
	var b1 float64
	var c1 float64
	var a2 float64
	var b2 float64
	var c2 float64
	var a3 float64
	var b3 float64
	var c3 float64
	var kxx float64
	var mult float64
	var eT int32
	var mT int32
	eT = femGetIntPos(ePos, eType, eLen)
	mT = femGetIntPos(ePos, eMP, eLen)
	kxx = femGetMPValPos(ePos, 37, 0)
	femMatSetZero(K_e)
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 0, 4, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], 0, 4, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 3, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 4, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], 0, 4, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:], 0, 4, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], 0, 3, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if Mode == 1 {
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 12, 12) != 0 {
			goto memFree
		}
	}
	// coordinates
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	z1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_z, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	z2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_z, nLen)
	x3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_x, nLen)
	y3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_y, nLen)
	z3 = femGetDblPos(femGetIntLPos(ePos, 2, eFrom, eNodesL, eLenL), n_z, nLen)
	x4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_x, nLen)
	y4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_y, nLen)
	z4 = femGetDblPos(femGetIntLPos(ePos, 3, eFrom, eNodesL, eLenL), n_z, nLen)
	noarch.Fprintf(msgout, []byte("E[%li]: x1=%f y1=%f z1=%f, x2=%f y2=%f z2=%f. x3=%f y3=%f z3=%f x4=%f y4=%f z4=%f\n\x00"), eID[ePos], x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)
	a1 = x2 - x1
	a2 = y2 - y1
	a3 = z2 - z1
	b1 = x3 - x1
	b2 = y3 - y1
	b3 = z3 - z1
	c1 = x4 - x1
	c2 = y4 - y1
	c3 = z4 - z1
	// "D" creation:
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 1, 1, kxx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 2, 2, kxx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 3, 3, kxx, 0)
	// "B" matrix:
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 1, 1, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 2, 2, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 3, 3, 1, 0)
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	// "S" matrix:
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 4, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 4, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 4, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4, 4, 1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 1, x1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 2, y1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 1, 3, z1, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 1, x2, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 2, y2, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 2, 3, z2, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 1, x3, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 2, y3, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 3, 3, z3, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4, 1, x4, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4, 2, y4, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], 4, 3, z4, 0)
	if femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&S))[:]) != 0 {
		// hope this works (inversion of "S"):
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inversion of S failed\x00"))
	}
	femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&St))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&S))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	// element stiffness matrix:
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BS))[:], K_e)
	volume = (a1*b2*c3 + c1*a2*b3 + a3*b1*c2 - (c1*b2*a3 + c3*b1*a2 + a1*b3*c2)) / 6
	femValMatMultSelf(volume, K_e)
	if Mode == 1 {
		// ======================================================================
		// result, F_e, Fr_e
		// obtaining of element displacements
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u))[:], []byte("u global:\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], []byte("u local:\x00"))
		mult = (femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 1) + femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 2) + femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 3) + femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 4)) / 4
		if femTangentMatrix == 1 {
			femAddPutRepVal(ePos, 71, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, mult)
		} else {
			femAddPutRepVal(ePos, 71, 0, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, mult)
		}
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], F_e)
		femVecSetZero(Fr_e)
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&S))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&St))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&StBtD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BS))[:])
	if Mode == 1 {
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	return 0
}

// e019_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e019.c:216
func e019_mass(ePos int32, M_e []tMatrix) int32 {
	return 0
}

// e019_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e019.c:218
func e019_rvals(ePos int32) int32 {
	return 1
}

// e019_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e019.c:220
func e019_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// addElem_019 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e019.c:224
func addElem_019() int32 {
	var rv int32
	var type_ int32 = 19
	var dim int32
	var nodes int32 = 4
	var dofs int32 = 1
	var ndof []int32 = []int32{7}
	var rs int32
	var real_ []int32
	var rs_rp int32
	var real_rp []int32
	var res int32 = 1
	var nres []int32 = []int32{71}
	var res_rp int32
	var nres_rp []int32
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e019_stiff
	Elem[type_].mass = e019_mass
	Elem[type_].rvals = e019_rvals
	Elem[type_].eload = e019_eload
	Elem[type_].res_p_loc = e004_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e004_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e020_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e020.c:35
func e020_stiff(ePos int32, Mode int32, K_e []tMatrix, Fe []tVector, Fre []tVector) int32 {
	//
	//   File name: fem_e020.c
	//   Date:      2011/07/08 12:33
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2013 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - element 020 (isoparametric thermal plane) definition
	//
	var rv int32
	var i int32
	var j int32
	var ii int32
	var jj int32
	var thick float64
	var kxx float64
	var ipos int32
	var x float64
	var y float64
	var weight_x float64
	var weight_y float64
	var detj float64
	var mult float64
	var sign [][]float64 = make([][]float64, 4)
	var u_e tVector
	var D tMatrix
	var B tMatrix
	var Bt tMatrix
	var BtD tMatrix
	var BtDB tMatrix
	var N tMatrix
	var G tMatrix
	var xyz tMatrix
	var gauss float64 = 0.577350269189626
	var order []int32 = []int32{1, 4, 2, 3}
	sign[0][0] = float64(-1)
	sign[0][1] = float64(-1)
	sign[1][0] = float64(-1)
	sign[1][1] = float64(+1)
	sign[2][0] = float64(+1)
	sign[2][1] = float64(-1)
	sign[3][0] = float64(+1)
	sign[3][1] = float64(+1)
	// vectors and matrices:
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	if Mode == 1 {
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, 4, 4)
			return rv
		}()) != 0 {
			goto memFree
		}
		femLocUtoU_e((*[1000000]tVector)(unsafe.Pointer(&u))[:], ePos, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], 0, 2, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], 0, 4, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], 0, 4, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:], 0, 4, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 0, 2, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 4, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	thick = femGetRSValPos(ePos, 3, 0)
	// D matrix:
	kxx = femGetMPValPos(ePos, 37, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 1, 1, kxx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 2, 2, kxx, 0)
	{
		// real coordinates:
		for i = 1; i <= 4; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
		}
	}
	// numerical integration:
	ipos = -1
	for i = 1; i <= 2; i++ {
		for j = 1; j <= 2; j++ {
			ipos++
			// int. point coordinates:
			x = gauss * sign[ipos][0]
			y = gauss * sign[ipos][1]
			weight_x = 1
			weight_y = 1
			// N matrix (derivatives)
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 1, y-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 2, -y+1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 3, y+1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 4, -y-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 1, x-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 2, -x-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 3, x+1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 4, -x+1, 0)
			femValMatMultSelf(0.25, (*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
			// G matrix (Jac inversion):
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
			for ii = 1; ii <= 4; ii++ {
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 2, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 1), 1)
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 1, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 2), 1)
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 2, -1*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 2), 1)
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 1, -1*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 1), 1)
			}
			detj = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 2) - femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 2)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 1)
			if detj <= 1e-17 {
				noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Invalid Jacobi matrix in element\x00"), eID[ePos])
				rv = -3
				goto memFree
			}
			femValMatMultSelf(1/detj, (*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
			// integration multiplier
			mult = detj * weight_x * weight_y * thick
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], (*[1000000]tMatrix)(unsafe.Pointer(&N))[:], (*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
			femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:], (*[1000000]tMatrix)(unsafe.Pointer(&B))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
			femValMatMultSelf(mult, (*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
			for ii = 1; ii <= 4; ii++ {
				for jj = 1; jj <= 4; jj++ {
					femMatPutAdd(K_e, ii, jj, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:], ii, jj), 1)
				}
			}
		}
	}
	if Mode == 1 {
		for jj = 1; jj <= 4; jj++ {
			if femTangentMatrix == 1 {
				femAddPutRepVal(ePos, 71, jj, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], order[jj-1]))
			} else {
				femAddPutRepVal(ePos, 71, jj, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], order[jj-1]))
			}
		}
		femMatVecMult(K_e, (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], Fe)
		femVecSetZero(Fre)
	}
memFree:
	;
	if Mode == 1 {
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	}
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&B))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Bt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BtD))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	return rv
}

// e020_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e020.c:200
func e020_mass(ePos int32, M_e []tMatrix) int32 {
	var rv int32
	var i int32
	var j int32
	var ii int32
	var jj int32
	var thick float64
	var ipos int32
	var x float64
	var y float64
	var weight_x float64
	var weight_y float64
	var detj float64
	var mult float64
	var sign [][]float64 = make([][]float64, 4)
	var BtDB tMatrix
	var N tMatrix
	var Nt tMatrix
	var NN tMatrix
	var NNt tMatrix
	var G tMatrix
	var xyz tMatrix
	var gauss float64 = 0.577350269189626
	sign[0][0] = float64(-1)
	sign[0][1] = float64(-1)
	sign[1][0] = float64(-1)
	sign[1][1] = float64(+1)
	sign[2][0] = float64(+1)
	sign[2][1] = float64(-1)
	sign[3][0] = float64(+1)
	sign[3][1] = float64(+1)
	// vectors and matrices:
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Nt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&NNt))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:], 0, 4, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 0, 1, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Nt))[:], 0, 4, 1, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], 0, 2, 4, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&NNt))[:], 0, 4, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 0, 2, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], 0, 4, 2, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	thick = femGetRSValPos(ePos, 3, 0)
	{
		// real coordinates:
		for i = 1; i <= 4; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 1, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_x, nLen), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], i, 2, femGetDblPos(femGetIntLPos(ePos, i-1, eFrom, eNodesL, eLenL), n_y, nLen), 0)
		}
	}
	// numerical integration:
	ipos = -1
	for i = 1; i <= 2; i++ {
		for j = 1; j <= 2; j++ {
			ipos++
			// int. point coordinates:
			// zeta
			x = gauss * sign[ipos][0]
			// eta
			y = gauss * sign[ipos][1]
			weight_x = 1
			weight_y = 1
			// N matrix (derivatives)
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 1, y-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 2, -y+1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 3, y+1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, 4, -y-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 1, x-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 2, -x-1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 3, x+1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, 4, -x+1, 0)
			femValMatMultSelf(0.25, (*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
			femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], []byte("N\x00"))
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], 1, 1, (1-x)*(2-y), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], 1, 2, (1+x)*(1-y), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], 1, 3, (1+x)*(1+y), 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], 1, 4, (1-x)*(1+y), 0)
			femValMatMultSelf(0.25, (*[1000000]tMatrix)(unsafe.Pointer(&NN))[:])
			femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], []byte("NN\x00"))
			// G matrix (Jac inversion):
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
			for ii = 1; ii <= 4; ii++ {
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 2, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 1), 1)
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 1, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 2), 1)
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 2, -1*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 1, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 2), 1)
				femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 1, -1*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&N))[:], 2, ii)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:], ii, 1), 1)
			}
			detj = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 1)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 2) - femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 1, 2)*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&G))[:], 2, 1)
			if detj <= 1e-17 {
				noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Invalid Jacobi matrix in element\x00"), eID[ePos])
				rv = -3
				goto memFree
			}
			// integration multiplier
			mult = detj * weight_x * weight_y * thick
			//femMatTran(&N, &Nt);
			//        femMatTran(&NN, &NNt);
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&NNt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&NN))[:], (*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
			femValMatMultSelf(mult, (*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
			for ii = 1; ii <= 4; ii++ {
				for jj = 1; jj <= 4; jj++ {
					femMatPutAdd(M_e, ii, jj, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:], ii, jj), 1)
				}
			}
		}
	}
	noarch.Fprintf(msgout, []byte("M_E (detj=%e)\n\x00"), detj)
	for i = 1; i <= 4; i++ {
		for j = 1; j <= 4; j++ {
			noarch.Fprintf(msgout, []byte("%e \x00"), femMatGet(M_e, i, j))
		}
		noarch.Fprintf(msgout, []byte("\n\x00"))
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&BtDB))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&N))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Nt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&NN))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&NNt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&G))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&xyz))[:])
	return rv
}

// e020_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e020.c:344
func e020_rvals(ePos int32) int32 {
	return 4
}

// e020_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e020.c:346
func e020_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// addElem_020 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e020.c:349
func addElem_020() int32 {
	var rv int32
	var type_ int32 = 20
	var dim int32
	var nodes int32 = 4
	var dofs int32 = 1
	var ndof []int32 = []int32{7}
	var rs int32 = 1
	var real_ []int32 = []int32{3}
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 1
	var nres_rp []int32 = []int32{71}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e020_stiff
	Elem[type_].mass = e020_mass
	Elem[type_].rvals = e020_rvals
	Elem[type_].eload = e020_eload
	Elem[type_].res_p_loc = e005_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e005_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e021_geom_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:31
func e021_geom_matrix(ePos int32, Mode int32, L float64, K_s []tMatrix) int32 {
	//
	//   File name: fem_e021.c
	//   Date:      Tue Mar 26 11:40:43 CET 2013
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2013  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Element 021 (2D link contact element)
	//
	return 0
}

// e021_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:32
func e021_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	return 0
}

// e021_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:33
func e021_mass(ePos int32, M_e []tMatrix) int32 {
	return 0
}

// e021_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:34
func e021_volume(ePos int32, val []float64) int32 {
	return 0
}

// e021_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:35
func e021_rvals(ePos int32) int32 {
	return 4
}

// e021_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:36
func e021_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// addElem_021 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e021.c:38
func addElem_021() int32 {
	var rv int32
	var type_ int32 = 21
	var dim int32 = 1
	var nodes int32 = 2
	var dofs int32 = 2
	var ndof []int32 = []int32{1, 2}
	var rs int32 = 2
	var real_ []int32 = []int32{27, 28}
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 2
	var nres_rp []int32 = []int32{1, 2}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e021_stiff
	Elem[type_].mass = e021_mass
	Elem[type_].rvals = e021_rvals
	Elem[type_].eload = e021_eload
	Elem[type_].res_p_loc = e003_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e021_volume
	Elem[type_].therm = e000_therm
	return rv
}

// e022_geom_matrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:31
func e022_geom_matrix(ePos int32, Mode int32, L float64, K_s []tMatrix) int32 {
	//
	//   File name: fem_e022.c
	//   Date:      Tue Mar 26 11:40:43 CET 2013
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2013  Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02239, USA.
	//
	// FEM Solver - Element 022 (2D link target element)
	//
	return 0
}

// e022_stiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:32
func e022_stiff(ePos int32, Mode int32, K_e []tMatrix, F_e []tVector, Fr_e []tVector) int32 {
	return 0
}

// e022_mass - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:33
func e022_mass(ePos int32, M_e []tMatrix) int32 {
	return 0
}

// e022_volume - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:34
func e022_volume(ePos int32, val []float64) int32 {
	return 0
}

// e022_rvals - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:35
func e022_rvals(ePos int32) int32 {
	return 4
}

// e022_eload - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:36
func e022_eload(ePos int32, mode int32, F_e []tVector) int32 {
	return 0
}

// e022_res_p_loc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:39
func e022_res_p_loc(ePos int32, point int32, x []float64, y []float64, z []float64) int32 {
	var x1 float64
	var x2 float64
	var y1 float64
	var y2 float64
	x1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	y1 = femGetDblPos(femGetIntLPos(ePos, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	x2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_x, nLen)
	y2 = femGetDblPos(femGetIntLPos(ePos, 1, eFrom, eNodesL, eLenL), n_y, nLen)
	switch point {
	case 1:
		x[0] = x1
		y[0] = y1
	case 2:
		x[0] = x2
		y[0] = y2
	default:
		x[0] = 0.5 * (x1 + x2)
		y[0] = 0.5 * (y1 + y2)
		break
	}
	z[0] = 0
	return 0
}

// addElem_022 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_e022.c:69
func addElem_022() int32 {
	var rv int32
	var type_ int32 = 22
	var dim int32 = 1
	var nodes int32 = 2
	var dofs int32 = 2
	var ndof []int32 = []int32{1, 2}
	var rs int32 = 2
	var real_ []int32 = []int32{27, 28}
	var rs_rp int32
	var real_rp []int32
	var res int32
	var nres []int32
	var res_rp int32 = 2
	var nres_rp []int32 = []int32{1, 2}
	if type_ != femAddElem(type_) {
		return -3
	}
	Elem[type_].dim = dim
	Elem[type_].nodes = nodes
	Elem[type_].dofs = dofs
	Elem[type_].ndof = ndof
	Elem[type_].rs = rs
	Elem[type_].real_ = real_
	Elem[type_].rs_rp = rs_rp
	Elem[type_].real_rp = real_rp
	Elem[type_].res = res
	Elem[type_].nres = nres
	Elem[type_].res_rp = res_rp
	Elem[type_].nres_rp = nres_rp
	Elem[type_].stiff = e022_stiff
	Elem[type_].mass = e022_mass
	Elem[type_].rvals = e022_rvals
	Elem[type_].eload = e022_eload
	Elem[type_].res_p_loc = e003_res_p_loc
	Elem[type_].res_node = e000_res_node
	Elem[type_].volume = e022_volume
	Elem[type_].therm = e000_therm
	return rv
}

// femSolveEigenInvIter - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eige.c:77
func femSolveEigenInvIter(max_iter int32, eps float64) int32 {
	//
	//   File name: fem_eige.c
	//   Date:      2007/10/22 15:47
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2007 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM solver: Eigenproblem solver
	//
	// from fem_sol.c:
	// total number of ACTIVE DOFs in structure (== size of "K" matrix)
	// lenght of nDOFfld
	// description of DOFs in nodes
	// numbers of items in "K" rows K_rows[nDOFAct]
	// K_rows for full ALM
	// structure stiffness matrix
	// structure load vector
	// unballanced forces vector
	// structure displacement vector
	// structure displacement vector - total displacements (NRM)
	// substep displacement vector for ALM
	// substep unballanced displacement vector for ALM
	// substep unballanced displacement vector for ALM
	// substep unballanced displacement vector for ALM
	// step sum of unballanced forces for full ALM
	// whole load vector full ALM
	// structure and step matrix for full ALM
	// displacement and lambda vectro for full ALM
	// load and arc lenght vector for full ALM
	// dynamics:
	// structure mass matrix
	// eigensolver
	// vector of eigenvalues
	// i-th iteration vector of eigenvalues
	// i-th iteration vector of eigenvalues
	// matrix of eigenvectors
	// FIELD of Gram-Schmidt data
	// Computation of eigenvalues and eigenvectors for dynamics: version 2
	// * according to Bathe and Wilson
	// * @return status value
	//
	var rv int32 = -3
	var i int32
	var j int32
	var jj int32
	var om_top float64
	var om_bot float64
	var omega float64
	var omega0 float64
	var c float64
	noarch.Fprintf(msgout, []byte("[I] %s:\n\x00"), []byte("Eigensolver started (inv. iter.)\x00"))
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		// stuff initializations
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	if (func() int32 {
		rv = fem_fill_K(0)
		return rv
	}()) != 0 {
		goto memFree
	}
	// initial approximation
	omega0 = 0
	omega = 0
	for i = 1; i <= nDOFAct; i++ {
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u))[:], i, 1, 0)
	}
	if (func() int32 {
		rv = fem_fill_M()
		return rv
	}()) != 0 {
		// mass matrix
		goto memFree
	}
	if (func() int32 {
		rv = fem_add_disps(1, 0)
		return rv
	}()) != 0 {
		goto memFree
	}
	// initial z1
	femMatVecMultBig((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
	{
		// main loop:
		for j = 1; j <= femEigenNum; j++ {
			// initial return value
			rv = -3
			solID = j
			if j > 1 {
				// initial approx.
				for jj = 0; jj < u.rows; jj++ {
					u.data[jj] *= float64(noarch.Int32() * 1000)
				}
			}
			for i = 0; i < max_iter; i++ {
				if j > 1 {
					// Gram-Schmidt:
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
					femMatVecMultBig((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
					for jj = 0; jj < j-1; jj++ {
						c = femVecVecMultBig(eig_y[jj:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
						femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], c, eig_y[jj:])
					}
					femVecLinCombBig(1, (*[1000000]tVector)(unsafe.Pointer(&u))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&Fr))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
					// eig_xM = z1 for j>=2
					femMatVecMultBig((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
				}
				if (func() int32 {
					rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/1e+06, 3*nDOFAct)
					return rv
				}()) != 0 {
					// u = xx(k+1)
					goto memFree
				}
				// eig_x = zz(k+1)
				femMatVecMultBig((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_x))[:])
				// omega(k+1) =  (xx(k+1)*z(k))/(zz(k+1)*xx(k+1)):
				om_top = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
				om_bot = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_x))[:])
				if math.Abs(om_bot) < 1e-17*1e-17 {
					noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Inverse iteration failed - can not compute omega\x00"))
					goto memFree
				}
				// eigenvalue
				omega = om_top / om_bot
				femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
				// z(k+1)
				femValVecMult(1/math.Sqrt(om_bot), (*[1000000]tVector)(unsafe.Pointer(&eig_x))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
				// eigenvector:
				femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
				if (func() int32 {
					rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/1000, 3*nDOFAct)
					return rv
				}()) != 0 {
					// xx(k+1)
					goto memFree
				}
				if i > 0 {
					if math.Abs(omega-omega0)/omega <= math.Pow(10, -2*eps) {
						noarch.Fprintf(msgout, []byte("[i] %s [%li]: %f (%s %li)\n\x00"), []byte("  Eigenvalue\x00"), j, math.Sqrt(math.Abs(omega))/(2*3.141592653589793), []byte("in iteration\x00"), i+1)
						// we are converged
						rv = 0
						break
					}
				}
				omega0 = omega
			}
			if rv != 0 {
				noarch.Fprintf(msgout, []byte("[E] %s %li %s!\n\x00"), []byte("Computation of eigenvalue no.\x00"), j, []byte("failed\x00"))
				goto memFree
			}
			// frequency
			solSimNum = math.Sqrt(math.Abs(omega)) / (2 * 3.141592653589793)
			if j == 1 {
				if (func() int32 {
					rv = femWriteRes(fem_output_file())
					return rv
				}()) != 0 {
					// first eigenvector
					goto memFree
				}
			}
			if len(femSubStepFname(j)) != 0 {
				if (func() int32 {
					rv = femWriteRes(femSubStepFname(j))
					return rv
				}()) != 0 {
					// all eigenvectors ("-osf NAME")
					goto memFree
				}
			}
			if j == femEigenNum {
				// we are finished
				break
			}
			// prepare next Gram-Schmidt HERE:
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], eig_y[j-1:])
		}
	}
memFree:
	;
	// end "j": multiple eigenvalues
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// femTriEigLU - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eige.c:237
func femTriEigLU(alpha []tVector, beta []tVector, gamma []tVector) int32 {
	// ############################################################
	// Lanczos method attempt
	//
	// * This is function solves eigenvalues for tridiagonal matrix.
	// * Algoritm is based on LU decoposition. A = LU, A_{i+1} = UL
	// * @param alpha diagonal elements (on output eigenvalues)
	// * @param beta  1st U-subdigonal (will bee destroyed)
	// * @param gamma 1st L-subdiagonal (will bee destroyed)
	// * @return error code.
	//
	var rv int32
	var P tVector
	var R tVector
	var i int32
	var j int32
	var n int32
	var norm float64
	n = alpha[0].rows
	if n < 1 {
		rv = -12
		goto memFree
	}
	for i = 1; i <= n; i++ {
		noarch.Printf([]byte(" %2.4e   %2.4e   %2.4e\n\x00"), femVecGet(beta, i), femVecGet(alpha, i), femVecGet(gamma, i))
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&P))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&R))[:])
	if (func() int32 {
		rv = noarch.BoolToInt(femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&P))[:], 0, n, n) != 0)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = noarch.BoolToInt(femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&R))[:], 0, n, n) != 0)
		return rv
	}()) != 0 {
		goto memFree
	}
	norm = femVecNormBig(beta)
	// only for counting of steps
	j = 0
	for norm > 0.0001 {
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&P))[:], 1, femVecGet(alpha, 1), 0)
		{
			// not to n?
			for i = 1; i < n; i++ {
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&R))[:], i, femVecGet(beta, i)/femVecGet((*[1000000]tVector)(unsafe.Pointer(&P))[:], i), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&P))[:], i+1, femVecGet(alpha, i+1)-femVecGet(gamma, i)*femVecGet((*[1000000]tVector)(unsafe.Pointer(&R))[:], i), 0)
				femVecPutAdd(alpha, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&P))[:], i)+femVecGet(gamma, i)*femVecGet((*[1000000]tVector)(unsafe.Pointer(&R))[:], i), 0)
				femVecPutAdd(beta, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&R))[:], i)*femVecGet((*[1000000]tVector)(unsafe.Pointer(&P))[:], i+1), 0)
			}
		}
		femVecPutAdd(alpha, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&P))[:], i), 0)
		norm = femVecNormBig(beta)
		j++
		noarch.Fprintf(msgout, []byte("EIG-LU STEP: %li\n\x00"), j)
	}
	femVecPrn(alpha, []byte("EIGENVALUES\x00"))
	if n > 4 {
		n = 4
	}
	for i = 1; i <= n; i++ {
		noarch.Printf([]byte("a[%4li] = %e\n\x00"), i, femVecGet(alpha, i))
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&P))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&R))[:])
	return rv
}

// femEigLanczos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eige.c:314
func femEigLanczos(K []tMatrix, M []tMatrix, k int32, eigval []tVector) int32 {
	// Lanczos method
	// *
	//
	var rv int32
	var r tVector
	var rr tVector
	var rrr tVector
	var q tVector
	var q1 tVector
	var p tVector
	var pp tVector
	var s tVector
	var a tVector
	var b tVector
	var c tVector
	var beta float64
	var alpha float64
	var betadiv float64
	var n int32
	var i int32
	n = K[0].rows
	if n < 1 {
		rv = -12
		goto memFree
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&rr))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&rrr))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&q))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&q1))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&s))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&a))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&b))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&c))[:])
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rr))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rrr))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&q))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&q1))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&p))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&s))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&a))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&b))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&c))[:], 0, n, n)
	{
		// Preparations:
		for i = 1; i <= n; i++ {
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&r))[:], i, 0.001*float64(noarch.Int32()), 0)
		}
	}
	femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&q1))[:])
	// TODO: {Kg} = {K} - sigma*{M}
	// beta = sqrt({r}^T.[M].{r})
	femMatVecMultBig(M, (*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&s))[:])
	beta = math.Sqrt(femVecVecMult((*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&s))[:]))
	if beta == 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Eigenvalue solver stopped: beta = 0 not allowed\x00"))
		rv = -3
		goto memFree
	}
	// {q} = {r} / beta
	betadiv = 1 / beta
	femValVecMult(betadiv, (*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&q))[:])
	// {p} = {M}*{q}
	femMatVecMultBig(M, (*[1000000]tVector)(unsafe.Pointer(&q))[:], (*[1000000]tVector)(unsafe.Pointer(&p))[:])
	{
		// Main loop for "k" eigenvectors:
		for i = 1; i <= k; i++ {
			// {Kg}*{rr} = {p}
			femEqsCGwJ(K, (*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&rr))[:], 1e-08, 3*n)
			// {rrr} = {rr} - {q1} * beta
			femVecLinCombBig(1, (*[1000000]tVector)(unsafe.Pointer(&rr))[:], -1*beta, (*[1000000]tVector)(unsafe.Pointer(&q1))[:], (*[1000000]tVector)(unsafe.Pointer(&rrr))[:])
			// alpha = {p}^T*{rrr}
			alpha = femVecVecMult((*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&rrr))[:])
			// {r} = {rrr} - alpha*{q}
			femVecLinCombBig(1, (*[1000000]tVector)(unsafe.Pointer(&rrr))[:], -1*alpha, (*[1000000]tVector)(unsafe.Pointer(&q))[:], (*[1000000]tVector)(unsafe.Pointer(&r))[:])
			// {pp} = {M} * {r}
			femMatVecMultBig(M, (*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&pp))[:])
			if i == 1 {
				// Fill tridiagonal matrix:
				// first line
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&a))[:], 1, alpha, 0)
			} else {
				// normal line
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&a))[:], i, alpha, 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&c))[:], i-1, beta, 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&b))[:], i, beta, 0)
			}
			noarch.Printf([]byte("Lanczos [%li]: a=%e b=%e\n\x00"), i, alpha, beta)
			// beta = sqrt({pp}^T * {r})
			beta = math.Sqrt(femVecVecMult((*[1000000]tVector)(unsafe.Pointer(&pp))[:], (*[1000000]tVector)(unsafe.Pointer(&r))[:]))
			if i == k {
				// check for the last step
				break
			}
			// only for non-last steps:
			betadiv = 1 / beta
			// {q}  = {r} / beta
			femValVecMult(betadiv, (*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&q))[:])
			// {p}  = {pp} / beta
			femValVecMult(betadiv, (*[1000000]tVector)(unsafe.Pointer(&pp))[:], (*[1000000]tVector)(unsafe.Pointer(&p))[:])
			// q(i-1):
			femVecClone((*[1000000]tVector)(unsafe.Pointer(&q))[:], (*[1000000]tVector)(unsafe.Pointer(&q1))[:])
		}
	}
	fmt.Printf("CCCCCCCCCCCCCCCCCCCCCCCCCC\n")
	rv = femTriEigLU((*[1000000]tVector)(unsafe.Pointer(&a))[:], (*[1000000]tVector)(unsafe.Pointer(&b))[:], (*[1000000]tVector)(unsafe.Pointer(&c))[:])
	fmt.Printf("CCCCCCCCCCCCCCCCCCCCCCCCCC\n")
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&rr))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&rrr))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&q))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&q1))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&s))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&a))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&b))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&c))[:])
	return rv
}

// femSolveEigenLanczos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eige.c:445
func femSolveEigenLanczos(max_iter int32, eps float64) int32 {
	var rv int32 = -3
	var i int32
	var j int32
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	if (func() int32 {
		rv = fem_fill_K(0)
		return rv
	}()) != 0 {
		goto memFree
	}
	{
		// initial approximation
		for i = 1; i <= nDOFAct; i++ {
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u))[:], i, 1, 0)
		}
	}
	if (func() int32 {
		rv = fem_add_disps(1, 0)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_fill_M()
		return rv
	}()) != 0 {
		// mass matrix
		goto memFree
	}
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], []byte("MASS\x00"))
	rv = femEigLanczos((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M))[:], femEigenNum, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	for j = 1; j <= femEigenNum; j++ {
	}
memFree:
	;
	// end "j": multiple eigenvalues
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// femElemTypeInit - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eini.c:56
func femElemTypeInit() int32 {
	//
	//   File name: fem_eini.c
	//   Date:      2003/04/12 15:26
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - element type initialization
	//
	//  $Id: fem_eini.c,v 1.15 2005/07/11 17:56:16 jirka Exp $
	//
	var rv int32
	if (func() int32 {
		rv = addElem_000()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_001()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_002()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_003()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_004()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_005()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_006()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_007()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_008()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_009()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_010()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_011()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_012()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_013()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_014()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_015()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_016()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_017()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_018()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_019()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_020()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_021()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addElem_022()
		return rv
	}()) != 0 {
		goto memFree
	}
	if rv == 0 {
		return rv
	}
memFree:
	;
	noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Element type initialization failed\x00"))
	noarch.Exit(rv)
	return rv
}

// Elem - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_elem.c:34
//
//   File name: fem_elem.c
//   Date:      2003/04/09 11:44
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - element definition
//
//  $Id: fem_elem.c,v 1.6 2003/08/02 18:37:52 jirka Exp $
//
// Included headers:
// definitions of data structures
// elements
var Elem []tElem

// elemLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_elem.c:35
// number of elements
var elemLen int32

// femAddElem - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_elem.c:41
func femAddElem(type_ int32) int32 {
	// Adds new (empty) element structure
	// * @param type element type number
	// * @return element type number (or value >= 0 on error)
	//
	var tmpElem []tElem
	var i int32
	if type_ != elemLen {
		noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Incorrect element type number\x00"), type_)
		return -3
	}
	if len((func() []tElem {
		tmpElem = (*[1000000]tElem)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := make([]byte, uint32(elemLen+1)*uint32(1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		return tmpElem
	}())) == 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Out of memory during element type preparing\x00"))
		return -4
	}
	if elemLen > 0 {
		for i = 0; i < elemLen; i++ {
			tmpElem[i] = Elem[i]
		}
	}
	_ = Elem
	Elem = nil
	Elem = tmpElem
	tmpElem = nil
	Elem[elemLen].type_ = type_
	Elem[elemLen].nodes = 0
	Elem[elemLen].dofs = 0
	Elem[elemLen].ndof = nil
	Elem[elemLen].rs = 0
	Elem[elemLen].real_ = nil
	Elem[elemLen].rs_rp = 0
	Elem[elemLen].real_rp = nil
	Elem[elemLen].res = 0
	Elem[elemLen].nres = nil
	Elem[elemLen].res_rp = 0
	Elem[elemLen].nres_rp = nil
	Elem[elemLen].stiff = nil
	Elem[elemLen].mass = nil
	Elem[elemLen].rvals = nil
	Elem[elemLen].eload = nil
	Elem[elemLen].therm = nil
	elemLen++
	return Elem[elemLen-1].type_
}

// femElemIPoints - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_elem.c:100
func femElemIPoints(ePos int32) int32 {
	// Computes number of element internal (integration) points
	// * param ePos element position
	//
	var num int32
	var eT int32
	eT = femGetIntPos(ePos, eType, eLen)
	if Elem[eT].res_rp > 0 {
		num = (Elem[eT].rvals(ePos) - Elem[eT].res) / Elem[eT].res_rp
	}
	if Elem[eT].res > 0 {
		num++
	}
	return num
}

// eqsCompResid - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:37
func eqsCompResid(a []tMatrix, x []tVector, b []tVector, r []tVector) int32 {
	//
	//   File name: fem_eqs.c
	//   Date:      2003/04/13 10:38
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - linear equation system solver(s)
	//
	//  $Id: fem_eqs.c,v 1.13 2005/07/11 17:56:16 jirka Exp $
	//
	// Computes r = A.x - b
	// * @param a matrix
	// * @param x results
	// * @param b right-side
	// * @param r computed residuum vector
	// * @return state value
	//
	var i int32
	var j int32
	if a[0].cols != b[0].rows || b[0].rows != x[0].rows || x[0].rows != r[0].rows {
		return -9
	}
	if b[0].type_ != 0 || x[0].type_ != 0 || r[0].type_ != 0 {
		return -5
	}
	if a[0].type_ == 1 {
		for i = 0; i < a[0].rows; i++ {
			r[0].data[i] = 0 - b[0].data[i]
			for j = a[0].frompos[i]; j < a[0].frompos[i]+a[0].defpos[i]; j++ {
				if a[0].pos[j] <= 0 {
					break
				}
				r[0].data[i] += a[0].data[j] * x[0].data[a[0].pos[j]-1]
			}
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			femVecPutAdd(r, i, 0-femVecGet(b, i), 0)
			for j = 1; j < a[0].cols; j++ {
				femVecPutAdd(r, i, femMatGet(a, i, j)*femVecGet(x, j), 1)
			}
		}
	}
	return 0
}

// femEqsCGwJ - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:88
func femEqsCGwJ(a []tMatrix, b []tVector, x []tVector, eps float64, maxIt int32) int32 {
	// Conjugate gradient method with Jacobi preconditioner
	// *  (for symetric matrices only!)
	// *  @param a      matrix
	// *  @param b      "load" vector
	// *  @param x      results (vector - given as first iteration)
	// *  @param eps    error (min.)
	// *  @param maxIt  max. number of iterations
	// *  @return state value
	//
	// Jacobi preconditioner (diag[A] ;-)
	var M tVector
	var r tVector
	var z tVector
	var p tVector
	var q tVector
	var ro float64
	var alpha float64
	var beta float64
	var roro float64
	var n int32
	var i int32
	var j int32
	var rv int32
	var converged int32
	var normRes float64
	var normX float64
	var normA float64
	var normB float64
	if a[0].cols != x[0].rows || x[0].rows != b[0].rows {
		return -9
	}
	n = a[0].rows
	normA = femMatNormBig(a)
	normB = femVecNormBig(b)
	if normB <= 0 {
		femVecSetZeroBig(x)
		noarch.Fprintf(msgout, []byte("[ ]  %s!\n\x00"), []byte("solution done without iterations because of zero load\x00"))
		return 0
	}
	// vector initialization
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&z))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&q))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&M))[:], 0, n, n)
		return rv
	}()) != 0 {
		// memory allocation
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&z))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&p))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&q))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	{
		// Jacobi preconditioner creation:
		for i = 1; i <= n; i++ {
			M.data[i-1] = femMatGet(a, i, i)
			if math.Abs(M.data[i-1]) < 1e-17 {
				rv = -13
				noarch.Fprintf(msgout, []byte("[ ]   %s[%li][%li] %s: %e\n\x00"), []byte("matrix member\x00"), i, i, []byte("has zero size\x00"), M.data[i-1])
				goto memFree
			}
		}
	}
	// next two lines mean: r = b - A*x
	femMatVecMultBig(a, x, (*[1000000]tVector)(unsafe.Pointer(&r))[:])
	for i = 0; i < n; i++ {
		r.data[i] = b[0].data[i] - r.data[i]
	}
	{
		// main loop
		for i = 1; i <= maxIt; i++ {
			noarch.Fprintf(msgout, []byte("[ ]   %s %li\n\x00"), []byte("linear step\x00"), i)
			{
				// using preconditioner:
				for j = 0; j < n; j++ {
					z.data[j] = r.data[j] / M.data[j]
				}
			}
			ro = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&z))[:])
			noarch.Fprintf(msgout, []byte("ro = %f\n\x00"), ro)
			if i == 1 {
				for j = 0; j < n; j++ {
					p.data[j] = z.data[j]
				}
			} else {
				beta = ro / roro
				noarch.Fprintf(msgout, []byte("beta = %f\n\x00"), beta)
				for j = 0; j < n; j++ {
					p.data[j] = z.data[j] + beta*p.data[j]
				}
			}
			femMatVecMultBig(a, (*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&q))[:])
			alpha = ro / femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&q))[:])
			noarch.Fprintf(msgout, []byte("alpha = %f\n\x00"), alpha)
			for j = 0; j < n; j++ {
				x[0].data[j] = x[0].data[j] + alpha*p.data[j]
				r.data[j] = r.data[j] - alpha*q.data[j]
			}
			// Convergence testing
			normRes = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&r))[:])
			normX = femVecNormBig(x)
			if normRes <= eps*(normA*normX+normB) {
				// convergence test
				//if (fabs(norm - norm0) < eps )
				converged = 1
				noarch.Fprintf(msgout, []byte("[ ]  %s %li %s!\n\x00"), []byte("linear solution done in\x00"), i, []byte("iterations\x00"))
				break
			}
			noarch.Fprintf(msgout, []byte("[i] Convergence test %f < %f (step %li from %li)\n\x00"), normRes, eps*(normA*normX+normB), i, maxIt)
			roro = ro
		}
	}
	if converged != 1 {
		// end of main loop
		//fprintf(msgout,"[I] normRes = %f\n",normRes);
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("unconverged solution\x00"))
		rv = -1
	}
memFree:
	;
	// freeing memory:
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&z))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&q))[:])
	return rv
}

// femEqsBiCCSwJ - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:262
func femEqsBiCCSwJ(a []tMatrix, b []tVector, x []tVector, eps float64, maxIt int32) int32 {
	// Bi-Conjugate Gradient Stabilized Method with Jacobi preconditioner
	// *  (for symetric and non-symetric matrices)
	// *  @param a      matrix
	// *  @param b      "load" vector
	// *  @param x      results (vector - given as first iteration)
	// *  @param eps    error (min.)
	// *  @param maxIt  max. number of iterations
	// *  @return state value
	// *
	// *  Note: "res" is probably useless and *NormBig(res) can be replaced by *NormBig(r).
	// *  Test it!!
	// *
	//
	// preconditioner (diag[a])
	var M tVector
	var r tVector
	var rr tVector
	var p tVector
	var pp tVector
	var s tVector
	var ss tVector
	var t tVector
	var v tVector
	var ro float64
	var beta float64
	var roro float64
	var alpha float64
	var omega float64
	var i int32
	var j int32
	// size of matrix "a"
	var n int32
	var converged int32
	// residuum
	var res tVector
	// norms
	var normRes float64
	var normX float64
	var normA float64
	var normB float64
	var rv int32
	n = a[0].rows
	normA = femMatNormBig(a)
	normX = femVecNormBig(x)
	normB = femVecNormBig(b)
	// vector initialization
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&rr))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&s))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&ss))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&t))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&v))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&res))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&M))[:], 0, n, n)
		return rv
	}()) != 0 {
		// memory allocation
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rr))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&p))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&s))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&ss))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&t))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&v))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&res))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	{
		// Jacobi preconditioner creation:
		for i = 1; i <= n; i++ {
			M.data[i-1] = femMatGet(a, i, i)
			if math.Abs(M.data[i-1]) < 1e-17 {
				rv = -13
				noarch.Fprintf(msgout, []byte("[ ]   %s[%li][%li] %s: %e\n\x00"), []byte("matrix member\x00"), i, i, []byte("has zero size\x00"), M.data[i-1])
				goto memFree
			}
		}
	}
	// next two lines mean: r = b - A*x
	femMatVecMultBig(a, x, (*[1000000]tVector)(unsafe.Pointer(&r))[:])
	for i = 0; i < n; i++ {
		r.data[i] = b[0].data[i] - r.data[i]
		rr.data[i] = r.data[i]
	}
	if femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&r))[:]) <= 1e-17 {
		// convergence test
		converged = 1
		goto memFree
	}
	{
		// main loop
		for i = 1; i <= maxIt; i++ {
			noarch.Fprintf(msgout, []byte("[ ]   %s %li\n\x00"), []byte("linear step\x00"), i)
			ro = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&rr))[:], (*[1000000]tVector)(unsafe.Pointer(&r))[:])
			if math.Abs(ro) <= 0 {
				noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("solution interrupted on zero value\x00"))
				goto memFree
			}
			if i == 1 {
				// in first iteration
				for j = 0; j < n; j++ {
					p.data[j] = r.data[j]
				}
			} else {
				// int all iterations except first
				beta = ro / roro * (alpha / omega)
				for j = 0; j < n; j++ {
					p.data[j] = r.data[j] + beta*(p.data[j]-omega*v.data[j])
				}
			}
			{
				// using preconditioner M.pp=p -> pp
				for j = 0; j < n; j++ {
					pp.data[j] = p.data[j] / M.data[j]
				}
			}
			femMatVecMultBig(a, (*[1000000]tVector)(unsafe.Pointer(&pp))[:], (*[1000000]tVector)(unsafe.Pointer(&v))[:])
			alpha = ro / femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&rr))[:], (*[1000000]tVector)(unsafe.Pointer(&v))[:])
			for j = 0; j < n; j++ {
				s.data[j] = r.data[j] - alpha*v.data[j]
			}
			if femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&s))[:]) <= 1e-17 {
				{
					// test of "s" size
					for j = 0; j < n; j++ {
						x[0].data[j] += alpha * pp.data[j]
					}
				}
				converged = 1
				noarch.Fprintf(msgout, []byte("[ ]  %s %li %s!\n\x00"), []byte("linear solution done in\x00"), i, []byte("iterations\x00"))
				break
			}
			{
				// using preconditioner M.ss=s -> ss
				for j = 0; j < n; j++ {
					ss.data[j] = s.data[j] / M.data[j]
				}
			}
			femMatVecMultBig(a, (*[1000000]tVector)(unsafe.Pointer(&ss))[:], (*[1000000]tVector)(unsafe.Pointer(&t))[:])
			omega = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&t))[:], (*[1000000]tVector)(unsafe.Pointer(&s))[:]) / femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&t))[:], (*[1000000]tVector)(unsafe.Pointer(&t))[:])
			for j = 0; j < n; j++ {
				x[0].data[j] += alpha*pp.data[j] + omega*ss.data[j]
				r.data[j] = s.data[j] - omega*t.data[j]
			}
			roro = ro
			// Convergence testing
			eqsCompResid(a, b, x, (*[1000000]tVector)(unsafe.Pointer(&res))[:])
			normRes = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&res))[:])
			normX = femVecNormBig(x)
			if normRes < eps*(normA*normX+normB) {
				converged = 1
				noarch.Fprintf(msgout, []byte("[ ]  %s %li %s!\n\x00"), []byte("solution done in\x00"), i, []byte("iterations\x00"))
				break
			}
		}
	}
	if converged != 1 {
		// end of main loop
		noarch.Fprintf(msgout, []byte("[E] BiCGS: %s!\n\x00"), []byte("unconverged solution\x00"))
	}
memFree:
	;
	// freeing of memory:
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&rr))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&s))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&ss))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&t))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&v))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&res))[:])
	return 0
}

// femEqsLU - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:482
func femEqsLU(a []tMatrix, b []tVector, x []tVector, eps float64, maxIt int32) int32 {
	// Solver that uses LU - for full matrices!
	// *  @param a      matrix
	// *  @param b      "load" vector
	// *  @param x      results (vector - given as first iteration)
	// *  @param eps    error (min.)
	// *  @param maxIt  max. number of iterations
	// *  @return state value
	// *
	// *  Note: "res" is probably useless and *NormBig(res) can be replaced by *NormBig(r).
	// *  Test it!!
	// *
	//
	var rv int32
	var n int32
	var indx tVector
	if (func() int32 {
		n = a[0].rows
		return n
	}()) <= 0 {
		return -9
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&indx))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&indx))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femLUdecomp(a, (*[1000000]tVector)(unsafe.Pointer(&indx))[:])
		return rv
	}()) != 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("LU decomposition failed\x00"))
		goto memFree
	}
	if (func() int32 {
		rv = femLUback(a, (*[1000000]tVector)(unsafe.Pointer(&indx))[:], b)
		return rv
	}()) != 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Backward run of LU failed\x00"))
		goto memFree
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&indx))[:])
	return rv
}

// femEqsPCGwJ - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:514
func femEqsPCGwJ(a []tMatrix, b []tVector, x []tVector, eps float64, maxIt int32) int32 {
	// Alternative version of the Conjugate Gradient Method ()
	var rv int32
	var converged int32
	var nui float64
	var dei float64
	var lambda float64
	var alpha float64
	// norms
	var normRes float64
	var normX float64
	var normA float64
	var normB float64
	var p tVector
	var r tVector
	var d tVector
	// Jacobi preconditioner
	var M tVector
	// a*p result vector
	var ap tVector
	// number of rows
	var n int32
	var i int32
	var j int32
	if a[0].rows != x[0].rows || x[0].rows != b[0].rows {
		return -9
	}
	n = a[0].rows
	normA = femMatNormBig(a)
	normB = femVecNormBig(b)
	normX = femVecNormBig(x)
	if normB <= 0 {
		femVecSetZeroBig(x)
		noarch.Fprintf(msgout, []byte("[ ]  %s!\n\x00"), []byte("solution done without iterations because of zero load\x00"))
		return 0
	}
	// vector initializations
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&d))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&ap))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&p))[:], 0, n, n)
		return rv
	}()) != 0 {
		// memory allocation
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&d))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&M))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&ap))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	{
		// Jacobi preconditioner
		for i = 1; i <= n; i++ {
			M.data[i-1] = femMatGet(a, i, i)
			if math.Abs(M.data[i-1]) < 1e-17 {
				rv = -13
				noarch.Fprintf(msgout, []byte("[ ]   %s[%li][%li] %s: %e\n\x00"), []byte("matrix member\x00"), i, i, []byte("has zero size\x00"), M.data[i-1])
				goto memFree
			}
		}
	}
	// next several lines mean: r = b - A*x
	femMatVecMultBig(a, x, (*[1000000]tVector)(unsafe.Pointer(&r))[:])
	for i = 0; i < n; i++ {
		r.data[i] = b[0].data[i] - r.data[i]
	}
	{
		// using preconditioner:
		for j = 0; j < n; j++ {
			d.data[j] = r.data[j] / M.data[j]
			p.data[j] = d.data[j]
		}
	}
	for i = 1; i <= maxIt; i++ {
		noarch.Fprintf(msgout, []byte("[ ]   %s %li (%s %li)\n\x00"), []byte("linear step\x00"), i, []byte("from\x00"), maxIt)
		// untested code follows...
		femMatVecMultBig(a, (*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&ap))[:])
		nui = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&d))[:])
		dei = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&ap))[:])
		lambda = nui / dei
		noarch.Printf([]byte("NUI = %f DEI = %f LAMBDA = %f\n\x00"), nui, dei, lambda)
		for j = 0; j < n; j++ {
			x[0].data[j] += lambda * p.data[j]
			r.data[j] = r.data[j] - lambda*ap.data[j]
			d.data[j] = r.data[j] / M.data[j]
		}
		normRes = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&r))[:])
		normX = femVecNormBig(x)
		nui = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&d))[:])
		dei = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&ap))[:])
		noarch.Printf([]byte("NORMS: A=%f X=%f B=%f <> R=%f\n\x00"), normA, normX, normB, normRes)
		if normRes < eps*(normA*normX+normB) {
			// convergence test
			converged = 1
			noarch.Fprintf(msgout, []byte("[ ]  %s %li %s!\n\x00"), []byte("solution done in\x00"), i, []byte("iterations\x00"))
			break
		}
		alpha = nui / dei
		for j = 0; j < n; j++ {
			p.data[j] = d.data[j] + alpha*p.data[j]
		}
	}
	// end of "for i"
	femVecPrn(x, []byte("X\x00"))
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&d))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&ap))[:])
	return rv
}

// femMatCholFact - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:660
func femMatCholFact(a []tMatrix, C []tVector) int32 {
	// Choleski decomposition - forward run only!
	// * @param a matrix (must  be a MAT_FULL)
	// * @return status
	//
	var rv int32
	var sum float64
	var n int32
	var i int32
	var j int32
	var k int32
	var have_C int32
	n = a[0].rows
	if len(C) != 0 {
		if C[0].rows != a[0].rows {
			return -3
		} else {
			have_C = 1
		}
	}
	if have_C == 0 {
		femVecNull(C)
		if femVecAlloc(C, 0, n, n) != 0 {
			goto memFree
		}
	}
	for i = 1; i <= n; i++ {
		for j = i; j <= n; j++ {
			sum = femMatGet(a, i, j)
			for k = i - 1; k >= 1; k-- {
				sum -= femMatGet(a, i, k) * femMatGet(a, j, k)
			}
			if i == j {
				if sum <= 0 {
					rv = -3
					noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Given matrix is singular\x00"))
					goto memFree
				}
				femVecPutAdd(C, i, math.Sqrt(sum), 0)
			} else {
				femMatPutAdd(a, j, i, sum/femVecGet(C, i), 0)
			}
		}
	}
	for i = 1; i <= n; i++ {
		for j = i; j <= n; j++ {
			if i != j {
				femMatPutAdd(a, i, j, femMatGet(a, j, i), 0)
				femMatPutAdd(a, j, i, 0, 0)
			} else {
				femMatPutAdd(a, j, i, femVecGet(C, i), 0)
			}
		}
	}
	femVecPrn(C, []byte("C\x00"))
memFree:
	;
	if have_C == 0 {
		// freeing of memory:
		femVecFree(C)
	}
	return rv
}

// femEqsChol - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:759
func femEqsChol(a []tMatrix, b []tVector, x []tVector) int32 {
	// Choleski decomposition - complete
	// * @param a matrix (must  be a MAT_FULL)
	// * @return status
	//
	var rv int32
	var sum float64
	var n int32
	var i int32
	var j int32
	var k int32
	var C tVector
	n = a[0].rows
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&C))[:])
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&C))[:], 0, n, n) != 0 {
		goto memFree
	}
	for i = 1; i <= n; i++ {
		for j = i; j <= n; j++ {
			sum = femMatGet(a, i, j)
			for k = i - 1; k >= 1; k-- {
				sum -= femMatGet(a, i, k) * femMatGet(a, j, k)
			}
			if i == j {
				if sum <= 0 {
					rv = -3
					noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Given matrix is singular\x00"))
					goto memFree
				}
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&C))[:], i, math.Sqrt(sum), 0)
			} else {
				femMatPutAdd(a, j, i, sum/femVecGet((*[1000000]tVector)(unsafe.Pointer(&C))[:], i), 0)
			}
		}
	}
	{
		// backward run:
		for i = 1; i <= n; i++ {
			sum = femVecGet(b, i)
			for k = i - 1; k >= 1; k-- {
				sum -= femMatGet(a, i, k) * femVecGet(x, k)
			}
			femVecPutAdd(x, i, sum/femVecGet((*[1000000]tVector)(unsafe.Pointer(&C))[:], i), 0)
		}
	}
	for i = n; i >= 1; i-- {
		sum = femVecGet(x, i)
		for k = i + 1; k <= n; k++ {
			sum -= femMatGet(a, k, i) * femVecGet(x, k)
		}
		femVecPutAdd(x, i, sum/femVecGet((*[1000000]tVector)(unsafe.Pointer(&C))[:], i), 0)
	}
memFree:
	;
	// freeing of memory:
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&C))[:])
	return rv
}

// femMatJacRotate - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:832
func femMatJacRotate(a []tMatrix, i int32, j int32, k int32, l int32, g float64, h float64, s float64, tau float64) {
	// rotation for Jacobi computation of eigenvalues
	g = femMatGet(a, i, j)
	h = femMatGet(a, k, l)
	femMatPutAdd(a, i, j, g-s*(h+g*tau), 0)
	femMatPutAdd(a, k, l, h+s*(g-h*tau), 0)
}

// femMatEigenJacobi - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:848
func femMatEigenJacobi(a []tMatrix, d []tVector, v []tMatrix, nrot []int32) int32 {
	// Compute eigen numbers and vectors (Jacobi method)
	// * @param a matrix to be analysed
	// * @param d vector to store eigenvalues
	// * @param v matrix to store eigenvectors
	// * @return status
	//
	var iters int32 = 100
	var i int32
	var iq int32
	var ip int32
	var j int32
	var n int32
	var sm float64
	var tresh float64
	var g float64
	var h float64
	var t float64
	var c float64
	var theta float64
	var s float64
	var tau float64
	var checkp float64
	var checkq float64
	var checkh float64
	var b tVector
	var z tVector
	nrot[0] = 0
	n = a[0].rows
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&b))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&z))[:])
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&b))[:], 0, n, n)
	femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&z))[:], 0, n, n)
	for i = 1; i <= n; i++ {
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&b))[:], i, femMatGet(a, i, i), 0)
		femVecPutAdd(d, i, femMatGet(a, i, i), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&z))[:], i, 0, 0)
		femMatPutAdd(v, i, i, 1, 0)
	}
	for i = 1; i <= iters; i++ {
		sm = 0
		for ip = 0; ip <= n-1; ip++ {
			for iq = ip + 1; iq <= n; iq++ {
				sm += math.Abs(femMatGet(a, ip, iq))
			}
		}
		if sm <= 1e-17 {
			// sum <= 0 so we are finished
			//printf("iterations: %li\n", *nrot);
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&b))[:])
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&z))[:])
			return 0
		}
		if i < 4 {
			tresh = 0.2 * sm / float64(n*n)
		} else {
			tresh = 0
		}
		for ip = 1; ip <= n-1; ip++ {
			for iq = ip + 1; iq <= n; iq++ {
				g = 100 * math.Abs(femMatGet(a, ip, iq))
				checkp = math.Abs(g*math.Abs(femVecGet(d, ip)) - math.Abs(femVecGet(d, ip)))
				checkq = math.Abs(g*math.Abs(femVecGet(d, iq)) - math.Abs(femVecGet(d, iq)))
				if i > 4 && checkp <= 1e-17 && checkq <= 1e-17 {
					// off-diagonal elements are small
					femMatPutAdd(a, ip, iq, 0, 0)
				} else {
					// still are big..
					h = femVecGet(d, iq) - femVecGet(d, ip)
					checkh = math.Abs(math.Abs(h) + g - math.Abs(h))
					if checkh < 1e-17 {
						if h != 0 {
							t = femMatGet(a, ip, iq) / h
						} else {
							t = 0
						}
					} else {
						theta = 0.5 * h / femMatGet(a, ip, iq)
						t = 1 / (math.Abs(theta) + math.Sqrt(1+math.Pow(theta, 2)))
						if theta < 0 {
							t = -1 * t
						}
					}
					c = 1 / math.Sqrt(1+math.Pow(t, 2))
					s = t * c
					tau = s / (1 + c)
					h = t * femMatGet(a, ip, iq)
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&z))[:], ip, femVecGet((*[1000000]tVector)(unsafe.Pointer(&z))[:], ip)-h, 0)
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&z))[:], iq, femVecGet((*[1000000]tVector)(unsafe.Pointer(&z))[:], iq)+h, 0)
					femVecPutAdd(d, ip, femVecGet(d, ip)-h, 0)
					femVecPutAdd(d, iq, femVecGet(d, iq)+h, 0)
					femMatPutAdd(a, ip, iq, 0, 0)
					for j = 1; j <= ip-1; j++ {
						femMatJacRotate(a, j, ip, j, iq, g, h, s, tau)
					}
					for j = ip + 1; j <= iq-1; j++ {
						femMatJacRotate(a, ip, j, j, iq, g, h, s, tau)
					}
					for j = iq + 1; j <= n; j++ {
						femMatJacRotate(a, ip, j, iq, j, g, h, s, tau)
					}
					for j = 1; j <= n; j++ {
						femMatJacRotate(v, j, ip, j, iq, g, h, s, tau)
					}
					nrot[0] = nrot[0] + 1
				}
			}
		}
		for ip = 1; ip <= n; ip++ {
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&b))[:], ip, femVecGet((*[1000000]tVector)(unsafe.Pointer(&z))[:], ip), 1)
			femVecPutAdd(d, ip, femVecGet((*[1000000]tVector)(unsafe.Pointer(&b))[:], ip), 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&z))[:], ip, 0, 0)
		}
	}
	noarch.Fprintf(msgout, []byte("[E] %s\n\x00"), []byte("Out of iterations for eigendata\x00"))
	return -1
}

// femEqsCGwSSOR - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:1001
func femEqsCGwSSOR(a []tMatrix, b []tVector, x []tVector, eps float64, maxIt int32) int32 {
	// Conjugate gradient method with SSOR preconditioner
	// *  (for symetric matrices only!)
	// *  @param a      matrix
	// *  @param b      "load" vector
	// *  @param x      results (vector - given as first iteration)
	// *  @param eps    error (min.)
	// *  @param maxIt  max. number of iterations
	// *  @return state value
	//
	// Jacobi preconditioner (diag[A] ;-)
	var M tVector
	var r tVector
	var z tVector
	var zz tVector
	var p tVector
	var q tVector
	var ro float64
	var alpha float64
	var beta float64
	var roro float64
	var n int32
	var i int32
	var ii int32
	var j int32
	var ipos int32
	var rv int32
	var converged int32
	var normRes float64
	var normX float64
	var normA float64
	var normB float64
	var val float64
	if a[0].cols != x[0].rows || x[0].rows != b[0].rows {
		return -9
	}
	n = a[0].rows
	normA = femMatNormBig(a)
	normB = femVecNormBig(b)
	if normB <= 0 {
		femVecSetZeroBig(x)
		noarch.Fprintf(msgout, []byte("[ ]  %s!\n\x00"), []byte("solution done without iterations because of zero load\x00"))
		return 0
	}
	// vector initialization
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&z))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&zz))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&q))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&M))[:], 0, n, n)
		return rv
	}()) != 0 {
		// memory allocation
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&z))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&zz))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&p))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&q))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	{
		// Jacobi preconditioner creation:
		for i = 1; i <= n; i++ {
			val = femMatGet(a, i, i)
			if math.Abs(val) < 1e-17 {
				rv = -13
				noarch.Fprintf(msgout, []byte("[ ]   %s[%li][%li] %s: %e\n\x00"), []byte("matrix member\x00"), i, i, []byte("has zero size\x00"), val)
				goto memFree
			}
			// NOTE: M includes inverse of diagonal
			M.data[i-1] = 1 / val
		}
	}
	// next two lines mean: r = b - A*x
	femMatVecMultBig(a, x, (*[1000000]tVector)(unsafe.Pointer(&r))[:])
	for i = 0; i < n; i++ {
		r.data[i] = b[0].data[i] - r.data[i]
	}
	{
		// main loop
		for i = 1; i <= maxIt; i++ {
			noarch.Fprintf(msgout, []byte("[ ]   %s %li\n\x00"), []byte("linear step\x00"), i)
			if a[0].type_ != 1 {
				{
					// using preconditioner:
					for ii = 1; ii <= n; ii++ {
						val = 0
						for j = 1; j < ii; j++ {
							val += femMatGet(a, ii, j) * femVecGet((*[1000000]tVector)(unsafe.Pointer(&zz))[:], j)
						}
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&zz))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&M))[:], ii)*(femVecGet((*[1000000]tVector)(unsafe.Pointer(&r))[:], ii)-val), 0)
					}
				}
				for ii = n; ii >= 1; ii-- {
					val = 0
					for j = ii + 1; j <= n; j++ {
						val += femMatGet(a, ii, j) * femVecGet((*[1000000]tVector)(unsafe.Pointer(&z))[:], j)
					}
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&z))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&zz))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&M))[:], ii)*val, 0)
				}
			} else {
				{
					// faster code for MAT_SPAR:
					for ii = 1; ii <= n; ii++ {
						val = 0
						for j = a[0].frompos[ii-1]; j < a[0].frompos[ii-1]+a[0].defpos[ii-1]; j++ {
							ipos = a[0].pos[j]
							if ipos >= ii || ipos < 1 {
								continue
							}
							val += a[0].data[j] * zz.data[ipos-1]
						}
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&zz))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&M))[:], ii)*(femVecGet((*[1000000]tVector)(unsafe.Pointer(&r))[:], ii)-val), 0)
					}
				}
				for ii = n; ii >= 1; ii-- {
					val = 0
					for j = a[0].frompos[ii-1]; j < a[0].frompos[ii-1]+a[0].defpos[ii-1]; j++ {
						ipos = a[0].pos[j]
						if ipos > ii {
							val += a[0].data[j] * z.data[ipos-1]
						}
					}
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&z))[:], ii, femVecGet((*[1000000]tVector)(unsafe.Pointer(&zz))[:], ii)-femVecGet((*[1000000]tVector)(unsafe.Pointer(&M))[:], ii)*val, 0)
				}
			}
			// end of preconditioning
			ro = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&r))[:], (*[1000000]tVector)(unsafe.Pointer(&z))[:])
			noarch.Fprintf(msgout, []byte("ro = %f\n\x00"), ro)
			if i == 1 {
				for j = 0; j < n; j++ {
					p.data[j] = z.data[j]
				}
			} else {
				beta = ro / roro
				noarch.Fprintf(msgout, []byte("beta = %f\n\x00"), beta)
				for j = 0; j < n; j++ {
					p.data[j] = z.data[j] + beta*p.data[j]
				}
			}
			femMatVecMultBig(a, (*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&q))[:])
			alpha = ro / femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&p))[:], (*[1000000]tVector)(unsafe.Pointer(&q))[:])
			noarch.Fprintf(msgout, []byte("alpha = %f\n\x00"), alpha)
			for j = 0; j < n; j++ {
				x[0].data[j] = x[0].data[j] + alpha*p.data[j]
				r.data[j] = r.data[j] - alpha*q.data[j]
			}
			// Convergence testing
			normRes = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&r))[:])
			normX = femVecNormBig(x)
			if normRes <= eps*(normA*normX+normB) {
				// convergence test
				//if (fabs(norm - norm0) < eps )
				converged = 1
				noarch.Fprintf(msgout, []byte("[ ]  %s %li %s!\n\x00"), []byte("linear solution done in\x00"), i, []byte("iterations\x00"))
				break
			}
			noarch.Fprintf(msgout, []byte("[i] Convergence test %f < %f (step %li from %li)\n\x00"), normRes, eps*(normA*normX+normB), i, maxIt)
			roro = ro
		}
	}
	if converged != 1 {
		// end of main loop
		//fprintf(msgout,"[I] normRes = %f\n",normRes);
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("unconverged solution\x00"))
		rv = -1
	}
memFree:
	;
	// freeing memory:
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&r))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&z))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&zz))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&p))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&q))[:])
	return rv
}

// femEqsMatInverse - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_eqs.c:1227
func femEqsMatInverse(a []tMatrix, b []tMatrix, eps float64, maxIt int32) int32 {
	// (Large) matrix inversion with use of GCwJ; MIGHT BE SLOW
	// *  (for symetric matrices only!)
	// *  @param a      original matrix (must be MAT_SPAR)
	// *  @param b      inverted matrix (must be MAT_FULL)
	// *  @param eps    error (min.)
	// *  @param maxIt  max. number of iterations
	// *  @return state value
	//
	// unit matrix
	var M tVector
	// column of result vector
	var x tVector
	var i int32
	var j int32
	var n int32
	var rv int32
	if a[0].cols != a[0].rows {
		return -9
	}
	if a[0].cols != b[0].rows || a[0].rows != b[0].cols {
		return -9
	}
	if a[0].type_ != 1 || b[0].type_ != 0 {
		return -5
	}
	n = a[0].rows
	femMatSetZeroBig(b)
	// memory allocation
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&x))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&M))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&x))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= n; i++ {
		if i > 1 {
			// clean previous data
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&M))[:], i-1, 0, 0)
		}
		// set current vector
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&M))[:], i, 1, 0)
		if (func() int32 {
			rv = femEqsCGwJ(a, (*[1000000]tVector)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&x))[:], eps, maxIt)
			return rv
		}()) != 0 {
			goto memFree
		}
		for j = 1; j <= n; j++ {
			femMatPutAdd(b, j, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&x))[:], j), 0)
		}
	}
memFree:
	;
	// freeing memory:
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&M))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&x))[:])
	return rv
}

// fem_plast_H_RO - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_hard.c:32
func fem_plast_H_RO(ePos int32, k float64, n float64, E float64, sigma float64) float64 {
	//
	//   File name: fem_hard.c
	//   Date:      2011/11/06 17:56
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2011 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM solver: hardening rules for plasticity
	//
	// Computes Ramberg--Osgood approximation of H
	return E / (k * n) * math.Pow(sigma/E, 1-n)
}

// fem_plast_H_linear - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_hard.c:43
func fem_plast_H_linear(ePos int32, E0 float64, E1 float64, fy float64, sigma float64) float64 {
	// Computes linear approximation of H
	//
	return E1 / (1 - E1/E0)
}

// femRenumIndex - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:50
func femRenumIndex(ind []int32, indLen int32, by_ind []int32, by_indLen int32) int32 {
	//
	//   File name: fem_io.c
	//   Date:      2003/04/07 09:06
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   Finite Element Solver - I/O operations
	//
	//  $Id: fem_io.c,v 1.20 2005/01/01 21:01:26 jirka Exp $
	//
	// from "fem_sol.c":
	// total number of ACTIVE DOFs in structure (== size of "K" matrix)
	// lenght of nDOFfld
	// description of DOFs in nodes
	// structure displacement vector
	// "monte" data reading (fem_mont.c)
	// tensor scale data export (fem_ts.c)
	// replaces name (long number!) values in "ind" with their positions by "by_imd" field
	// * @param ind field to be modified
	// * @param indLen lenght of ind
	// * @param ind_by
	// * @param ind_byLen lenght of ind_by
	// * @return state value
	//
	var rv int32 = -3
	var i int32
	var j int32
	if femPreparsedData == 1 {
		rv = 0
		return rv
	}
	for i = 0; i < indLen; i++ {
		for j = 0; j < by_indLen; j++ {
			rv = -3
			if ind[i] == by_ind[j] {
				//fprintf(msgout,"ind[i] = %li | %li\n",ind[i],by_ind[i]);
				ind[i] = j
				rv = 0
				break
			}
		}
		if rv != 0 {
			noarch.Fprintf(msgout, []byte("[E] %s: \"%li\"!\n\x00"), []byte("Stop - name without index found\x00"), ind[i])
			return rv
		}
	}
	return rv
}

// femReadInputLoads - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:86
func femReadInputLoads(fr *noarch.File) int32 {
	// reads loads data from file - do NOT use it directly
	// * @param fname file name
	// * @return state value
	//
	var rv int32
	var i int32
	var sum int32
	var pos int32
	// nodal loads:
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&nlLen))
	if nlLen > 0 {
		if len((func() []int32 {
			nlNode = femIntAlloc(nlLen)
			return nlNode
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			nlType = femIntAlloc(nlLen)
			return nlType
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			nlDir = femIntAlloc(nlLen)
			return nlDir
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []float64 {
			nlVal = femDblAlloc(nlLen)
			return nlVal
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			nlTrPos = femIntAlloc(nlLen)
			return nlTrPos
		}())) == 0 {
			rv = -4
			goto memFree
		}
		for i = 0; i < nlLen; i++ {
			noarch.Fscanf(fr, []byte("%li %li %li %f\x00\x00"), nlNode[i:], nlType[i:], nlDir[i:], nlVal[i:])
			nlTrPos[i] = -1
			noarch.Fprintf(msgout, []byte("nl: n=%li typ=%li dir=%li val=%f\n\x00"), nlNode[i], nlType[i], nlDir[i], nlVal[i])
		}
		if (func() int32 {
			rv = femRenumIndex(nlNode, nlLen, nID, nLen)
			return rv
		}()) != 0 {
			// renumbering of "nlNode" (names -> indexes)
			goto memFree
		}
	}
	// element loads:
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&elLen))
	if elLen > 0 {
		if len((func() []int32 {
			elElem = femIntAlloc(elLen)
			return elElem
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			elType = femIntAlloc(elLen)
			return elType
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			elFrom = femIntAlloc(elLen)
			return elFrom
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			elTrPos = femIntAlloc(elLen)
			return elTrPos
		}())) == 0 {
			rv = -4
			goto memFree
		}
		sum = 0
		for i = 0; i < elLen; i++ {
			noarch.Fscanf(fr, []byte("%li %li %li\x00"), elElem[i:], elType[i:], elFrom[i:])
			sum += elFrom[i]
			elTrPos[i] = -1
			noarch.Fprintf(msgout, []byte("el: e = %li: t=%li nn=%li\n\x00"), elElem[i], elType[i], elFrom[i])
		}
		// setting elFrom field
		sum = 0
		for i = 0; i < elLen; i++ {
			pos = elFrom[i]
			elFrom[i] = sum
			sum += pos
		}
		noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&elLenL))
		if elLenL != sum {
			noarch.Fprintf(msgout, []byte("[E] %s (%lix%li)!\n\x00"), []byte("Bad number of element load values\x00"), sum, elLenL)
			rv = -9
			goto memFree
		}
		if len((func() []float64 {
			elValL = femDblAlloc(elLenL)
			return elValL
		}())) == 0 {
			rv = -4
			goto memFree
		}
		for i = 0; i < elLenL; i++ {
			noarch.Fscanf(fr, []byte("%f\x00\x00"), elValL[i:])
			noarch.Fprintf(msgout, []byte(" %f \n\x00"), elValL[i])
		}
		if (func() int32 {
			rv = femRenumIndex(elElem, elLen, eID, eLen)
			return rv
		}()) != 0 {
			// renumbering of "elElem" (names -> indexes)
			goto memFree
		}
	}
memFree:
	;
	return rv
}

// femReadRepeatData - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:178
func femReadRepeatData(fr *noarch.File) int32 {
	// Reads repeating data (dynamics, transient analysis etc.)
	// * @param fname file name
	// * @return state value
	//
	var rv int32
	var i int32
	var j int32
	transTS = -1
	if noarch.Fscanf(fr, []byte("%li %li %f\x00\x00"), c4goUnsafeConvert_int32(&transNum), c4goUnsafeConvert_int32(&dynNum), c4goUnsafeConvert_float64(&dynStp)) < 3 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Empty transient data\x00"))
		femNewmarkEL = 0
		femThermTrans = 0
		return 0
	}
	if dynNum > 0 {
		if transNum > 0 {
			if len((func() []int32 {
				transType = femIntAlloc(transNum)
				return transType
			}())) == 0 {
				rv = -4
				goto memFree
			}
			if len((func() []int32 {
				transPos = femIntAlloc(transNum)
				return transPos
			}())) == 0 {
				rv = -4
				goto memFree
			}
			if len((func() [][]float64 {
				transMult = (*[1000000][]float64)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := make([]byte, uint32(transNum)*uint32(1))
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				return transMult
			}())) == 0 {
				rv = -4
				goto memFree
			} else {
				for i = 0; i < transNum; i++ {
					if len((func() []float64 {
						transMult[i] = femDblAlloc(dynNum)
						return transMult[i]
					}())) == 0 {
						rv = -4
						goto memFree
					}
					for j = 0; j < dynNum; j++ {
						transMult[i][j] = 0
					}
				}
			}
			{
				// read data types:
				for i = 0; i < transNum; i++ {
					if noarch.Fscanf(fr, []byte("%li %li\x00"), transType[i:], transPos[i:]) < 2 {
						rv = -2
						noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Missing transient data description\x00"))
						goto memFree
					}
				}
			}
			{
				// read actual data
				for i = 0; i < transNum; i++ {
					for j = 0; j < dynNum; j++ {
						if noarch.Fscanf(fr, []byte("%f\x00\x00"), transMult[i][j:]) != 1 {
							noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Missing transient data\x00"))
							rv = -2
							goto memFree
						}
					}
				}
			}
			{
				// test of data and filling of elTrPos, nlTrPos...
				for i = 0; i < transNum; i++ {
					switch transType[i] {
					case 0:
						// absolute time
						transTS = i
					case 1:
						// gravity ux
						dynAccX = i
					case 2:
						// gravity uy
						dynAccY = i
					case 3:
						// gravity uz
						dynAccZ = i
					case 4:
						if transPos[i] >= 0 && transPos[i] < nlLen {
							// load/support in node
							nlTrPos[transPos[i]] = i
						}
					case 5:
						if transPos[i] >= 0 && transPos[i] < elLen {
							// load on element
							elTrPos[transPos[i]] = i
						}
						break
					}
				}
			}
		}
	} else {
		// end of transNum > 0
		// no transient data
		femNewmarkEL = 0
		femThermTrans = 0
		return 0
	}
	return rv
memFree:
	;
	femIntFree(transType)
	femIntFree(transPos)
	if len(transMult) != 0 {
		for i = 0; i < transNum; i++ {
			femDblFree(transMult[i])
		}
		_ = transMult
		transMult = nil
	}
	return rv
}

// femReadInputDynLoads - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:301
func femReadInputDynLoads(fr *noarch.File) int32 {
	// reads dynamics (acceleration) data from file - do NOT use it directly
	// * @param fname file name
	// * @return state value
	//
	var rv int32
	var dynNum0 int32
	rv = noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&dynNum0))
	rv = 0
	if dynNum0 <= 0 {
		if femNewmarkEL != 0 {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Empty dynamics data\x00"))
			dynNum = 0
			dynStp = 0
			return -12
		} else {
			if dynNum0 > 0 && dynNum0 != dynNum {
				noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Dynamics data inconsistent with subtsep data\x00"))
				dynNum = 0
				dynStp = 0
				return -12
			} else {
				return 0
			}
		}
	}
	if noarch.Fscanf(fr, []byte("%f\x00\x00"), c4goUnsafeConvert_float64(&dynStp)) < 1 {
		dynNum = 0
		return -2
	}
	if dynStp < 0 {
		noarch.Fprintf(msgout, []byte("[E] %s: %f!\n\x00"), []byte("Dynamics time step too small\x00"), dynStp)
		dynNum = 0
		dynStp = 0
		return -3
	}
	if noarch.Fscanf(fr, []byte("%f %f\x00\x00\x00"), c4goUnsafeConvert_float64(&dynAlpha), c4goUnsafeConvert_float64(&dynBeta)) < 2 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Can not read damping data\x00"))
		dynNum = 0
		dynStp = 0
		return -2
	}
	if dynAlpha < 0 || dynBeta < 0 {
		noarch.Fprintf(msgout, []byte("[E] %s: alpha=%f, beta=%f!\n\x00"), []byte("Invalid damping data\x00"), dynAlpha, dynBeta)
		dynNum = 0
		dynStp = 0
		return -2
	}
	// should be zero for dynamics!
	grVal = 0
	return rv
}

// femReadInput - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:380
func femReadInput(fname []byte) int32 {
	// reads input data from file - THE MAIN READING FUNCTION
	// * @param fname file name
	// * @return state value
	//
	var rv int32
	var fr *noarch.File
	var pos int32
	var sum int32
	var i int32
	if femReadStdInput == 1 {
		// open file: **************************************
		fr = noarch.Stdin
	} else {
		if (func() *noarch.File {
			fr = noarch.Fopen(fname, []byte("r\x00"))
			return fr
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during input data reading\x00"))
			return -2
		}
	}
	// solution control data:
	noarch.Fscanf(fr, []byte("%li %li\x00"), c4goUnsafeConvert_int32(&solID), c4goUnsafeConvert_int32(&solDepOn))
	noarch.Fprintf(msgout, []byte("TN: %li DepOn: %li\n\x00"), solID, solDepOn)
	noarch.Fscanf(fr, []byte("%li %li %li\n\x00"), c4goUnsafeConvert_int32(&solLinSol), c4goUnsafeConvert_int32(&solNoLinS), c4goUnsafeConvert_int32(&solNoLinSteps))
	if solNoLinS_cmd > -1 {
		// always can be overwritten from command line:
		solNoLinS = solNoLinS_cmd
	}
	if solNoLinSteps_cmd > -1 {
		solNoLinSteps = solNoLinSteps_cmd
	}
	noarch.Fprintf(msgout, []byte("Eq. solver: %li Non-lin: %li N.L. Steps: %li\n\x00"), solID, solNoLinS, solNoLinSteps)
	// real sets:
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&rsLen))
	if rsLen > 0 {
		if len((func() []int32 {
			rsID = femIntAlloc(rsLen)
			return rsID
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			rsType = femIntAlloc(rsLen)
			return rsType
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			rsFrom = femIntAlloc(rsLen)
			return rsFrom
		}())) == 0 {
			rv = -4
			goto memFree
		}
		sum = 0
		for i = 0; i < rsLen; i++ {
			noarch.Fscanf(fr, []byte("%li %li %li\x00"), rsID[i:], rsType[i:], rsFrom[i:])
			sum += rsFrom[i]
			noarch.Fprintf(msgout, []byte("rs = %li: t=%li nn=%li\n\x00"), rsID[i], rsType[i], rsFrom[i])
		}
		// setting rsFrom field
		sum = 0
		for i = 0; i < rsLen; i++ {
			pos = rsFrom[i]
			rsFrom[i] = sum
			sum += pos
		}
		noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&rsLenL))
		if rsLenL != sum {
			noarch.Fprintf(msgout, []byte("[E] %s (%lix%li)!\n\x00"), []byte("Bad number of real set values\x00"), sum, rsLenL)
			rv = -9
			goto memFree
		}
		if rsLenL > 0 {
			if len((func() []float64 {
				rsValL = femDblAlloc(rsLenL)
				return rsValL
			}())) == 0 {
				rv = -4
				goto memFree
			}
			for i = 0; i < rsLenL; i++ {
				noarch.Fscanf(fr, []byte("%f\x00\x00"), rsValL[i:])
				noarch.Fprintf(msgout, []byte(" %f \n\x00"), rsValL[i])
			}
		}
	} else {
		rsLen = 0
		rsLenL = 0
		rsID = nil
		rsType = nil
		rsFrom = nil
		rsValL = nil
	}
	// material properties:
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&mpLen))
	if mpLen > 0 {
		if len((func() []int32 {
			mpID = femIntAlloc(mpLen)
			return mpID
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			mpType = femIntAlloc(mpLen)
			return mpType
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			mpFrom = femIntAlloc(mpLen)
			return mpFrom
		}())) == 0 {
			rv = -4
			goto memFree
		}
		sum = 0
		for i = 0; i < mpLen; i++ {
			noarch.Fscanf(fr, []byte("%li %li %li\x00"), mpID[i:], mpType[i:], mpFrom[i:])
			sum += mpFrom[i]
			noarch.Fprintf(msgout, []byte("mp = %li: t=%li nn=%li\n\x00"), mpID[i], mpType[i], mpFrom[i])
		}
		// setting mpFrom field
		sum = 0
		for i = 0; i < mpLen; i++ {
			pos = mpFrom[i]
			mpFrom[i] = sum
			sum += pos
		}
		noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&mpLenL))
		if mpLenL != sum {
			noarch.Fprintf(msgout, []byte("[E] %s (%lix%li)!\n\x00"), []byte("Bad number of material property values\x00"), sum, mpLenL)
			rv = -9
			goto memFree
		}
		if len((func() []float64 {
			mpValL = femDblAlloc(mpLenL)
			return mpValL
		}())) == 0 {
			rv = -4
			goto memFree
		}
		for i = 0; i < mpLenL; i++ {
			noarch.Fscanf(fr, []byte("%f\x00\x00"), mpValL[i:])
			noarch.Fprintf(msgout, []byte(" %f \n\x00"), mpValL[i])
		}
	}
	// nodes:
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&nLen))
	if nLen < 2 {
		return -10
	}
	if len((func() []int32 {
		nID = femIntAlloc(nLen)
		return nID
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		n_x = femDblAlloc(nLen)
		return n_x
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		n_y = femDblAlloc(nLen)
		return n_y
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		n_z = femDblAlloc(nLen)
		return n_z
	}())) == 0 {
		rv = -4
		goto memFree
	}
	for i = 0; i < nLen; i++ {
		noarch.Fscanf(fr, []byte("%li %f %f %f\x00\x00\x00\x00"), nID[i:], n_x[i:], n_y[i:], n_z[i:])
		noarch.Fprintf(msgout, []byte("n = %li: %f %f %f\n\x00"), nID[i], n_x[i], n_y[i], n_z[i])
	}
	// elements:
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&eLen))
	if eLen < 1 {
		return -10
	}
	if len((func() []int32 {
		eID = femIntAlloc(eLen)
		return eID
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		eType = femIntAlloc(eLen)
		return eType
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		eRS = femIntAlloc(eLen)
		return eRS
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		eMP = femIntAlloc(eLen)
		return eMP
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		eFrom = femIntAlloc(eLen)
		return eFrom
	}())) == 0 {
		rv = -4
		goto memFree
	}
	sum = 0
	for i = 0; i < eLen; i++ {
		noarch.Fscanf(fr, []byte("%li %li %li %li %li\x00"), eID[i:], eType[i:], eRS[i:], eMP[i:], eFrom[i:])
		sum += eFrom[i]
		noarch.Fprintf(msgout, []byte("e = %li: t=%li r=%li m=%li nn=%li\n\x00"), eID[i], eType[i], eRS[i], eMP[i], eFrom[i])
	}
	if (func() int32 {
		rv = femRenumIndex(eMP, eLen, mpID, mpLen)
		return rv
	}()) != 0 {
		// Renumbering eMP
		goto memFree
	}
	if rsLen > 0 {
		if (func() int32 {
			rv = femRenumIndex(eRS, eLen, rsID, rsLen)
			return rv
		}()) != 0 {
			// Renumbering eRS
			goto memFree
		}
	}
	// setting eFrom field
	sum = 0
	for i = 0; i < eLen; i++ {
		pos = eFrom[i]
		eFrom[i] = sum
		sum += pos
	}
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&eLenL))
	if eLenL != sum {
		noarch.Fprintf(msgout, []byte("[E] %s (%lix%li)!\n\x00"), []byte("Bad number of element nodes\x00"), sum, eLenL)
		rv = -9
		goto memFree
	}
	if len((func() []int32 {
		eNodesL = femIntAlloc(eLenL)
		return eNodesL
	}())) == 0 {
		rv = -4
		goto memFree
	}
	for i = 0; i < eLenL; i++ {
		noarch.Fscanf(fr, []byte("%li\x00"), eNodesL[i:])
		noarch.Fprintf(msgout, []byte(" %li \n\x00"), eNodesL[i])
	}
	if (func() int32 {
		rv = femRenumIndex(eNodesL, eLenL, nID, nLen)
		return rv
	}()) != 0 {
		// renumbering of "eNodesL" (names -> indexes)
		goto memFree
	}
	// gravitation:
	noarch.Fscanf(fr, []byte("%li %f\x00\x00"), c4goUnsafeConvert_int32(&grDir), c4goUnsafeConvert_float64(&grVal))
	noarch.Fprintf(msgout, []byte("gr: dir=%li g=%f\n\x00"), grDir, grVal)
	if (func() int32 {
		rv = femReadInputLoads(fr)
		return rv
	}()) != 0 {
		// all load data:
		goto memFree
	}
	if (func() int32 {
		rv = femReadRepeatData(fr)
		return rv
	}()) != 0 {
		// Array data (thermal/dynamics) - if applicable
		goto memFree
	}
	if (func() int32 {
		rv = femReadInputDynLoads(fr)
		return rv
	}()) != 0 {
		// dynamics (if applicable)
		goto memFree
	}
	if (func() int32 {
		rv = fem_monte_read_data(fr)
		return rv
	}()) != 0 {
		// Monte-related data (if any )
		goto memFree
	}
	if noarch.Fclose(fr) != 0 {
		// close file: *************************************
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during input data reading\x00"))
		fr = nil
		return -2
	}
	if rv == 0 {
		return rv
	}
memFree:
	;
	// on error:
	femDataFree()
	return rv
}

// femWriteRes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:648
func femWriteRes(fname []byte) int32 {
	// Writes results
	// * @param fname name of file
	// * @return
	//
	var rv int32
	var fr *noarch.File
	var i int32
	if len(fname) == 0 && femWriteStdOutput == 1 {
		// open file: **************************************
		fr = noarch.Stdout
	} else {
		if (func() *noarch.File {
			fr = noarch.Fopen(fname, []byte("w\x00"))
			return fr
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during result data writing\x00"))
			return -2
		}
	}
	// Solution identifier and dependence info, (useless) simulation number:
	noarch.Fprintf(fr, []byte("S\n %li %li %e \n\x00"), solID, solDepOn, solSimNum)
	// DOF solution:
	noarch.Fprintf(fr, []byte(" %li \n %li \n %li\n\x00"), nDOFAct, nDOFlen, nLen)
	for i = 0; i < nLen; i++ {
		// node number
		noarch.Fprintf(fr, []byte(" %li\n\x00"), nID[i])
	}
	for i = 0; i < nDOFlen; i++ {
		// DOF description
		noarch.Fprintf(fr, []byte(" %li\n\x00"), nDOFfld[i])
	}
	// DOF solution vector
	femVecOut((*[1000000]tVector)(unsafe.Pointer(&u))[:], fr)
	// Reactions:
	noarch.Fprintf(fr, []byte(" %li \n\x00"), resRLen)
	for i = 0; i < resRLen; i++ {
		noarch.Fprintf(fr, []byte(" %li %li %li %e\n\x00"), resRnode[i], nID[resRnode[i]], resRdof[i], resRval[i])
	}
	// Element results:
	noarch.Fprintf(fr, []byte(" %li %li\n\x00"), eLen, resELen)
	for i = 0; i < eLen; i++ {
		noarch.Fprintf(fr, []byte(" %li \n\x00"), eID[i])
	}
	for i = 0; i < eLen; i++ {
		noarch.Fprintf(fr, []byte(" %li \n\x00"), resEFrom[i])
	}
	{
		//fprintf(fr," %li \n",resELen);
		for i = 0; i < resELen; i++ {
			noarch.Fprintf(fr, []byte(" %e \n\x00"), resEVal[i])
		}
	}
	if (int64(uintptr(unsafe.Pointer(fr)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fr) != 0 {
			// close file: *************************************
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of result file\x00"))
			fr = nil
			return -2
		}
	}
	return rv
}

// femReadRes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:741
func femReadRes(fname []byte) int32 {
	// Reads results - result fields have to be already allocated!
	// *  Note: values will be ADDED, NOT REWRITTEN
	// * @param fname name of file
	// * @return
	//
	var rv int32
	var fr *noarch.File
	var i int32
	var j int32
	var type_c byte
	var solID_tst int32
	var solDepOn_tst int32
	var solSimNum_tst float64
	var nDOFAct_tst int32
	var nDOFlen_tst int32
	var nLen_tst int32
	var n_id_tst []int32
	var n_pos_tst []int32
	var n_desc_tst []int32
	var e_id_tst []int32
	var e_pos_tst []int32
	var e_len_tst []int32
	var resRLen_tst int32
	var resRnode_tst int32
	var resRid_tst int32
	var resRdof_tst int32
	var resRval_tst float64
	var eLen_tst int32
	var resELen_tst int32
	var dummy int32
	var pos int32
	var val float64
	if len(fname) == 0 && femPrevStdInput == 1 {
		// open file: **************************************
		fr = noarch.Stdin
	} else {
		if (func() *noarch.File {
			fr = noarch.Fopen(fname, []byte("r\x00"))
			return fr
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during reading of previous results\x00"))
			return -2
		}
	}
	// Solution identifier and dependence info, (useless) simulation number:
	noarch.Fscanf(fr, []byte("%c %li %li %f\x00\x00"), c4goUnsafeConvert_byte(&type_c), c4goUnsafeConvert_int32(&solID_tst), c4goUnsafeConvert_int32(&solDepOn_tst), c4goUnsafeConvert_float64(&solSimNum_tst))
	// DOF solution:
	noarch.Fscanf(fr, []byte("%li %li %li\x00"), c4goUnsafeConvert_int32(&nDOFAct_tst), c4goUnsafeConvert_int32(&nDOFlen_tst), c4goUnsafeConvert_int32(&nLen_tst))
	//number of DOF's per node
	dummy = nDOFlen_tst / nLen_tst
	if dummy != nDOFlen/nLen {
		// catastrophic failure - different numbers of DOF's pe node!
		return -3
	}
	if len((func() []int32 {
		n_id_tst = femIntAlloc(nLen_tst)
		return n_id_tst
	}())) == 0 {
		// testing fields
		return -4
	}
	if len((func() []int32 {
		n_pos_tst = femIntAlloc(nLen_tst)
		return n_pos_tst
	}())) == 0 {
		femIntFree(n_id_tst)
		return -4
	}
	if len((func() []int32 {
		n_desc_tst = femIntAlloc(nDOFlen_tst)
		return n_desc_tst
	}())) == 0 {
		femIntFree(n_id_tst)
		femIntFree(n_pos_tst)
		return -4
	}
	for i = 0; i < nLen_tst; i++ {
		// node number
		noarch.Fscanf(fr, []byte("%li\x00"), n_id_tst[i:])
		n_pos_tst[i] = -1
	}
	for i = 0; i < nLen_tst; i++ {
		if i < nLen {
			if n_id_tst[i] == nID[i] {
				// nodes are the same - nice!
				n_pos_tst[i] = i
			} else {
				// have to find the node
				for j = 0; j < nLen; j++ {
					if n_id_tst[i] == nID[j] {
						n_pos_tst[i] = j
						break
					}
				}
			}
		} else {
			// have to find the node
			for j = 0; j < nLen; j++ {
				if n_id_tst[i] == nID[j] {
					n_pos_tst[i] = j
					break
				}
			}
		}
	}
	// no longer needed
	femIntFree(n_id_tst)
	{
		// DOF description - hope that's OK
		for i = 0; i < nDOFlen_tst; i++ {
			noarch.Fscanf(fr, []byte("%li\x00"), n_desc_tst[i:])
		}
	}
	// once more..
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&nDOFAct_tst))
	for i = 0; i < nLen_tst; i++ {
		for j = 0; j < dummy; j++ {
			if n_desc_tst[i*dummy+j] > 0 {
				// there is something - read it
				noarch.Fscanf(fr, []byte("%f\x00\x00"), c4goUnsafeConvert_float64(&val))
				if n_pos_tst[i] != -1 {
					if (func() int32 {
						pos = nDOFfld[n_pos_tst[i]*dummy+j]
						return pos
					}()) > 0 {
						// probably useless
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u))[:], pos, val, 1)
						// it exists, use it!
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], pos, val, 1)
					}
				}
			}
		}
	}
	// no longer needed
	femIntFree(n_pos_tst)
	// no longer needed
	femIntFree(n_desc_tst)
	// Reactions - we will silently ignore them :
	noarch.Fscanf(fr, []byte("%li\x00"), c4goUnsafeConvert_int32(&resRLen_tst))
	for i = 0; i < resRLen_tst; i++ {
		noarch.Fscanf(fr, []byte("%li %li %li %f\x00\x00"), c4goUnsafeConvert_int32(&resRnode_tst), c4goUnsafeConvert_int32(&resRid_tst), c4goUnsafeConvert_int32(&resRdof_tst), c4goUnsafeConvert_float64(&resRval_tst))
	}
	// Element results:
	noarch.Fscanf(fr, []byte("%li %li\x00"), c4goUnsafeConvert_int32(&eLen_tst), c4goUnsafeConvert_int32(&resELen_tst))
	if len((func() []int32 {
		e_id_tst = femIntAlloc(eLen_tst)
		return e_id_tst
	}())) == 0 {
		// testing fields
		return -4
	}
	if len((func() []int32 {
		e_pos_tst = femIntAlloc(eLen_tst)
		return e_pos_tst
	}())) == 0 {
		femIntFree(e_id_tst)
		return -4
	}
	if len((func() []int32 {
		e_len_tst = femIntAlloc(eLen_tst)
		return e_len_tst
	}())) == 0 {
		femIntFree(e_id_tst)
		femIntFree(e_pos_tst)
		return -4
	}
	for i = 0; i < eLen; i++ {
		noarch.Fscanf(fr, []byte("%li\x00"), e_id_tst[i:])
		e_pos_tst[i] = -1
	}
	for i = 0; i < eLen_tst; i++ {
		if i < eLen {
			if e_id_tst[i] == eID[i] {
				// nodes are the same - nice!
				e_pos_tst[i] = i
			} else {
				// have to find the node
				for j = 0; j < eLen; j++ {
					if e_id_tst[i] == eID[j] {
						e_pos_tst[i] = j
						break
					}
				}
			}
		} else {
			// have to find the node
			for j = 0; j < eLen; j++ {
				if e_id_tst[i] == eID[j] {
					e_pos_tst[i] = j
					break
				}
			}
		}
	}
	// no longer needed
	femIntFree(e_id_tst)
	for i = 0; i < eLen_tst; i++ {
		noarch.Fscanf(fr, []byte("%li\x00"), e_len_tst[i:])
	}
	for i = 0; i < eLen_tst-1; i++ {
		e_len_tst[i] = e_len_tst[i+1] - e_len_tst[i]
	}
	e_len_tst[eLen_tst-1] = resELen_tst - e_len_tst[eLen_tst-1]
	{
		// there also should be a test if elements have the same number of
		//   * results - I can imagine that it isn's a problem, but nobody knows..
		//
		for i = 0; i < eLen_tst; i++ {
			if e_len_tst[i] > 0 {
				if e_pos_tst[i] != -1 {
					pos = resEFrom[e_pos_tst[i]]
				} else {
					// we will not use these values
					pos = -1
				}
				for j = 0; j < e_len_tst[i]; j++ {
					noarch.Fscanf(fr, []byte("%f\x00\x00"), c4goUnsafeConvert_float64(&val))
					if pos != -1 {
						resEVal[pos+j] += val
					}
				}
			}
		}
	}
	// no longer needed
	femIntFree(e_pos_tst)
	// no longer needed
	femIntFree(e_len_tst)
	if (int64(uintptr(unsafe.Pointer(fr)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fr) != 0 {
			// close file: *************************************
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of previous result file\x00"))
			fr = nil
			return -2
		}
	}
	return rv
}

// femOpenSolNormFile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:1022
func femOpenSolNormFile(fname []byte) {
	if len(fname) == 0 {
		// *******************************************************
		// * *******************************************************
		// * *******************************************************
		//
		// Openes file for solution norm
		// * @param fname name of file to be opened
		//
		fem_sol_norm_file = nil
		return
	}
	if noarch.Strlen(fname) < int32(1) {
		fem_sol_norm_file = nil
		return
	}
	if (func() *noarch.File {
		fem_sol_norm_file = noarch.Fopen(fname, []byte("w\x00"))
		return fem_sol_norm_file
	}()) == nil {
		fem_sol_norm_file = nil
		return
	}
}

// femWriteSolNorm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:1052
func femWriteSolNorm(iter int32, load_mult float64, val float64, crit_min float64, crit_max float64) {
	if fem_sol_norm_file != nil {
		// Writes solution norm data to the file
		// * @param iter iteration number
		// * @param load_mult load level (0.0..1.0)
		// * @param val unballanced forces (or other measured data)
		// * @param crit criteria value
		// * @param crit criteria value
		//
		noarch.Fprintf(fem_sol_norm_file, []byte("%li %e %e %e %e\n\x00"), iter, load_mult, val, crit_min, crit_max)
		noarch.Fflush(fem_sol_norm_file)
	}
}

// femCloseSolNormFile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:1064
func femCloseSolNormFile() {
	if fem_sol_norm_file != nil {
		// Closed file for solution norm
		//
		noarch.Fclose(fem_sol_norm_file)
		fem_sol_norm_file = nil
	}
}

// femWriteThermDOFS - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:1084
func femWriteThermDOFS(fname []byte, u []tVector) int32 {
	// **********************************************************
	// * **********************************************************
	// * **********************************************************
	//
	// Writes thermal results vector
	// * @param fname name of results file
	// * @param u vector data to save
	// * @return status
	//
	var fw *noarch.File
	var i int32
	var len_ int32
	if len(fname) == 0 && femWriteStdThrOut == 1 {
		fw = noarch.Stdout
	} else {
		if (func() *noarch.File {
			fw = noarch.Fopen(fname, []byte("w\x00"))
			return fw
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during thermal result data writing\x00"))
			return -2
		}
	}
	// write data:
	len_ = u[0].rows
	noarch.Fprintf(fw, []byte("%li\n\x00"), len_)
	for i = 1; i <= len_; i++ {
		noarch.Fprintf(fw, []byte("%e\n\x00"), femVecGet(u, i))
	}
	if (int64(uintptr(unsafe.Pointer(fw)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fw) != 0 {
			// close file: *************************************
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of thermal result file\x00"))
			fw = nil
			return -2
		}
	}
	return 0
}

// femReadThermRes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:1132
func femReadThermRes(fname []byte, u []tVector) int32 {
	// Reads results - result fields have to be already allocated!
	// *  Note: values will be ADDED, NOT REWRITTEN
	// * @param fname name of file
	// * @param u vector to put data in (must be allocated first!)
	// * @return
	//
	var rv int32
	var fr *noarch.File
	var val float64
	var i int32
	var len_ int32
	if len(fname) == 0 && femPrevThrStdIn == 1 {
		// open file: **************************************
		fr = noarch.Stdin
	} else {
		if (func() *noarch.File {
			fr = noarch.Fopen(fname, []byte("r\x00"))
			return fr
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during reading of previous results\x00"))
			return -2
		}
	}
	// read data:
	noarch.Fscanf(fr, []byte("%li\n\x00"), c4goUnsafeConvert_int32(&len_))
	if len_ == u[0].rows {
		for i = 1; i <= len_; i++ {
			noarch.Fscanf(fr, []byte("%f\x00\x00"), c4goUnsafeConvert_float64(&val))
			femVecPutAdd(u, i, val, 1)
		}
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Refuse to read thermal data because of size inconsistence\x00"))
		rv = -9
	}
	if (int64(uintptr(unsafe.Pointer(fr)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fr) != 0 {
			// close file: *************************************
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of previous result file\x00"))
			fr = nil
			return -2
		}
	}
	return rv
}

// femWriteTensorScaleRaster - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_io.c:1200
func femWriteTensorScaleRaster(fname []byte, dnumber int32) int32 {
	// **********************************************************
	// * **********************************************************
	// * **********************************************************
	//
	// Writes tensor scale data to file
	// * @param fname name of results file
	// * @param dnumber number of divisions in x direction
	// * @return status
	//
	var fw *noarch.File
	if len(fname) == 0 {
		fw = noarch.Stdout
	} else {
		if (func() *noarch.File {
			fw = noarch.Fopen(fname, []byte("w\x00"))
			return fw
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during trensor scale writing\x00"))
			return -2
		}
	}
	// write data:
	fem_ts_run(fw, dnumber)
	if (int64(uintptr(unsafe.Pointer(fw)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fw) != 0 {
			// close file:
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of tensor scale file\x00"))
			fw = nil
			return -2
		}
	}
	return 0
}

// femRedStiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:37
//
//   File name: fem_loads.c
//   Date:      2003/04/17 09:56
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - loads
//
// thermal loads field
// therm DOFs indicator
var femRedStiff float64 = 1

// femTestThermLoads - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:43
func femTestThermLoads() int32 {
	// Find if there is need for thermal loads on elements
	// * @return AF_YES if there is at leas one temperature load, AF_NO otherwise
	//
	var i int32
	for i = 0; i < nlLen; i++ {
		if nlType[i] == 8 {
			return 1
		}
	}
	return 0
}

// femTestThermStructElems - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:54
func femTestThermStructElems() int32 {
	// Find if there is thermal load on structural elements
	// * @return AF_YES if there is, AF_NO if there are only thermal elements
	//
	var i int32
	var j int32
	var eType int32
	var nNum int32
	if (func() int32 {
		femHaveThermDOFs = femTestThermLoads()
		return femHaveThermDOFs
	}()) == 0 {
		return 0
	}
	for i = 0; i < rsLen; i++ {
		eType = rsType[i]
		nNum = Elem[eType].dofs
		for j = 0; j < nNum; j++ {
			if Elem[eType].ndof[j] != 7 {
				return 1
			}
		}
	}
	return 0
}

// femApplyStiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:82
func femApplyStiff(nodePos int32, dof int32, Val float64) int32 {
	// Boundary conditions realization (structural stifness)
	// *  @param nodePos node position
	// *  @param dof     degree of freedom
	// *  @param Val     value to be added (stiffness)
	//
	var Pos int32
	if (func() int32 {
		Pos = femKpos(nodePos, dof)
		return Pos
	}()) <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s (%s: %li, %s: %li)\n\x00"), []byte("Cannot add stiffness\x00"), []byte("node\x00"), femGetIntPos(nodePos, nID, nLen), []byte("DOF\x00"), dof)
		return -3
	}
	// standard way:
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos, Pos, math.Abs(Val), 1)
	return 0
}

// femApplyDisp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:116
func femApplyDisp(nodePos int32, dof int32, Val float64) int32 {
	// Adds displacements/stifnesses to Ku=F
	// * @param
	// * @return
	//
	var rv int32
	var K_Val float64
	var F_Val float64
	var u_Val float64
	var tmpVal float64
	var Pos int32
	var rPos int32
	var row int32
	var i int32
	if (func() int32 {
		Pos = femKpos(nodePos, dof)
		return Pos
	}()) <= 0 {
		if femFastBC == 1 {
			return 0
		}
		noarch.Fprintf(msgout, []byte("[E] %s (%s: %li, %s: %li)\n\x00"), []byte("Cannot add boundary condition\x00"), []byte("node\x00"), femGetIntPos(nodePos, nID, nLen), []byte("DOF\x00"), dof)
		return -3
	}
	row = Pos
	K_Val = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], row, Pos)
	F_Val = femVecGet((*[1000000]tVector)(unsafe.Pointer(&F))[:], row)
	u_Val = femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], row)
	if Val == 0 {
		femMatSetZeroRow((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos)
		femMatSetZeroCol((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos)
		femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos, Pos, 1, 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u))[:], Pos, Val, 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], Pos, Val, 0)
		if femDynamics == 1 || femThermTrans == 1 {
			femMatSetZeroRow((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], Pos)
			femMatSetZeroCol((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], Pos)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], Pos, Pos, 1, 0)
		}
		if (func() int32 {
			rPos = fem2IntPos(nodePos, resRnode, dof, resRdof, resRLen)
			return rPos
		}()) < 0 {
			if Val == 0 {
				// add F_Val handling code HERE!
				{
				}
			}
		}
		if rPos > -1 {
			resRval[rPos] -= F_Val
		}
	} else {
		u_Val = Val
		for i = 1; i <= K.rows; i++ {
			tmpVal = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], i, Pos)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], i, -1*tmpVal*u_Val, 1)
			noarch.Printf([]byte(" [%li | %li] Val is %e * %e\n\x00"), i, Pos, u_Val, tmpVal)
		}
		femMatSetZeroRow((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos)
		// why?
		femMatSetZeroCol((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u))[:], Pos, Val, 0)
		if math.Abs(femVecGet((*[1000000]tVector)(unsafe.Pointer(&F))[:], Pos)/u_Val) > 1e-17 {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos, Pos, femVecGet((*[1000000]tVector)(unsafe.Pointer(&F))[:], Pos)/u_Val, 0)
		} else {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], Pos, Pos, 1, 0)
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], Pos, Val, 0)
		}
		if femDynamics == 1 || femThermTrans == 1 {
			femMatSetZeroRow((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], Pos)
			femMatSetZeroCol((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], Pos)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], Pos, Pos, 1, 0)
		}
	}
	return rv
}

// femTestDisp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:266
func femTestDisp(nodePos int32, Type_ int32, dof int32) int32 {
	var rPos int32
	var dPos int32
	if (func() int32 {
		rPos = fem2IntPos(nodePos, resRnode, dof, resRdof, resRLen)
		return rPos
	}()) < 0 {
		// not found => ignore it
		return 1
	} else {
		dPos = femKpos(nodePos, dof)
		switch Type_ {
		case 4:
			fallthrough
		case 6:
			if resRval0[rPos] < 0 {
				if femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos) > 0 {
				} else {
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos, 1, 0)
					femIterBCchange++
				}
				return 0
			} else {
				if femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos) > 0 {
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos, 0, 0)
					femIterBCchange++
				}
			}
		case 5:
			fallthrough
		case 7:
			if resRval0[rPos] > 0 {
				if femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos) > 0 {
				} else {
					// do nothing
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos, 1, 0)
					femIterBCchange++
				}
				return 0
			} else {
				if femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos) > 0 {
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], dPos, 0, 0)
					femIterBCchange++
				}
			}
		default:
			return 1
			break
		}
	}
	return 1
}

// femApplyNLoad - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:343
func femApplyNLoad(nPos int32, Type_ int32, Dir int32, Val float64) int32 {
	// Uses load on nodes EXCEPT boundary conditions
	// * @param nPos node position
	// * @param load type
	// * @param dir direction (relevant DOF)
	// * @param Val value to be used
	// * @return state value
	//
	var rv int32
	var Pos int32
	if (func() int32 {
		Pos = femKpos(nPos, Dir)
		return Pos
	}()) <= 0 && Type_ != 8 {
		if femFastBC == 1 {
			return 0
		}
		noarch.Fprintf(msgout, []byte("[E] %s (%s: %li, %s: %li,  %s: %li)\n\x00"), []byte("Cannot add nodal load\x00"), []byte("node\x00"), femGetIntPos(nPos, nID, nLen), []byte("type\x00"), Type_, []byte("direction\x00"), Dir)
	}
	switch Type_ {
	case 1:
		fallthrough
	case 2:
		fallthrough
	case 4:
		fallthrough
	case 5:
		fallthrough
	case 6:
		fallthrough
	case 7:
		// displacement
		// stifness
		// b.c. is added by another function
		return 0
	case 8:
		// b.c. should be added by another function
		return 0
	case 3:
		// force/moment load
		rv = femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], Pos, Val, 1)
	case 9:
		// heat
		rv = femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], Pos, Val, 1)
	default:
		// error
		break
	}
	return rv
}

// femApplyNBC - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:406
func femApplyNBC(nPos int32, Type_ int32, Dir int32, Val float64) int32 {
	// Uses boundary conditions on nodes
	// * @param nPos node position
	// * @param load type
	// * @param dir direction (relevant DOF)
	// * @param Val value to be used
	// * @return state value
	//
	var rv int32
	if femKpos(nPos, Dir) <= 0 {
		if Type_ != 8 {
			if femFastBC == 1 {
				return 0
			}
			noarch.Fprintf(msgout, []byte("[E] %s (%s: %li, %s: %li)\n\x00"), []byte("Cannot add nodal b.c.\x00"), []byte("node\x00"), femGetIntPos(nPos, nID, nLen), []byte("direction\x00"), Dir)
		}
	}
	switch Type_ {
	case 1:
		// displacement
		rv = femApplyDisp(nPos, Dir, Val)
	case 8:
		if femHaveThermLoad != 1 {
			// temperature as DOF:
			rv = femApplyDisp(nPos, Dir, Val)
		}
	case 2:
		// stifness
		rv = femApplyStiff(nPos, Dir, Val)
	case 3:
		// force/moment load
		return 0
	case 4:
		if femTestDisp(nPos, Type_, Dir) != 1 {
			// works only in compression
			// displacement - compression only
			rv = femApplyStiff(nPos, Dir, femRedStiff)
			break
		}
		rv = femApplyDisp(nPos, Dir, Val)
	case 5:
		if femTestDisp(nPos, Type_, Dir) != 1 {
			// works only in tension
			// displacement - tension only
			rv = femApplyStiff(nPos, Dir, femRedStiff)
			break
		}
		rv = femApplyDisp(nPos, Dir, Val)
	case 6:
		if femTestDisp(nPos, Type_, Dir) != 1 {
			// works only in compression
			// stifness
			rv = femApplyStiff(nPos, Dir, femRedStiff)
			break
		}
		rv = femApplyStiff(nPos, Dir, Val)
	case 7:
		if femTestDisp(nPos, Type_, Dir) != 1 {
			// works only in tension
			// stifness
			rv = femApplyStiff(nPos, Dir, femRedStiff)
			break
		}
		rv = femApplyStiff(nPos, Dir, Val)
	case 9:
		// heat power load
		return 0
	default:
		// nothing
		break
	}
	return rv
}

// femAddGravLoad - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:499
func femAddGravLoad(Dir int32, Val float64) int32 {
	// Adds gravitation load to load vector
	// * @param Dir direction of acceleration
	// * @param Val acceleration size
	// * @return state value
	//
	var rv int32
	var eT int32
	var MeSz int32
	var M_e tMatrix
	var u_e tVector
	var F_e tVector
	var i int32
	var j int32
	var k int32
	var pos int32
	if math.Abs(Val) <= 0 {
		return 0
	}
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	for i = 0; i < eLen; i++ {
		eT = eType[i]
		MeSz = Elem[eT].dofs * Elem[eT].nodes
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:], 0, MeSz, MeSz, 0, nil)
			return rv
		}()) != 0 {
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], 0, MeSz, MeSz)
			return rv
		}()) != 0 {
			femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], 0, MeSz, MeSz)
			return rv
		}()) != 0 {
			femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			goto memFree
		}
		if (func() int32 {
			rv = Elem[eT].mass(i, (*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			return rv
		}()) != 0 {
			noarch.Fprintf(msgout, []byte("[E] %s: %li!\x00"), []byte("Mass matrix creation failed on element\x00"), eID[i])
			goto memFree
		}
		femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
		pos = 0
		{
			// multipliers vector:
			for j = 0; j < Elem[eT].nodes; j++ {
				for k = 0; k < Elem[eT].dofs; k++ {
					pos++
					if Elem[eT].ndof[k] == Dir {
						rv = femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], pos, -1*Val, 0)
						if rv != 0 {
							noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Problem with gravity matrix on element\x00"), eID[i])
						}
					}
				}
			}
		}
		if (func() int32 {
			rv = femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:], (*[1000000]tVector)(unsafe.Pointer(&u_e))[:], (*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			return rv
		}()) != 0 {
			// load vector:
			goto memFree
		}
		femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:], []byte("Mass matrix\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u_e))[:], []byte("Mass multiplier\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], []byte("Mass load\x00"))
		if (func() int32 {
			rv = femLocF_e((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], i, (*[1000000]tVector)(unsafe.Pointer(&F))[:], 1)
			return rv
		}()) != 0 {
			// localization of load vector:
			noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Localization of gravitation load vectro failed on element\x00"), eID[i])
			goto memFree
		}
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	}
	if rv == 0 {
		return rv
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_e))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	return rv
}

// femAddElemLoad - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:606
func femAddElemLoad() int32 {
	// Adds element loads to load vector
	// * @return state value
	//
	var rv int32
	var F_e tVector
	var size int32
	var eT int32
	var i int32
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	for i = 0; i < elLen; i++ {
		eT = eType[i]
		size = Elem[eT].dofs * Elem[eT].nodes
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], 0, size, size)
			return rv
		}()) != 0 {
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			return rv
		}
		if (func() int32 {
			rv = Elem[eT].eload(elElem[i], i, (*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			return rv
		}()) != 0 {
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			return rv
		}
		// add localization of F_e here!
		rv = femLocF_e((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], i, (*[1000000]tVector)(unsafe.Pointer(&F))[:], 1)
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	}
	return rv
}

// femAddThermLoads - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_loads.c:639
func femAddThermLoads() int32 {
	// Adds temperatures as loads to load vector
	// * @return state value
	//
	var rv int32
	var F_e tVector
	var T_e tVector
	var size int32
	var tsize int32
	var eT int32
	var i int32
	var j int32
	var pos int32
	var use int32
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	for i = 0; i < eLen; i++ {
		eT = eType[i]
		tsize = Elem[eT].nodes
		size = Elem[eT].dofs * tsize
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], 0, size, size)
			return rv
		}()) != 0 {
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			return rv
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&T_e))[:], 0, tsize, tsize)
			return rv
		}()) != 0 {
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&T_e))[:])
			return rv
		}
		{
			// get temperature field:
			for j = 0; j < tsize; j++ {
				pos = 1 + eNodesL[eFrom[i]+j]
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&T_e))[:], j+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&uTemp))[:], pos), 0)
			}
		}
		// compute temperature FE:
		rv = Elem[eT].therm(i, c4goUnsafeConvert_int32(&use), (*[1000000]tVector)(unsafe.Pointer(&T_e))[:], (*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
		if use == 1 {
			// add localization of F_e here!
			rv = femLocF_e((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], i, (*[1000000]tVector)(unsafe.Pointer(&F))[:], 1)
		}
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&T_e))[:])
	}
	return rv
}

// e000_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m000.c:28
func e000_test(mPos int32) int32 {
	//
	//   File name: fem_m000.c
	//   Date:      2003/04/16 21:01
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 000 (empty)
	//
	return 0
}

// addMat_000 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m000.c:31
func addMat_000() int32 {
	var rv int32
	var type_ int32
	var num int32
	var val []int32
	var num_rp int32
	var val_rp []int32
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e000_test
	return rv
}

// mat001_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m001.c:28
func mat001_test(mPos int32) int32 {
	//
	//   File name: fem_m001.c
	//   Date:      2003/04/16 21:01
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 000 (empty)
	//
	// Some datatest needed ;-)
	return 0
}

// addMat_001 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m001.c:35
func addMat_001() int32 {
	var rv int32
	var type_ int32 = 1
	var num int32 = 7
	var val []int32 = []int32{1, 2, 5, 38, 37, 39, 36}
	var num_rp int32 = 6
	var val_rp []int32 = []int32{1, 2, 5, 38, 37, 39}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = mat001_test
	return rv
}

// e002_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m002.c:30
func e002_test(mPos int32) int32 {
	//
	//   File name: fem_m002.c
	//   Date:      2003/04/16 21:01
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 002 (2D concrete fracture)
	//
	//  $Id: fem_m002.c,v 1.4 2004/01/10 21:09:29 jirka Exp $
	//
	// Datatest needed ;-)
	return 0
}

// addMat_002 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m002.c:37
func addMat_002() int32 {
	var rv int32
	var type_ int32 = 2
	var num int32 = 9
	var val []int32 = []int32{1, 2, 5, 6, 7, 8, 9, 10, 11}
	var num_rp int32 = 9
	var val_rp []int32 = []int32{1, 2, 5, 6, 7, 8, 9, 10, 11}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e002_test
	return rv
}

// e003_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m003.c:28
func e003_test(mPos int32) int32 {
	//
	//   File name: fem_m003.c
	//   Date:      2004/01/10 17:50
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 003 (3D concrete - Chen+Chen)
	//
	// Datatest needed ;-)
	return 0
}

// addMat_003 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m003.c:35
func addMat_003() int32 {
	var rv int32
	var type_ int32 = 3
	var num int32 = 11
	var val []int32 = []int32{1, 2, 5, 12, 13, 14, 15, 16, 17, 10, 36}
	var num_rp int32 = 2
	var val_rp []int32 = []int32{30, 31}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e003_test
	return rv
}

// e004_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m004.c:28
func e004_test(mPos int32) int32 {
	//
	//   File name: fem_m004.c
	//   Date:      2004/01/10 17:50
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 004 (3D plasticity - Drucker-Prager/von Mises)
	//
	// Datatest needed ;-)
	return 0
}

// addMat_004 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m004.c:35
func addMat_004() int32 {
	var rv int32
	var type_ int32 = 4
	var num int32 = 11
	var val []int32 = []int32{1, 2, 5, 6, 18, 19, 12, 20, 30, 31, 36}
	var num_rp int32 = 6
	var val_rp []int32 = []int32{1, 2, 5, 6, 12, 20}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e004_test
	return rv
}

// mat005_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m005.c:28
func mat005_test(mPos int32) int32 {
	//
	//   File name: fem_m005.c
	//   Date:      2003/04/16 21:01
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 005 (Hooke for assessment)
	//
	// Some datatest needed ;-)
	return 0
}

// addMat_005 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m005.c:34
func addMat_005() int32 {
	var rv int32
	var type_ int32 = 5
	var num int32 = 8
	var val []int32 = []int32{1, 2, 5, 6, 12, 14, 15, 17}
	var num_rp int32 = 8
	var val_rp []int32 = []int32{1, 2, 5, 6, 12, 14, 15, 17}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = mat005_test
	return rv
}

// e006_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m006.c:29
func e006_test(mPos int32) int32 {
	//
	//   File name: fem_m006.c
	//   Date:      2004/01/10 17:50
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 006 (unused)
	//
	//
	// Datatest needed ;-)
	return 0
}

// addMat_006 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m006.c:36
func addMat_006() int32 {
	var rv int32
	var type_ int32 = 6
	var num int32 = 8
	var val []int32 = []int32{1, 2, 5, 6, 10, 15, 16, 17}
	var num_rp int32
	var val_rp []int32
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e006_test
	return rv
}

// mat007_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m007.c:30
func mat007_test(mPos int32) int32 {
	//
	//   File name: fem_m007.c
	//   Date:      2004/09/05 14:16
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 007 (linear orthotropic)
	//
	// Note that material axes must be identical to x,y,z!
	//
	// Some datatest needed ;-)
	return 0
}

// addMat_007 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m007.c:37
func addMat_007() int32 {
	var rv int32
	var type_ int32 = 7
	var num int32 = 10
	var val []int32 = []int32{1, 2, 3, 4, 21, 22, 23, 24, 25, 26}
	var num_rp int32 = 1
	var val_rp []int32 = []int32{40}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = mat007_test
	return rv
}

// e008_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m008.c:30
func e008_test(mPos int32) int32 {
	//
	//   File name: fem_m008.c
	//   Date:      2006/00/11 14:01
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2006 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 008 (2D concrete fracture)
	//
	//  $Id: fem_m008.c,v 1.4 2004/01/10 21:09:29 jirka Exp $
	//
	// Datatest needed ;-)
	return 0
}

// addMat_008 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m008.c:37
func addMat_008() int32 {
	var rv int32
	var type_ int32 = 8
	var num int32 = 12
	var val []int32 = []int32{1, 2, 5, 7, 8, 9, 10, 11, 29, 32, 33, 34}
	// SELE=type, SHTYPE=shear reduction type, CRTYPE=fix/rot cracks
	var num_rp int32 = 1
	// WX = softening parameter
	var val_rp []int32 = []int32{28}
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e008_test
	return rv
}

// e009_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m009.c:33
func e009_test(mPos int32) int32 {
	//
	//   File name: fem_m009.c
	//   Date:      2006/11/26 16:04
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2006 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 009 (brittle - clay brick)
	//
	// Datatest needed ;-)
	return 0
}

// fem_m09_D_2d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m009.c:48
func fem_m09_D_2d(ePos int32, iPoint int32, A float64, epsilon []tVector, Mode int32, Problem int32, D []tMatrix) int32 {
	// fills (allocated!) D matrix
	// * @param ePos finite element position
	// * @param iPoint finite element (integration) point position
	// * @param A area size
	// * @param epsilon strain vector (NULL if unused)
	// * @param Mode mode  AF_YES means changes, AF_NO=previous state
	// * @param Problem 0=plane stress, 1=plane strain (1 is now ignored!)
	// * @param D matrix to be filled
	//
	var rv int32
	var nu float64
	var E float64
	E = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	// boring linear behaviour
	rv = D_HookIso_planeRaw(E, nu, Problem, D)
	return rv
}

// addMat_009 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m009.c:124
func addMat_009() int32 {
	var rv int32
	var type_ int32 = 9
	var num int32 = 8
	var val []int32 = []int32{1, 2, 5, 7, 8, 9, 10, 27}
	var num_rp int32
	var val_rp []int32
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e009_test
	return rv
}

// e010_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m010.c:28
func e010_test(mPos int32) int32 {
	//
	//   File name: fem_m009.c
	//   Date:      2006/11/26 16:04
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2006 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 010 (compression-only material: concrete)
	//
	// Datatest needed ;-)
	return 0
}

// addMat_010 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m010.c:34
func addMat_010() int32 {
	var rv int32
	var type_ int32 = 10
	var num int32 = 6
	var val []int32 = []int32{1, 2, 5, 7, 8, 10}
	var num_rp int32
	var val_rp []int32
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = e010_test
	return rv
}

// mat011_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m011.c:30
func mat011_test(mPos int32) int32 {
	//
	//   File name: fem_m011.c
	//   Date:      2015/02/05 20:46
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2015 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	// FEM Solver - Material 011 (linear trnasversely isotropic)
	//
	// Note that material axes must be identical to x,y,z!
	//
	// Some datatest needed ;-)
	return 0
}

// addMat_011 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_m011.c:37
func addMat_011() int32 {
	var rv int32
	var type_ int32 = 11
	var num int32 = 6
	var val []int32 = []int32{1, 2, 4, 21, 22, 24}
	var num_rp int32
	var val_rp []int32
	if type_ != femAddMat(type_) {
		return -3
	}
	Mat[type_].num = num
	Mat[type_].val = val
	Mat[type_].num_rp = num_rp
	Mat[type_].val_rp = val_rp
	Mat[type_].test = mat011_test
	return rv
}

// Mat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mat.c:33
//
//   File name: fem_elem.c
//   Date:      2003/04/16 20:38
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - element definition
//
//  $Id: fem_mat.c,v 1.4 2004/01/10 21:09:29 jirka Exp $
//
// Included headers:
// definitions of data structures
// elements
var Mat []tMat

// matLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mat.c:34
// number of elements
var matLen int32

// femAddMat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mat.c:40
func femAddMat(type_ int32) int32 {
	// Adds new (empty) element structure
	// * @param type element type number
	// * @return element type number (or value >= 0 on error)
	//
	var tmpMat []tMat
	var i int32
	if type_ != matLen {
		noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Incorrect material type number\x00"), type_)
		return -3
	}
	if len((func() []tMat {
		tmpMat = (*[1000000]tMat)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := make([]byte, uint32(matLen+1)*uint32(1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		return tmpMat
	}())) == 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Out of memory during material type preparing\x00"))
		return -4
	}
	if matLen > 0 {
		for i = 0; i < matLen; i++ {
			tmpMat[i] = Mat[i]
		}
	}
	_ = Mat
	Mat = nil
	Mat = tmpMat
	tmpMat = nil
	Mat[matLen].type_ = type_
	Mat[matLen].num = 0
	Mat[matLen].val = nil
	Mat[matLen].num_rp = 0
	Mat[matLen].val_rp = nil
	Mat[matLen].test = nil
	matLen++
	return Mat[matLen-1].type_
}

// femMatNull - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:33
func femMatNull(mat []tMatrix) {
	//
	//   File name: fem_math.c
	//   Date:      2003/04/12 12:44
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - matrix library
	//
	//  $Id: fem_math.c,v 1.46 2005/07/11 17:56:16 jirka Exp $
	//
	// MATRIX ***
	mat[0].type_ = 0
	mat[0].rows = 0
	mat[0].cols = 0
	mat[0].len_ = 0
	mat[0].pos = nil
	mat[0].data = nil
	mat[0].frompos = nil
	mat[0].defpos = nil
}

// femMatFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:45
func femMatFree(mat []tMatrix) {
	mat[0].type_ = 0
	mat[0].rows = 0
	mat[0].cols = 0
	mat[0].len_ = 0
	femIntFree(mat[0].pos)
	femDblFree(mat[0].data)
	femIntFree(mat[0].frompos)
	femIntFree(mat[0].defpos)
}

// femMatAlloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:57
func femMatAlloc(mat []tMatrix, type_ int32, rows int32, cols int32, bandwidth int32, rowdesc []int32) int32 {
	var sum int32
	var i int32
	femMatNull(mat)
	if type_ >= 0 && type_ <= 1 {
		mat[0].type_ = type_
		switch type_ {
		case 0:
			mat[0].rows = rows
			mat[0].cols = cols
			mat[0].len_ = cols * rows
			if len((func() []float64 {
				mat[0].data = femDblAlloc(mat[0].len_)
				return mat[0].data
			}())) == 0 {
				goto memFree
			}
			mat[0].pos = nil
			mat[0].frompos = nil
			mat[0].defpos = nil
		case 1:
			mat[0].rows = rows
			mat[0].cols = cols
			if len((func() []int32 {
				mat[0].defpos = femIntAlloc(mat[0].rows)
				return mat[0].defpos
			}())) == 0 {
				goto memFree
			}
			if len((func() []int32 {
				mat[0].frompos = femIntAlloc(mat[0].rows)
				return mat[0].frompos
			}())) == 0 {
				goto memFree
			}
			if bandwidth > 0 && len(rowdesc) == 0 {
				mat[0].len_ = rows * bandwidth
				if len((func() []float64 {
					mat[0].data = femDblAlloc(mat[0].len_)
					return mat[0].data
				}())) == 0 {
					goto memFree
				}
				if len((func() []int32 {
					mat[0].pos = femIntAlloc(mat[0].len_)
					return mat[0].pos
				}())) == 0 {
					goto memFree
				}
				for i = 0; i < rows; i++ {
					mat[0].frompos[i] = bandwidth * i
				}
			} else {
				sum = 0
				for i = 0; i < rows; i++ {
					sum += rowdesc[i]
					mat[0].defpos[i] = rowdesc[i]
					mat[0].frompos[i] = sum - rowdesc[i]
				}
				mat[0].len_ = sum
				if len((func() []float64 {
					mat[0].data = femDblAlloc(mat[0].len_)
					return mat[0].data
				}())) == 0 {
					goto memFree
				}
				if len((func() []int32 {
					mat[0].pos = femIntAlloc(sum)
					return mat[0].pos
				}())) == 0 {
					goto memFree
				}
			}
			break
		}
		return 0
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Matrix type unsupported\x00"), type_)
		return -3
	}
memFree:
	;
	femMatFree(mat)
	return -4
}

// femMatGet - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:142
func femMatGet(mat []tMatrix, row int32, col int32) float64 {
	// Gets value from matrix
	// * @param mat matrix
	// * @param row row
	// * @param row collumn
	// * @return value
	//
	var pos int32
	var i int32
	if row < 0 || col < 0 {
		return float64(0)
	}
	if row > mat[0].rows || col > mat[0].cols {
		return float64(0)
	}
	switch mat[0].type_ {
	case 0:
		pos = (row-1)*mat[0].cols + (col - 1)
		return mat[0].data[pos]
	case 1:
		for i = mat[0].frompos[row-1]; i < mat[0].frompos[row-1]+mat[0].defpos[row-1]; i++ {
			if mat[0].pos[i] == 0 {
				break
			}
			if mat[0].pos[i] == col {
				return mat[0].data[i]
				break
			}
		}
	default:
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid matrix type\x00"))
		return 0
		break
	}
	return 0
}

// femMatPutAdd - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:185
func femMatPutAdd(mat []tMatrix, row int32, col int32, val float64, mode int32) (c4goDefaultReturn int32) {
	// Adds value to matrix
	// * @param mat matrix
	// * @param row row
	// * @param col column
	// * @param val value
	// * @param mode FEM_PUT for putting ("=") FEM_ADD for adding ("+=")
	// * @return  status
	//
	var pos int32
	var i int32
	if row < 0 || col < 0 {
		return -10
	}
	if row > mat[0].rows || col > mat[0].cols {
		return -11
	}
	switch mat[0].type_ {
	case 0:
		pos = (row-1)*mat[0].cols + (col - 1)
		if mode == 1 {
			mat[0].data[pos] += val
		} else {
			mat[0].data[pos] = val
		}
		return 0
	case 1:
		{
			// this is more complicated
			for i = mat[0].frompos[row-1]; i < mat[0].frompos[row-1]+mat[0].defpos[row-1]; i++ {
				if mat[0].pos[i] == col {
					if mode == 1 {
						mat[0].data[i] += val
					} else {
						mat[0].data[i] = val
					}
					return 0
				}
				if mat[0].pos[i] == 0 {
					// empty field found
					mat[0].pos[i] = col
					if mode == 1 {
						mat[0].data[i] += val
					} else {
						mat[0].data[i] = val
					}
					return 0
				}
			}
		}
		// if we are here
		//           * because reallocation is needed !
		//
		noarch.Fprintf(msgout, []byte("[E] %s [%li,%li]!\n\x00"), []byte("Matrix reallocation needed - requested unwritten code\x00"), row, col)
		noarch.Exit(-11)
		return -11
	default:
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid matrix type\x00"))
		return -3
		break
	}
	return
}

// femMatPrn - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:238
func femMatPrn(mat []tMatrix, name []byte) {
	// Prints matrix to stdout, works only in DEVEL mode
	var i int32
	var j int32
	noarch.Fprintf(msgout, []byte("\n%s %s %s[%li,%li]:\n\x00"), []byte("Matrix\x00"), name, []byte("listing\x00"), mat[0].rows, mat[0].cols)
	for i = 1; i <= mat[0].rows; i++ {
		for j = 1; j <= mat[0].cols; j++ {
			noarch.Fprintf(msgout, []byte(" %f \x00"), femMatGet(mat, i, j))
		}
		noarch.Fprintf(msgout, []byte("\n\x00"))
	}
	noarch.Fprintf(msgout, []byte("\n\x00"))
}

// femMatPrnF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:261
func femMatPrnF(fname []byte, mat []tMatrix) int32 {
	// Saves matrix to file
	// * @param fname name of file
	// * @param mat matrix to be printed
	// * @return status
	//
	var fw *noarch.File
	var rv int32
	var i int32
	var j int32
	if (func() *noarch.File {
		fw = noarch.Fopen(fname, []byte("w\x00"))
		return fw
	}()) == nil {
		return -2
	}
	for i = 1; i <= mat[0].rows; i++ {
		for j = 1; j <= mat[0].cols; j++ {
			noarch.Fprintf(fw, []byte(" %e \x00"), femMatGet(mat, i, j))
		}
		noarch.Fprintf(fw, []byte("\n\x00"))
	}
	if noarch.Fclose(fw) != 0 {
		rv = -2
	}
	return rv
}

// femSparseMatPrnF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:288
func femSparseMatPrnF(fname []byte, mat []tMatrix) int32 {
	// Saves matrix to file IN SPARSE FORM
	// * @param fname name of file
	// * @param mat matrix to be printed
	// * @return status
	//
	var fw *noarch.File
	var rv int32
	var i int32
	var j int32
	var sum int32
	if mat[0].type_ != 1 {
		return -3
	}
	if (func() *noarch.File {
		fw = noarch.Fopen(fname, []byte("w\x00"))
		return fw
	}()) == nil {
		return -2
	}
	noarch.Fprintf(fw, []byte("%li %li\n\x00"), mat[0].rows, mat[0].cols)
	for i = 0; i < mat[0].rows; i++ {
		sum = 0
		for j = mat[0].frompos[i]; j < mat[0].frompos[i]+mat[0].defpos[i]; j++ {
			if mat[0].pos[j] >= 0 {
				sum++
			} else {
				break
			}
		}
		noarch.Fprintf(fw, []byte("%li %li \x00"), i+1, sum)
		for j = mat[0].frompos[i]; j < mat[0].frompos[i]+sum; j++ {
			noarch.Fprintf(fw, []byte("%li %e \x00"), mat[0].pos[j], mat[0].data[j])
		}
		noarch.Fprintf(fw, []byte("\n\x00"))
	}
	if noarch.Fclose(fw) != 0 {
		rv = -2
	}
	return rv
}

// femSparseMarketMatPrnF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:329
func femSparseMarketMatPrnF(fname []byte, mat []tMatrix) int32 {
	// Saves matrix to file IN SPARSE FORM (MatrixMarket file standard)
	// * @param fname name of file
	// * @param mat matrix to be printed
	// * @return status
	//
	var fw *noarch.File
	var rv int32
	var i int32
	var j int32
	var sum int32
	if mat[0].type_ != 1 {
		return -3
	}
	if (func() *noarch.File {
		fw = noarch.Fopen(fname, []byte("w\x00"))
		return fw
	}()) == nil {
		return -2
	}
	noarch.Fprintf(fw, []byte("%%%%MatrixMarket matrix coordinate real general\n\x00"))
	noarch.Fprintf(fw, []byte("%li %li %li\n\x00"), mat[0].rows, mat[0].cols, mat[0].len_)
	for i = 0; i < mat[0].rows; i++ {
		sum = 0
		for j = mat[0].frompos[i]; j < mat[0].frompos[i]+mat[0].defpos[i]; j++ {
			if mat[0].pos[j] >= 0 {
				sum++
			} else {
				break
			}
		}
		for j = mat[0].frompos[i]; j < mat[0].frompos[i]+sum; j++ {
			noarch.Fprintf(fw, []byte("%li %li %e\n\x00"), i+1, mat[0].pos[j], mat[0].data[j])
		}
	}
	if noarch.Fclose(fw) != 0 {
		rv = -2
	}
	return rv
}

// femSparseMatReadF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:368
func femSparseMatReadF(fname []byte, mat []tMatrix) int32 {
	// Reads matrix from file IN SPARSE FORM
	// * @param fname name of file
	// * @param mat matrix (must be unallocated)
	// * @return status
	//
	var fw *noarch.File
	var rv int32
	var i int32
	var j int32
	var k int32
	var tmp int32
	var sum int32
	var size int32
	var ensize int32
	var pos0 []int32
	var data0 []float64
	if (func() *noarch.File {
		fw = noarch.Fopen(fname, []byte("r\x00"))
		return fw
	}()) == nil {
		return -2
	}
	noarch.Fscanf(fw, []byte("%li %li\n\x00"), (*[1000000]int32)(unsafe.Pointer(&mat[0].rows))[:], (*[1000000]int32)(unsafe.Pointer(&mat[0].cols))[:])
	if mat[0].rows <= 0 || mat[0].cols <= 0 {
		return -2
	}
	if len((func() []int32 {
		mat[0].frompos = femIntAlloc(mat[0].rows)
		return mat[0].frompos
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []int32 {
		mat[0].defpos = femIntAlloc(mat[0].rows)
		return mat[0].defpos
	}())) == 0 {
		rv = -4
		goto memFree
	}
	size = mat[0].rows * 300
	if len((func() []int32 {
		mat[0].pos = femIntAlloc(size)
		return mat[0].pos
	}())) == 0 {
		rv = -4
		goto memFree
	}
	if len((func() []float64 {
		mat[0].data = femDblAlloc(size)
		return mat[0].data
	}())) == 0 {
		rv = -4
		goto memFree
	}
	mat[0].type_ = 1
	sum = 0
	for i = 0; i < mat[0].rows; i++ {
		noarch.Fscanf(fw, []byte("%li %li \x00"), c4goUnsafeConvert_int32(&tmp), mat[0].defpos[i:])
		if i > 0 {
			mat[0].frompos[i] = mat[0].frompos[i-1] + mat[0].defpos[i-1]
		} else {
			// first row
			mat[0].frompos[i] = 0
		}
		for j = 0; j < mat[0].defpos[i]; j++ {
			if sum >= size {
				// enlarge "data" and "pos"
				ensize = size + 2*size*(i/mat[0].rows)
				if len((func() []int32 {
					pos0 = femIntAlloc(ensize)
					return pos0
				}())) == 0 {
					rv = -4
					goto memFree
				}
				if len((func() []float64 {
					data0 = femDblAlloc(ensize)
					return data0
				}())) == 0 {
					rv = -4
					goto memFree
				}
				for k = 0; k < sum; k++ {
					pos0[k] = mat[0].pos[k]
					data0[k] = mat[0].data[k]
				}
				_ = mat[0].pos
				_ = mat[0].data
				mat[0].pos = pos0
				mat[0].data = data0
				pos0 = nil
				data0 = nil
			}
			noarch.Fscanf(fw, []byte("%li %f \x00\x00"), mat[0].pos[sum:], mat[0].data[sum:])
			sum++
		}
	}
	if noarch.Fclose(fw) != 0 {
		rv = -2
	}
	return rv
memFree:
	;
	femMatFree(mat)
	return rv
}

// femMatOut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:447
func femMatOut(a []tMatrix, fw *noarch.File) int32 {
	// Writes matrix to stream (FILE *)
	// * @param a matrix
	// * @param fw stream
	// * @return stave value
	//
	var rv int32
	var i int32
	var j int32
	noarch.Fprintf(fw, []byte(" %li %li\n\x00"), a[0].rows, a[0].cols)
	for i = 1; i <= a[0].rows; i++ {
		for j = 1; j <= a[0].cols; j++ {
			noarch.Fprintf(fw, []byte(" %e \n\x00"), femMatGet(a, i, j))
		}
	}
	return rv
}

// femMatSetZeroBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:483
func femMatSetZeroBig(a []tMatrix) {
	// Sets all of matrix contents to 0
	var i int32
	for i = 0; i < a[0].len_; i++ {
		a[0].data[i] = 0
	}
}

// femMatSetZero - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:527
func femMatSetZero(a []tMatrix) {
	// Sets all of matrix contents to 0 FOR SMALL DATA
	var i int32
	for i = 0; i < a[0].len_; i++ {
		a[0].data[i] = 0
	}
}

// femMatSetZeroRow - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:535
func femMatSetZeroRow(a []tMatrix, row int32) {
	// Sets matrix row to 0
	var i int32
	if row < 1 || row > a[0].rows {
		return
	}
	if a[0].type_ == 1 {
		for i = a[0].frompos[row-1]; i < a[0].frompos[row-1]+a[0].defpos[row-1]; i++ {
			if a[0].pos[i] == 0 {
				break
			}
			a[0].data[i] = 0
		}
	} else {
		//fprintf(msgout,"zero on %li\n",i);
		for i = 1; i <= a[0].cols; i++ {
			femMatPutAdd(a, row, i, 0, 0)
		}
	}
}

// femMatSetZeroCol - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:592
func femMatSetZeroCol(a []tMatrix, Col int32) {
	// Sets all of matrix contents to 0
	var i int32
	var j int32
	var ifrom int32
	var ito int32
	if a[0].type_ == 1 {
		for i = 0; i < a[0].len_; i++ {
			if a[0].pos[i] == Col {
				a[0].data[i] = 0
			}
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			femMatPutAdd(a, i, Col, 0, 0)
		}
	}
}

// femVecNull - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:699
func femVecNull(mat []tVector) {
	// VECTOR ***
	mat[0].type_ = 0
	mat[0].rows = 0
	mat[0].len_ = 0
	mat[0].pos = nil
	mat[0].data = nil
}

// femVecFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:708
func femVecFree(mat []tVector) {
	mat[0].type_ = 0
	mat[0].rows = 0
	mat[0].len_ = 0
	femIntFree(mat[0].pos)
	femDblFree(mat[0].data)
}

// femVecAlloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:718
func femVecAlloc(mat []tVector, type_ int32, rows int32, items int32) int32 {
	femVecNull(mat)
	if type_ >= 0 && type_ <= 1 {
		mat[0].type_ = type_
		switch type_ {
		case 0:
			mat[0].rows = rows
			mat[0].len_ = rows
			if len((func() []float64 {
				mat[0].data = femDblAlloc(mat[0].len_)
				return mat[0].data
			}())) == 0 {
				goto memFree
			}
			mat[0].pos = nil
		case 1:
			// VEC_SPAR cannot be used ;-)
			noarch.Exit(-3)
			mat[0].rows = rows
			if items > 0 {
				mat[0].len_ = items
				if len((func() []float64 {
					mat[0].data = femDblAlloc(mat[0].len_)
					return mat[0].data
				}())) == 0 {
					goto memFree
				}
				if len((func() []int32 {
					mat[0].pos = femIntAlloc(mat[0].len_)
					return mat[0].pos
				}())) == 0 {
					goto memFree
				}
			} else {
				noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Number of sparse vector items MUST BE nonzero\x00"))
				goto memFree
			}
			break
		}
		return 0
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Matrix type unsupported\x00"), type_)
		return -3
	}
memFree:
	;
	femVecFree(mat)
	return -4
}

// femVecPutAdd - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:776
func femVecPutAdd(vec []tVector, pos int32, val float64, mode int32) int32 {
	if pos > vec[0].rows {
		// Adds value to vector
		// * @param vec vector
		// * @param pos row to add value
		// * @param val value
		// * @param mode FEM_PUT for putting ("=") FEM_ADD for adding ("+=")
		// * @return  status
		//
		noarch.Fprintf(msgout, []byte("[E] %s: %li > %li!\n\x00"), []byte("Index outside vector (Add/Put)\x00"), pos, vec[0].rows)
		return -11
	}
	switch vec[0].type_ {
	case 0:
		if mode == 0 {
			// put
			vec[0].data[pos-1] = val
		} else {
			// add
			vec[0].data[pos-1] += val
		}
	case 1:
		// unimplemented
		noarch.Exit(-3)
	default:
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid vector type (Add/Put)\x00"))
		return -5
		break
	}
	return 0
}

// femVecGet - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:811
func femVecGet(vec []tVector, pos int32) float64 {
	if pos > vec[0].rows || pos < 1 {
		// Gets value from vector
		// * @param vec vector
		// * @param pos row to add value
		// * @return value
		//
		noarch.Fprintf(msgout, []byte("[E] %s: %li/%li!\n\x00"), []byte("Index outside vector (Get)\x00"), pos, vec[0].rows)
		return float64(0)
	}
	return vec[0].data[pos-1]
}

// femVecPrn - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:842
func femVecPrn(mat []tVector, name []byte) {
	// Prints vector to stdout, works only in DEVEL mode
	var i int32
	noarch.Fprintf(msgout, []byte("\n%s %s %s[%li]:\n\x00"), []byte("Vector\x00"), name, []byte("listing\x00"), mat[0].rows)
	for i = 1; i <= mat[0].rows; i++ {
		noarch.Fprintf(msgout, []byte(" %f \x00"), femVecGet(mat, i))
	}
	noarch.Fprintf(msgout, []byte("\n\x00"))
}

// femVecPrnF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:861
func femVecPrnF(fname []byte, mat []tVector) int32 {
	// Saves vector to file
	// * @param fname name of file
	// * @param mat vector to be printed
	// * @return status
	//
	var fw *noarch.File
	var rv int32
	var i int32
	if (func() *noarch.File {
		fw = noarch.Fopen(fname, []byte("w\x00"))
		return fw
	}()) == nil {
		return -2
	}
	for i = 1; i <= mat[0].rows; i++ {
		noarch.Fprintf(fw, []byte(" %e \x00"), femVecGet(mat, i))
	}
	noarch.Fprintf(fw, []byte("\n\x00"))
	if noarch.Fclose(fw) != 0 {
		rv = -2
	}
	return rv
}

// femVecOut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:886
func femVecOut(a []tVector, fw *noarch.File) int32 {
	// Writes vector to stream (FILE *)
	// * @ a vector
	// * @ fw stream
	// * @return stave value
	//
	var rv int32
	var i int32
	noarch.Fprintf(fw, []byte(" %li\n\x00"), a[0].rows)
	for i = 1; i <= a[0].rows; i++ {
		noarch.Fprintf(fw, []byte(" %e \n\x00"), femVecGet(a, i))
	}
	return rv
}

// femVecSetZeroBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:920
func femVecSetZeroBig(a []tVector) {
	// Sets all of vertor contents to 0
	var i int32
	for i = 0; i < a[0].len_; i++ {
		a[0].data[i] = 0
	}
}

// femVecSetZero - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:964
func femVecSetZero(a []tVector) {
	// Sets all of vertor contents to 0 FOR SMALL DATA
	var i int32
	for i = 0; i < a[0].len_; i++ {
		a[0].data[i] = 0
	}
}

// femVecClone - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:974
func femVecClone(src []tVector, dest []tVector) int32 {
	// Clones vectors: src to dest both must be VEC_FULL, same size and allocated
	// * @param src original vector
	// * @param dest modified vector
	//
	var i int32
	if src[0].type_ != 0 || dest[0].type_ != 0 {
		return -5
	}
	if src[0].len_ != dest[0].len_ {
		return -9
	}
	for i = 0; i < src[0].len_; i++ {
		dest[0].data[i] = src[0].data[i]
	}
	return 0
}

// femVecVecMultBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1017
func femVecVecMultBig(a []tVector, b []tVector) float64 {
	// ------------------    Matrix Operations    --------------------
	// vector multiplication (scalar) (a[n]^t * b[n])
	// * @param a vector
	// * @param b vector
	// * @return multiplication product
	//
	var i int32
	var mult float64
	if a[0].rows != b[0].rows {
		return float64(0)
	}
	if a[0].rows <= 0 || b[0].rows <= 0 {
		return float64(0)
	}
	mult = 0
	if a[0].type_ == 0 && b[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			mult += a[0].data[i] * b[0].data[i]
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			mult += femVecGet(a, i) * femVecGet(b, i)
		}
	}
	return mult
}

// femVecVecMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1107
func femVecVecMult(a []tVector, b []tVector) float64 {
	// vector multiplication (scalar) (a[n]^t * b[n])  FOR SMALL VECTORS
	// * @param a vector
	// * @param b vector
	// * @return multiplication product
	//
	var i int32
	var mult float64
	if a[0].rows != b[0].rows {
		return float64(0)
	}
	if a[0].rows <= 0 || b[0].rows <= 0 {
		return float64(0)
	}
	mult = 0
	if a[0].type_ == 0 && b[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			mult += a[0].data[i] * b[0].data[i]
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			mult += femVecGet(a, i) * femVecGet(b, i)
		}
	}
	return mult
}

// femVecVecMulttoMat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1143
func femVecVecMulttoMat(a []tVector, b []tVector, c []tMatrix) int32 {
	// vector multiplication (matrix) (a[n] * b[n]^t)
	// * @param a vector
	// * @param b vector
	// * @param c matrix (result)
	// * @return status
	//
	var i int32
	var j int32
	if a[0].rows != b[0].rows {
		return -9
	}
	if a[0].rows != c[0].rows || b[0].rows != c[0].cols {
		return -9
	}
	if a[0].type_ != 0 {
		return -5
	}
	if a[0].type_ == 0 && b[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			for j = 0; j < a[0].rows; j++ {
				c[0].data[i*c[0].cols+j] = a[0].data[i] * b[0].data[j]
			}
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			for j = 1; j <= a[0].rows; j++ {
				femMatPutAdd(c, i, j, femVecGet(a, i)*femVecGet(b, j), 0)
			}
		}
	}
	return 0
}

// femValVecMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1183
func femValVecMult(val float64, a []tVector, b []tVector) int32 {
	// number by vector multiplication (b[n] = val * a[n])
	// * @param val number
	// * @param a original vector (will not be modified)
	// * @param b result (vector) - must be allocated and must have proper size
	// * @return status
	//
	var i int32
	if a[0].rows != b[0].rows {
		return -9
	}
	if a[0].type_ != b[0].type_ {
		return -3
	}
	if a[0].type_ != 0 {
		// will be fixed
		return -3
	}
	for i = 0; i < a[0].len_; i++ {
		b[0].data[i] = a[0].data[i] * val
	}
	return 0
}

// femValVecMultSelf - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1205
func femValVecMultSelf(val float64, a []tVector) int32 {
	// number by vector multiplication (a[n] = val * a[n])
	// * @param val number
	// * @param a original vector (WILL BE modified)
	// * @return status
	//
	var i int32
	for i = 0; i < a[0].len_; i++ {
		a[0].data[i] *= val
	}
	return 0
}

// femValMatMultSelf - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1218
func femValMatMultSelf(val float64, a []tMatrix) int32 {
	// number by matrix multiplication (a[n] = val * a[n])
	// * @param val number
	// * @param a original number (WILL BE modified)
	// * @return status
	//
	var i int32
	for i = 0; i < a[0].len_; i++ {
		a[0].data[i] *= val
	}
	return 0
}

// femVecMatMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1232
func femVecMatMult(a []tVector, b []tMatrix, c []tVector) int32 {
	// vector by matrix multiplication (a[n]^t * b[n,m]  = c[m])
	// * @param a vector
	// * @param b matrix
	// * @param vector (result)
	// * @return status
	//
	var i int32
	var j int32
	var val float64
	if a[0].rows != b[0].rows || b[0].cols != c[0].rows {
		return -9
	}
	if c[0].type_ != 0 {
		return -3
	}
	if a[0].type_ == 0 && b[0].type_ == 0 && c[0].type_ == 0 {
		for i = 0; i < b[0].cols; i++ {
			val = 0
			for j = 0; j < a[0].rows; j++ {
				val += a[0].data[j] * b[0].data[i+b[0].cols*j]
			}
			c[0].data[i] = val
		}
	} else {
		for i = 1; i <= b[0].cols; i++ {
			val = 0
			for j = 1; j <= a[0].rows; j++ {
				val += femVecGet(a, j) * femMatGet(b, j, i)
			}
			femVecPutAdd(c, i, val, 0)
		}
	}
	return 0
}

// femVecMatVecMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1275
func femVecMatVecMult(a []tVector, b []tMatrix, c []tVector) float64 {
	// Vector by matrix by vector multiplication (a[n]^t * b[n,m] * c[m]  = d)
	// * For small full matrices only (it is slow).
	// * @param a vector
	// * @param b matrix
	// * @param c vector
	// * @return constant (result)
	//
	var i int32
	var j int32
	var val float64
	var sum_tot float64
	sum_tot = 0
	if a[0].rows != b[0].rows || b[0].cols != c[0].rows {
		return float64(-9)
	}
	if c[0].type_ != 0 {
		return float64(-3)
	}
	if a[0].type_ == 0 && b[0].type_ == 0 && c[0].type_ == 0 {
		for i = 0; i < b[0].cols; i++ {
			val = 0
			for j = 0; j < a[0].rows; j++ {
				val += a[0].data[j] * b[0].data[i+b[0].cols*j]
			}
			sum_tot += c[0].data[i] * val
		}
	} else {
		for i = 1; i <= b[0].cols; i++ {
			val = 0
			for j = 1; j <= a[0].rows; j++ {
				val += femVecGet(a, j) * femMatGet(b, j, i)
			}
			sum_tot += femVecGet(c, i) * val
		}
	}
	return sum_tot
}

// femMatVecMultBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1350
func femMatVecMultBig(a []tMatrix, b []tVector, c []tVector) int32 {
	// Matrix by vector multiplication (a[m,n]*b[n] = b[n])
	// * @param a matrix
	// * @param b vector
	// * @param c vector (result)
	// * @return status
	//
	var i int32
	var j int32
	var val float64
	if a[0].cols != b[0].rows || c[0].rows != a[0].rows {
		return -9
	}
	if c[0].type_ != 0 {
		return -3
	}
	if a[0].type_ == 0 && b[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			val = 0
			for j = 0; j < a[0].cols; j++ {
				val += b[0].data[j] * a[0].data[j+i*a[0].cols]
			}
			c[0].data[i] = val
		}
	} else {
		if a[0].type_ == 1 && b[0].type_ == 0 {
			femVecSetZero(c)
			for i = 0; i < a[0].rows; i++ {
				val = 0
				for j = a[0].frompos[i]; j < a[0].frompos[i]+a[0].defpos[i]; j++ {
					if a[0].pos[j] <= 0 {
						break
					}
					val += a[0].data[j] * b[0].data[a[0].pos[j]-1]
				}
				c[0].data[i] = val
			}
		} else {
			for i = 1; i <= a[0].rows; i++ {
				val = 0
				for j = 1; j <= a[0].cols; j++ {
					val += femMatGet(a, i, j) * femVecGet(b, j)
				}
				femVecPutAdd(c, i, val, 0)
			}
		}
	}
	return 0
}

// femMatVecMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1459
func femMatVecMult(a []tMatrix, b []tVector, c []tVector) int32 {
	// Matrix by vector multiplication (a[m,n]*b[n] = b[n]) FOR SMALL DATA
	// * @param a matrix
	// * @param b vector
	// * @param c vector (result)
	// * @return status
	//
	var i int32
	var j int32
	var val float64
	if a[0].cols != b[0].rows || c[0].rows != a[0].rows {
		return -9
	}
	if c[0].type_ != 0 {
		return -3
	}
	if a[0].type_ == 0 && b[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			val = 0
			for j = 0; j < a[0].cols; j++ {
				val += b[0].data[j] * a[0].data[j+i*a[0].cols]
			}
			c[0].data[i] = val
		}
	} else {
		if a[0].type_ == 1 && b[0].type_ == 0 {
			femVecSetZero(c)
			for i = 0; i < a[0].rows; i++ {
				val = 0
				for j = a[0].frompos[i]; j < a[0].frompos[i]+a[0].defpos[i]; j++ {
					if a[0].pos[j] <= 0 {
						break
					}
					val += a[0].data[j] * b[0].data[a[0].pos[j]-1]
				}
				c[0].data[i] = val
			}
		} else {
			for i = 1; i <= a[0].rows; i++ {
				val = 0
				for j = 1; j <= a[0].cols; j++ {
					val += femMatGet(a, i, j) * femVecGet(b, j)
				}
				femVecPutAdd(c, i, val, 0)
			}
		}
	}
	return 0
}

// femVecLinCombBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1543
func femVecLinCombBig(amult float64, a []tVector, bmult float64, b []tVector, c []tVector) int32 {
	// linear combination of vectors am*a[m,n]+ bm*b[m,n] = c[m,n] (c..MAT_FULL)
	// * @param am  "a" vector multiplier
	// * @param a vector
	// * @param bm  "b" vector multiplier
	// * @param b vector
	// * @param c vector (result)
	// * @return status
	//
	var i int32
	if a[0].rows != b[0].rows {
		return 0
	}
	if a[0].rows <= 0 || b[0].rows <= 0 {
		return 0
	}
	if a[0].type_ == 0 && b[0].type_ == 0 && c[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			c[0].data[i] = amult*a[0].data[i] + bmult*b[0].data[i]
		}
	} else {
		// VERY SLOW CODE:
		for i = 1; i <= a[0].rows; i++ {
			femVecPutAdd(c, i, femVecGet(a, i)*amult+femVecGet(b, i)*bmult, 0)
		}
	}
	return 0
}

// femVecLinComb - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1632
func femVecLinComb(amult float64, a []tVector, bmult float64, b []tVector, c []tVector) int32 {
	// linear combination of vectors am*a[m,n]+ bm*b[m,n] = c[m,n] (c..MAT_FULL)
	// * @param am  "a" vector multiplier
	// * @param a vector
	// * @param bm  "b" vector multiplier
	// * @param b vector
	// * @param c vector (result)
	// * @return status
	//
	var i int32
	if a[0].rows != b[0].rows || b[0].rows != c[0].rows {
		return -9
	}
	if c[0].type_ != 0 {
		return -3
	}
	if a[0].type_ == 0 && b[0].type_ == 0 && c[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			c[0].data[i] = amult*a[0].data[i] + bmult*b[0].data[i]
		}
	} else {
		// SLOW CODE:
		for i = 1; i <= a[0].rows; i++ {
			femVecPutAdd(c, i, femVecGet(a, i)*amult+femVecGet(b, i)*bmult, 0)
		}
	}
	return 0
}

// femMatMatMult - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1665
func femMatMatMult(a []tMatrix, b []tMatrix, c []tMatrix) int32 {
	// matrix by matrix multiplication a[m,n]*b[n,h] = c[m,h]
	// * @param a matrix
	// * @param b matrix
	// * @param c matrix (result)
	// * @return status
	//
	var i int32
	var j int32
	var k int32
	var val float64
	if a[0].cols != b[0].rows || b[0].cols != c[0].cols || a[0].rows != c[0].rows {
		return -9
	}
	if c[0].type_ != 0 {
		return -3
	}
	if a[0].type_ == 0 && b[0].type_ == 0 && c[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			for j = 0; j < b[0].cols; j++ {
				val = 0
				for k = 0; k < a[0].cols; k++ {
					//val += femMatGet(a, i,k)*femMatGet(b, k,j);
					val += a[0].data[i*a[0].cols+k] * b[0].data[k*b[0].cols+j]
				}
				//femMatPut(c, i,j, val);
				c[0].data[i*c[0].cols+j] = val
			}
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			for j = 1; j <= b[0].cols; j++ {
				val = 0
				for k = 1; k <= a[0].cols; k++ {
					val += femMatGet(a, i, k) * femMatGet(b, k, j)
				}
				femMatPutAdd(c, i, j, val, 0)
			}
		}
	}
	return 0
}

// femMatLinComb - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1717
func femMatLinComb(am float64, a []tMatrix, bm float64, b []tMatrix, c []tMatrix) int32 {
	// linear combination of matrices am*a[m,n]+ bm*b[m,n] = c[m,n] (c..MAT_FULL)
	// * @param am  "a" matrix multiplier
	// * @param a matrix
	// * @param bm  "b" matrix multiplier
	// * @param b matrix
	// * @param c matrix (result)
	// * @return status
	//
	var i int32
	var j int32
	var val float64
	if a[0].cols != b[0].cols || a[0].rows != b[0].rows || a[0].rows != c[0].rows || a[0].cols != c[0].cols {
		return -9
	}
	if c[0].type_ != 0 {
		return -3
	}
	if a[0].type_ == 0 && b[0].type_ == 0 && c[0].type_ == 0 {
		for i = 0; i < a[0].rows*a[0].cols; i++ {
			c[0].data[i] = am*a[0].data[i] + bm*b[0].data[i]
		}
	} else {
		for i = 1; i <= c[0].rows; i++ {
			for j = 1; j <= c[0].cols; j++ {
				val = am*femMatGet(a, i, j) + bm*femMatGet(b, i, j)
				femMatPutAdd(c, i, j, val, 0)
			}
		}
	}
	return 0
}

// femMatLinCombClones - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1756
func femMatLinCombClones(am float64, a []tMatrix, bm float64, b []tMatrix, c []tMatrix) int32 {
	// linear combination of matrices am*a[m,n]+ bm*b[m,n] = c[m,n] (c..MAT_SPAR only, must have identical internal structure!)
	// * @param am  "a" matrix multiplier
	// * @param a matrix
	// * @param bm  "b" matrix multiplier
	// * @param b matrix
	// * @param c matrix (result)
	// * @return status
	//
	var i int32
	if a[0].cols != b[0].cols || a[0].rows != b[0].rows || a[0].rows != c[0].rows || a[0].cols != c[0].cols {
		return -9
	}
	if c[0].type_ != 1 {
		return -3
	}
	if b[0].type_ != 1 {
		return -3
	}
	if a[0].type_ != 1 {
		return -3
	}
	if a[0].type_ == 1 && b[0].type_ == 1 && c[0].type_ == 1 {
		for i = 0; i < a[0].len_; i++ {
			c[0].data[i] = am*a[0].data[i] + bm*b[0].data[i]
		}
	}
	return 0
}

// femMatTran - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1784
func femMatTran(a []tMatrix, b []tMatrix) int32 {
	// matrix transposition - works only on dense matrices (MAT_FULL)
	// * @param a matrix (original)
	// * @param b matrix (result - must be allocated)
	// * @return status
	//
	var i int32
	var j int32
	if a[0].cols != b[0].rows || b[0].cols != a[0].rows {
		return -9
	}
	if a[0].type_ != 0 || b[0].type_ != 0 {
		return -9
	}
	for i = 0; i < a[0].rows; i++ {
		for j = 0; j < a[0].cols; j++ {
			if a[0].cols == a[0].rows {
				b[0].data[j*a[0].cols+i] = a[0].data[i*a[0].cols+j]
			} else {
				femMatPutAdd(b, j+1, i+1, femMatGet(a, i+1, j+1), 0)
			}
		}
	}
	return 0
}

// femMatNormBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1856
func femMatNormBig(a []tMatrix) float64 {
	// Computes norm of sparse matrix
	// *  @param a matrix
	// *  @return norm
	//
	var Norm float64
	var MaxNorm float64
	var val float64
	var i int32
	var j int32
	MaxNorm = 0
	if a[0].type_ == 1 {
		for i = 0; i < a[0].rows; i++ {
			Norm = 0
			for j = a[0].frompos[i]; j < a[0].frompos[i]+a[0].defpos[i]; j++ {
				if a[0].pos[j] <= 0 {
					break
				}
				Norm += a[0].data[j] * a[0].data[j]
			}
			Norm = math.Sqrt(Norm)
			if Norm > MaxNorm {
				MaxNorm = Norm
			}
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			Norm = 0
			for j = 1; j <= a[0].cols; j++ {
				val = femMatGet(a, i, j)
				Norm += val * val
			}
			Norm = math.Sqrt(Norm)
			if Norm > MaxNorm {
				MaxNorm = Norm
			}
		}
	}
	return MaxNorm
}

// femMatNorm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:1955
func femMatNorm(a []tMatrix) float64 {
	// Computes norm of sparse matrix FOR SMALL DATA
	// *  @param a matrix
	// *  @return norm
	//
	var Norm float64
	var MaxNorm float64
	var val float64
	var i int32
	var j int32
	MaxNorm = 0
	if a[0].type_ == 1 {
		for i = 0; i < a[0].rows; i++ {
			Norm = 0
			for j = a[0].frompos[i]; j < a[0].frompos[i]+a[0].defpos[i]; j++ {
				if a[0].pos[j] <= 0 {
					break
				}
				Norm += a[0].data[j] * a[0].data[j]
			}
			Norm = math.Sqrt(Norm)
			if Norm > MaxNorm {
				MaxNorm = Norm
			}
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			Norm = 0
			for j = 1; j <= a[0].cols; j++ {
				val = femMatGet(a, i, j)
				Norm += val * val
			}
			Norm = math.Sqrt(Norm)
			if Norm > MaxNorm {
				MaxNorm = Norm
			}
		}
	}
	return MaxNorm
}

// femVecNormBig - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2022
func femVecNormBig(a []tVector) float64 {
	// Computes Euclide norm of vector sum(sqrt(a*a))
	// *  @param a     vector
	// *  @return norm
	//
	var Norm float64
	var val float64
	var i int32
	Norm = 0
	if a[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			Norm += a[0].data[i] * a[0].data[i]
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			val = femVecGet(a, i)
			Norm += val * val
		}
	}
	return math.Sqrt(Norm)
}

// femVecNorm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2106
func femVecNorm(a []tVector) float64 {
	// Computes Euclide norm of vector sum(sqrt(a*a)) FOR SMALL DATA
	// *  @param a     vector
	// *  @return norm
	//
	var Norm float64
	var val float64
	var i int32
	Norm = 0
	if a[0].type_ == 0 {
		for i = 0; i < a[0].rows; i++ {
			Norm += a[0].data[i] * a[0].data[i]
		}
	} else {
		for i = 1; i <= a[0].rows; i++ {
			val = femVecGet(a, i)
			Norm += val * val
		}
	}
	return math.Sqrt(Norm)
}

// femVecMaxAbs - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2136
func femVecMaxAbs(a []tVector) float64 {
	// Finds maximum value in vector (absolute value)
	// *  @param a     vector
	// *  @return fabs(maximum)
	//
	var Norm float64
	var val float64
	var i int32
	if a[0].type_ == 0 {
		Norm = math.Abs(a[0].data[0])
		for i = 1; i < a[0].rows; i++ {
			val = math.Abs(a[0].data[i])
			if Norm < val {
				Norm = val
			}
		}
	} else {
		Norm = math.Abs(femVecGet(a, 1))
		for i = 2; i <= a[0].rows; i++ {
			val = math.Abs(femVecGet(a, i))
			if Norm < val {
				Norm = val
			}
		}
	}
	return math.Sqrt(Norm)
}

// femVecAddVec - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2170
func femVecAddVec(orig []tVector, mult float64, addt []tVector) int32 {
	// Adds vector "addt" to "orig" e.g. orig += mult*addt
	// * @param orig original vector (to be modified)
	// * @param mult scalar multiplier
	// * @param addt addition vector
	// * @return status
	//
	var i int32
	if orig[0].rows != addt[0].rows {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Different vector sizes not allowed here\x00"))
		return -9
	}
	if orig[0].type_ == 0 && addt[0].type_ == 0 {
		for i = 0; i < orig[0].len_; i++ {
			orig[0].data[i] += mult * addt[0].data[i]
		}
	} else {
		for i = 1; i <= orig[0].len_; i++ {
			femVecPutAdd(orig, i, mult*femVecGet(addt, i), 1)
		}
	}
	return 0
}

// femMatInv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2203
func femMatInv(a []tMatrix) int32 {
	// Does matrix inversion UNOPTIMIZED!
	// *  @param a  matrix to be inverted
	//
	var m int32
	var n int32
	var i int32
	var j int32
	var k int32
	var f float64
	var f2 float64
	var val float64
	var f1 tVector
	if a[0].rows != a[0].cols {
		return -9
	}
	n = a[0].cols
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&f1))[:])
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&f1))[:], 0, n, n) != 0 {
		return -4
	}
	m = n - 1
	val = femMatGet(a, 1, 1)
	femMatPutAdd(a, 1, 1, 1/val, 0)
	for i = 1; i <= m; i++ {
		for j = 1; j <= i; j++ {
			f = 0
			for k = 1; k <= i; k++ {
				f += femMatGet(a, j, k) * femMatGet(a, k, i+1)
			}
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&f1))[:], j, -f, 0)
		}
		f2 = femMatGet(a, i+1, i+1)
		for j = 1; j <= i; j++ {
			f2 += femMatGet(a, j, i+1) * femVecGet((*[1000000]tVector)(unsafe.Pointer(&f1))[:], j)
		}
		if math.Abs(f2/femMatGet(a, i+1, i+1)) < 1e-17 {
			return -3
		}
		f2 = 1 / f2
		femMatPutAdd(a, i+1, i+1, f2, 0)
		for j = 1; j <= i; j++ {
			for k = 1; k <= i; k++ {
				femMatPutAdd(a, j, k, femVecGet((*[1000000]tVector)(unsafe.Pointer(&f1))[:], j)*femVecGet((*[1000000]tVector)(unsafe.Pointer(&f1))[:], k)*f2+femMatGet(a, j, k), 0)
			}
		}
		for j = 1; j <= i; j++ {
			femMatPutAdd(a, j, i+1, femVecGet((*[1000000]tVector)(unsafe.Pointer(&f1))[:], j)*f2, 0)
			femMatPutAdd(a, i+1, j, femMatGet(a, j, i+1), 0)
		}
	}
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&f1))[:])
	return 0
}

// femLUdecomp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2285
func femLUdecomp(a []tMatrix, index []tVector) int32 {
	// L-U:
	// Decomposition to L/U
	// * @param a matrix (will be modified!)
	// * @param index index vector
	// * @param d modified index status (-1/+1)
	// * @return status
	//
	var rv int32
	var i int32
	var j int32
	var k int32
	var imax int32
	var n int32
	var big float64
	var dum float64
	var sum float64
	var temp float64
	var vv tVector
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&vv))[:])
	if (func() int32 {
		n = a[0].rows
		return n
	}()) <= 0 {
		return -9
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&vv))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= n; i++ {
		big = 0
		for j = 1; j <= n; j++ {
			if (func() float64 {
				temp = math.Abs(femMatGet(a, i, j))
				return temp
			}()) > big {
				big = temp
			}
		}
		if big == 0 {
			// singular matrix
			return -3
		}
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&vv))[:], i, 1/big, 0)
	}
	for j = 1; j <= n; j++ {
		for i = 1; i < j; i++ {
			sum = femMatGet(a, i, j)
			for k = 1; k < i; k++ {
				sum -= femMatGet(a, i, k) * femMatGet(a, k, j)
			}
			femMatPutAdd(a, i, j, sum, 0)
		}
		big = 0
		for i = j; i <= n; i++ {
			sum = femMatGet(a, i, j)
			for k = 1; k < j; k++ {
				sum -= femMatGet(a, i, k) * femMatGet(a, k, j)
			}
			femMatPutAdd(a, i, j, sum, 0)
			if (func() float64 {
				dum = femVecGet((*[1000000]tVector)(unsafe.Pointer(&vv))[:], i) * math.Abs(sum)
				return dum
			}()) >= big {
				big = dum
				imax = i
			}
		}
		if j != imax {
			for k = 1; k <= n; k++ {
				dum = femMatGet(a, imax, k)
				femMatPutAdd(a, imax, k, femMatGet(a, j, k), 0)
				femMatPutAdd(a, j, k, dum, 0)
			}
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&vv))[:], imax, femVecGet((*[1000000]tVector)(unsafe.Pointer(&vv))[:], j), 0)
		}
		femVecPutAdd(index, j, float64(imax), 0)
		if femMatGet(a, j, j) == 0 {
			femMatPutAdd(a, j, j, 1e-20, 0)
		}
		if j != n {
			dum = 1 / femMatGet(a, j, j)
			for i = j + 1; i <= n; i++ {
				femMatPutAdd(a, i, j, dum*femMatGet(a, i, j), 0)
			}
		}
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&vv))[:])
	return rv
}

// femLUback - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2388
func femLUback(a []tMatrix, index []tVector, b []tVector) int32 {
	// Decomposition to L/U
	// * @param a matrix (will be modified!)
	// * @param index index vector
	// * @param b right hand side/result vector (will be modified!)
	// * @return status
	//
	var rv int32
	var i int32
	var ii int32
	var ip int32
	var j int32
	var n int32
	var sum float64
	ii = 0
	if (func() int32 {
		n = a[0].rows
		return n
	}()) <= 0 {
		return -9
	}
	for i = 1; i <= n; i++ {
		ip = int32(femVecGet(index, i))
		sum = femVecGet(b, ip)
		femVecPutAdd(b, ip, femVecGet(b, i), 0)
		if ii != 0 {
			// means ii > 0
			for j = ii; j <= i-1; j++ {
				sum -= femMatGet(a, i, j) * femVecGet(b, j)
			}
		} else {
			if sum != 0 {
				ii = i
			}
		}
		femVecPutAdd(b, i, sum, 0)
	}
	for i = n; i >= 1; i-- {
		sum = femVecGet(b, i)
		for j = i + 1; j <= n; j++ {
			sum -= femMatGet(a, i, j) * femVecGet(b, j)
		}
		femVecPutAdd(b, i, sum/femMatGet(a, i, i), 0)
	}
	return rv
}

// femLUinverse - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2440
func femLUinverse(a []tMatrix) int32 {
	// Inversion of "a" matrix using L/U
	// * @param a matrix (will be modified!)
	// * @return status
	//
	var rv int32
	var i int32
	var j int32
	var n int32
	var col tVector
	var index tVector
	var b tMatrix
	if (func() int32 {
		n = a[0].rows
		return n
	}()) <= 0 {
		return -9
	}
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&col))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&index))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&b))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&col))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&index))[:], 0, n, n)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&b))[:], 0, n, n, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femLUdecomp(a, (*[1000000]tVector)(unsafe.Pointer(&index))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&col))[:], i, 0, 0)
		}
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&col))[:], j, 1, 0)
		if (func() int32 {
			rv = femLUback(a, (*[1000000]tVector)(unsafe.Pointer(&index))[:], (*[1000000]tVector)(unsafe.Pointer(&col))[:])
			return rv
		}()) != 0 {
			goto memFree
		}
		for i = 1; i <= n; i++ {
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&b))[:], i, j, femVecGet((*[1000000]tVector)(unsafe.Pointer(&col))[:], i), 0)
		}
	}
	for i = 1; i <= n; i++ {
		for j = 1; j <= n; j++ {
			femMatPutAdd(a, i, j, femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&b))[:], i, j), 0)
		}
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&col))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&index))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&b))[:])
	return rv
}

// femVecSwitch - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2490
func femVecSwitch(a []tVector, b []tVector) int32 {
	// Moves "a" to "b" and "b" to "a"
	// * @param a vector
	// * @param b vector
	// * @return status
	//
	var val float64
	var i int32
	if a[0].rows != b[0].rows || a[0].type_ != 0 || b[0].type_ != 0 {
		return -9
	}
	for i = 0; i < a[0].len_; i++ {
		val = a[0].data[i]
		a[0].data[i] = b[0].data[i]
		b[0].data[i] = val
	}
	return 0
}

// femVecCloneDiff - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2515
func femVecCloneDiff(orig []tVector, clone []tVector) int32 {
	// Copies vector content to a larger one (extra fields are left untouched)
	// * @param orig original vector
	// * @param clone target vector (to be modified)
	// * @return status
	//
	var i int32
	var len_ int32
	if orig[0].type_ != 0 || clone[0].type_ != 0 {
		return -5
	}
	if clone[0].rows < 1 || orig[0].rows < 1 {
		return -9
	}
	if orig[0].rows > clone[0].rows {
		len_ = clone[0].rows
	} else {
		len_ = orig[0].rows
	}
	for i = 0; i < len_; i++ {
		clone[0].data[i] = orig[0].data[i]
	}
	return 0
}

// femMatCloneDiffToSame - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2550
func femMatCloneDiffToSame(orig []tMatrix, clone []tMatrix) int32 {
	// TODO FIX!!! Copies sparse matrix content to a larger one (extra fields are left untouched)
	// * it is assumed that a) there is a space for data in "clone", b) identical data
	// * in both matrices are stored at identical places
	// * @param orig original vector
	// * @param clone target vector (to be modified)
	// * @return status
	//
	var i int32
	var j int32
	var k int32
	var ko int32
	var kc int32
	if orig[0].type_ != 1 || clone[0].type_ != 1 {
		return -5
	}
	if orig[0].rows > clone[0].rows || orig[0].rows < 1 {
		return -9
	}
	if orig[0].cols > clone[0].cols || orig[0].cols < 1 {
		return -9
	}
	for i = 0; i < orig[0].rows; i++ {
		k = 0
		for j = orig[0].frompos[i]; j < orig[0].frompos[i]+orig[0].defpos[i]; j++ {
			ko = k + orig[0].frompos[i]
			kc = k + clone[0].frompos[i]
			clone[0].data[kc] = orig[0].data[ko]
			k++
		}
	}
	return 0
}

// femMatCloneDiffToEmpty - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2603
func femMatCloneDiffToEmpty(orig []tMatrix, clone []tMatrix) int32 {
	// Copies sparse matrix content to a larger one (extra fields are left untouched)
	// * it is assumed that a) there is a space for data in "clone", b) identical data
	// * in both matrices are stored at identical places
	// * @param orig original vector
	// * @param clone target vector (to be modified)
	// * @return status
	//
	var i int32
	var j int32
	if orig[0].type_ != 1 || clone[0].type_ != 1 {
		return -5
	}
	if orig[0].rows > clone[0].rows || orig[0].rows < 1 {
		return -9
	}
	if orig[0].cols > clone[0].cols || orig[0].cols < 1 {
		return -9
	}
	for i = 0; i < orig[0].rows; i++ {
		for j = orig[0].frompos[i]; j < orig[0].frompos[i]+orig[0].defpos[i]; j++ {
			femMatPutAdd(clone, i+1, orig[0].pos[j], orig[0].data[j], 0)
		}
	}
	return 0
}

// femMatAllocCloneStruct - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_math.c:2637
func femMatAllocCloneStruct(orig []tMatrix, clone []tMatrix) int32 {
	// Allocates empty sparse matrix with the same innternal structures as the original
	// * @param orig original (filled) matrix - must not be empty
	// * @param clone (empty) clone matrix
	// *
	var i int32
	if orig[0].type_ != 1 {
		return -5
	}
	if clone[0].type_ != 1 {
		return -5
	}
	if clone[0].len_ != orig[0].len_ {
		return -9
	}
	if clone[0].cols != orig[0].cols {
		return -9
	}
	if clone[0].rows != orig[0].rows {
		return -9
	}
	clone[0].type_ = orig[0].type_
	clone[0].rows = orig[0].rows
	clone[0].cols = orig[0].cols
	clone[0].len_ = orig[0].len_
	for i = 0; i < orig[0].rows; i++ {
		clone[0].frompos[i] = orig[0].frompos[i]
		clone[0].defpos[i] = orig[0].defpos[i]
	}
	for i = 0; i < orig[0].len_; i++ {
		clone[0].pos[i] = orig[0].pos[i]
	}
	return 0
}

// msgout - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mem.c:29
//
//   File name: fem_mem.c
//   Date:      2003/04/07 10:16
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	FEM Solver - memory handling
//  $Id: fem_mem.c,v 1.5 2004/07/06 21:03:44 jirka Exp $
//
var msgout *noarch.File

// femIntAlloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mem.c:37
func femIntAlloc(length int32) (c4goDefaultReturn []int32) {
	// 1D fields ----------------------------------------------------------
	// allocates and returns 1D int field  (NULL if failed)
	// * @param length length of field
	// * @returns field (or NULL)
	//
	var field []int32
	var i int32
	if length < 1 {
		return nil
	}
	if len((func() []int32 {
		field = (*[1000000]int32)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := make([]byte, uint32(length)*uint32(1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		return field
	}())) == 0 {
		return nil
	} else {
		for i = 0; i < length; i++ {
			field[i] = 0
		}
		return field
	}
	return
}

// femIntFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mem.c:59
func femIntFree(field []int32) int32 {
	_ = field
	// removes memory from int field
	// * @param field  field to be freed
	// * @returns state value
	//
	field = nil
	return 0
}

// femDblAlloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mem.c:71
func femDblAlloc(length int32) (c4goDefaultReturn []float64) {
	// allocates and returns 1D double field  (NULL if failed)
	// * @param length length of field
	// * @returns field (or NULL)
	//
	var field []float64
	var i int32
	if length < 1 {
		return nil
	}
	if len((func() []float64 {
		field = (*[1000000]float64)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := make([]byte, uint32(length)*uint32(1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		return field
	}())) == 0 {
		return nil
	} else {
		for i = 0; i < length; i++ {
			field[i] = 0
		}
		return field
	}
	return
}

// femDblFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mem.c:93
func femDblFree(field []float64) int32 {
	_ = field
	// removes memory from dbl field
	// * @param field  field to be freed
	// * @returns state value
	//
	field = nil
	return 0
}

// femMatTypeInit - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mini.c:43
func femMatTypeInit() int32 {
	//
	//   File name: fem_eini.c
	//   Date:      2003/04/16 21:00
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - material type initialization
	//
	//  $Id: fem_mini.c,v 1.7 2004/11/11 21:39:25 jirka Exp $
	//
	var rv int32
	if (func() int32 {
		rv = addMat_000()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_001()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_002()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_003()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_004()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_005()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_006()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_007()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_008()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_009()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_010()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = addMat_011()
		return rv
	}()) != 0 {
		goto memFree
	}
	if rv == 0 {
		return rv
	}
memFree:
	;
	noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Material type initialization failed\x00"))
	noarch.Exit(rv)
	return rv
}

// femKpos - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mloc.c:52
func femKpos(node_pos int32, dof int32) int32 {
	//
	//   File name: fem_mloc.c
	//   Date:      2003/04/13 13:10
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - localization of element matrices and vectors
	//
	//  $Id: fem_mloc.c,v 1.13 2004/07/08 22:46:43 jirka Exp $
	//
	// total number of ACTIVE DOFs in structure (== size of "K" matrix)
	// lenght of nDOFfld
	// description of DOFs in nodes
	// numbers of items in "K" rows K_rows[nDOFAct]
	// "K" matrix
	// Returnes row/collumn (e.g. 1..n) number in "K" matrix
	// * @param node_pos position of node
	// * @param dof_id DOF TYPE (for example U_X)
	// * @return position (0 on error)
	//
	var pos int32
	var pos_ind int32
	pos_ind = node_pos*7 + (dof - 1)
	if pos_ind < nDOFlen && pos_ind >= 0 {
		pos = nDOFfld[pos_ind]
	} else {
		// ERROR !
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("K-index out of boundaries\x00"))
		noarch.Exit(-9)
		return 0
	}
	noarch.Printf([]byte("[ ] pos = %li (index %li, n=%li, dof=%li) \n\x00"), pos, pos_ind, node_pos, dof)
	return pos
}

// femKhit - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mloc.c:83
func femKhit() int32 {
	// Computes number of "K" rows
	var i int32
	var j int32
	var k int32
	var pos int32
	var node_pos int32
	if len(K_rows) == 0 {
		return -4
	}
	for i = 0; i < eLen; i++ {
		for j = 0; j < Elem[eType[i]].nodes; j++ {
			node_pos = femGetIntLPos(i, j, eFrom, eNodesL, eLenL)
			for k = 0; k < Elem[eType[i]].dofs; k++ {
				if (func() int32 {
					pos = femKpos(node_pos, Elem[eType[i]].ndof[k])
					return pos
				}()) < 1 {
					// workaround for femFastBC
					continue
				}
				K_rows[pos-1] += Elem[eType[i]].nodes * Elem[eType[i]].dofs
			}
		}
	}
	return 0
}

// femFillLocVec - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mloc.c:121
func femFillLocVec(ePos int32, Vec []int32, vLen int32) int32 {
	// Fills element localization vector
	var i int32
	var j int32
	var eT int32
	var pos int32
	var node_pos int32
	eT = eType[ePos]
	if Elem[eT].dofs*Elem[eT].nodes != vLen {
		return -3
	}
	for i = 0; i < Elem[eT].nodes; i++ {
		node_pos = femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL)
		for j = 0; j < Elem[eT].dofs; j++ {
			if (func() int32 {
				Vec[pos] = femKpos(node_pos, Elem[eT].ndof[j])
				return Vec[pos]
			}()) < 1 {
				Vec[pos] = int32(0)
			}
			pos++
		}
	}
	return 0
}

// femLocKM_e - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mloc.c:163
func femLocKM_e(K_e []tMatrix, K []tMatrix, ePos int32) int32 {
	// localizes items from "K_e" to "K"
	// * @param K_e matrix
	// * @param ePos element position
	// * @return state value
	//
	var rv int32
	var i int32
	var j int32
	var lFld []int32
	var lFldLen int32
	lFldLen = Elem[eType[ePos]].dofs * Elem[eType[ePos]].nodes
	if lFldLen != K_e[0].rows {
		return -9
	}
	if len((func() []int32 {
		lFld = femIntAlloc(lFldLen)
		return lFld
	}())) == 0 {
		return -4
	}
	if (func() int32 {
		rv = femFillLocVec(ePos, lFld, lFldLen)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= lFldLen; i++ {
		for j = 1; j <= lFldLen; j++ {
			if float64(lFld[i-1]*lFld[j-1]) != 0 {
				// <- femFastBC workaround
				// standard way:
				rv = femMatPutAdd(K, lFld[i-1], lFld[j-1], femMatGet(K_e, i, j), 1)
			}
			if rv != 0 {
				goto memFree
			}
		}
	}
memFree:
	;
	femIntFree(lFld)
	return rv
}

// femLocF_e - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mloc.c:230
func femLocF_e(F_e []tVector, ePos int32, F []tVector, isF int32) int32 {
	// localizes items from "F_e" to "F"
	// * @param F_e vector
	// * @param ePos element position
	// * @param isF AF_YES if F is F, AF_NO for Fr (used for mutexes only ;-)
	// * @return state value
	//
	var rv int32
	var i int32
	var lFld []int32
	var lFldLen int32
	lFldLen = Elem[eType[ePos]].dofs * Elem[eType[ePos]].nodes
	if lFldLen != F_e[0].rows {
		return -9
	}
	if len((func() []int32 {
		lFld = femIntAlloc(lFldLen)
		return lFld
	}())) == 0 {
		return -4
	}
	if (func() int32 {
		rv = femFillLocVec(ePos, lFld, lFldLen)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= lFldLen; i++ {
		if float64(lFld[i-1]) != 0 {
			// <- femFastBC workaround
			rv = femVecPutAdd(F, lFld[i-1], femVecGet(F_e, i), 1)
		}
		if rv != 0 {
			goto memFree
		}
	}
memFree:
	;
	femIntFree(lFld)
	return rv
}

// femLocUtoU_e - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mloc.c:301
func femLocUtoU_e(U []tVector, ePos int32, U_e []tVector) int32 {
	// localizes items from "U" to "U_e"
	// * @param F_e vector
	// * @param ePos element position
	// * @return state value
	//
	var rv int32
	var i int32
	var lFld []int32
	var lFldLen int32
	lFldLen = Elem[eType[ePos]].dofs * Elem[eType[ePos]].nodes
	if lFldLen != U_e[0].rows {
		return -9
	}
	if len((func() []int32 {
		lFld = femIntAlloc(lFldLen)
		return lFld
	}())) == 0 {
		return -4
	}
	if (func() int32 {
		rv = femFillLocVec(ePos, lFld, lFldLen)
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 1; i <= lFldLen; i++ {
		if float64(lFld[i-1]) != 0 {
			// <- femFastBC workaround
			rv = femVecPutAdd(U_e, i, femVecGet(U, lFld[i-1]), 1)
		} else {
			femVecPutAdd(U_e, i, 0, 1)
		}
		if rv != 0 {
			goto memFree
		}
	}
memFree:
	;
	femIntFree(lFld)
	return rv
}

// fem_monte_read_data - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mont.c:866
func fem_monte_read_data(fr *noarch.File) int32 {
	//
	//   File name: fem_mont.c
	//   Date:      2006/08/15 12:05
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2006 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM Solver - tools for building the code in the form of dynamic
	//   library loadable by "Monte" reliability tool.
	//
	// reads reliability data from input file - it is used (empty) even
	// * if library in not build
	// * @param fr file stream
	// * @return status
	//
	return 0
}

// femTestConstElem - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:30
//
//   File name: fem_mrun.c
//   Date:      2008/08/15 19:50
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2008 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//   FEM solver: testing of 2D (and later 3D) constitutive routines
//
var femTestConstElem int32 = -1

// femTestConstIpn - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:31
var femTestConstIpn int32 = -1

// femTestConstA - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:32
var femTestConstA float64

// femTestConstEX - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:33
var femTestConstEX float64

// femTestConstEY - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:34
var femTestConstEY float64

// femTestConstEZ - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:35
var femTestConstEZ float64

// femTestConstEXY - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:36
var femTestConstEXY float64

// femTestConstEYZ - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:37
var femTestConstEYZ float64

// femTestConstEZX - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:38
var femTestConstEZX float64

// femDryRun2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:49
func femDryRun2D(ePos int32, ipoint int32, A float64, e_x float64, e_y float64, e_xy float64) int32 {
	// Runs constitutive data testing routine with proper parameters
	// * @param ePos position of selected element
	// * @param ipoint integration point
	// * @param A element area
	// * @param e_x total strain in X direction
	// * @param e_y total strain in Y direction
	// * @param e_xy total strain in XY direction
	// * @return status
	//
	var rv int32
	var fw *noarch.File
	var i int32
	var dim int32 = 3
	// sorry, no plane strain here
	var Problem int32
	var mtype int32
	var mult float64
	var sigma tVector
	var sigma_r tVector
	var sigma_sum tVector
	var epsilon tVector
	var D tMatrix
	if len(fem_ofile) == 0 {
		fw = noarch.Stdout
	} else {
		if noarch.Strlen(fem_ofile) >= int32(1) {
			if (func() *noarch.File {
				fw = noarch.Fopen(fem_ofile, []byte("w\x00"))
				return fw
			}()) == nil {
				fw = noarch.Stdout
			}
		} else {
			fw = noarch.Stdout
		}
	}
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], 0, dim, dim, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, dim, dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 0, dim, dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 0, dim, dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 0, dim, dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done _before_ adding of loads!
		goto memFree
	}
	mtype = Mat[femGetIntPos(femGetIntPos(ePos, eMP, eLen), mpType, mpLen)].type_
	mult = 1 / float64(solNoLinSteps)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 1, mult*e_x, 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 2, mult*e_y, 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], 3, mult*e_y, 0)
	for i = 1; i <= solNoLinSteps; i++ {
		femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:])
		femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		fem_D_2D(ePos, ipoint, A, (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_r))[:], 1, Problem, (*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
		femVecSetZero((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&D))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
		femAddPutRepVal(ePos, 13, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, e_x)
		femAddPutRepVal(ePos, 14, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, e_y)
		femAddPutRepVal(ePos, 16, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 1, e_xy)
		femAddPutRepVal(ePos, 7, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 1))
		femAddPutRepVal(ePos, 8, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 2))
		femAddPutRepVal(ePos, 10, ipoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 3))
		noarch.Fprintf(fw, []byte("%li %e %e %e %e %e %e\n\x00"), i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 2), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:], 3), float64(i)*mult*e_x, float64(i)*mult*e_y, float64(i)*mult*e_xy)
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&D))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_sum))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon))[:])
	fem_sol_free()
	femDataFree()
	femResFree()
	noarch.Fclose(fw)
	return rv
}

// femDryRun - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_mrun.c:184
func femDryRun() int32 {
	// Does constitutive equation testing for 2D plane stress
	// * (in 3D maybe in future)
	// * @return status
	//
	var i int32
	var ePos int32 = -1
	for i = 0; i < eLen; i++ {
		if eID[i] == femTestConstElem {
			ePos = eID[i]
			break
		}
	}
	if eLen < 0 {
		noarch.Fprintf(msgout, []byte("[E} %s!\n\x00"), []byte("Requested element not found\x00"))
		return -3
	}
	return femDryRun2D(ePos, femTestConstIpn, femTestConstA, femTestConstEX, femTestConstEY, femTestConstEXY)
}

// femLinEqSystemSolve - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_newm.c:77
func femLinEqSystemSolve(Ks []tMatrix, Fs []tVector, us []tVector) int32 {
	//
	//   File name: fem_newm.c
	//   Date:      2010/11/01 19:11
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2010 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  Newmark implicit time integration routine for dynamics
	//
	// from fem_sol.c:
	// total number of ACTIVE DOFs in structure (== size of "K" matrix)
	// lenght of nDOFfld
	// description of DOFs in nodes
	// numbers of items in "K" rows K_rows[nDOFAct]
	// structure stiffness matrix
	// structure load vector
	// unballanced forces vector
	// structure displacement vector
	// dynamics:
	// structure mass matrix
	// newmark
	// combined stiffness matrix combined stiffness matrix
	// damping matrix
	// combined load vector
	// displacement change
	// temporary vector
	// temporary vector
	// previous displacement
	// previous velocity
	// previous acceleration
	// current velocity
	// current acceleration
	// initial load vector
	// Wrapper for linear system solvers
	// * @param Ks stiffness matrix
	// * @param Fs load vector
	// * @param us displacement vector (result)
	// * @return status
	//
	var rv int32
	var steps int32
	var precision float64
	steps = nDOFAct
	precision = 1e-17 / 10000
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("solution of linear equations\x00"))
	if solUseBiCGs != 1 {
		if solUseCGSSOR != 1 {
			rv = femEqsCGwJ(Ks, Fs, us, precision, steps)
		} else {
			rv = femEqsCGwSSOR(Ks, Fs, us, precision, steps)
		}
	} else {
		rv = femEqsBiCCSwJ(Ks, Fs, us, precision, steps)
	}
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("solution of linear equations done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E]   %s!\n\x00"), []byte("solution of linear equations FAILED\x00"))
	}
	return rv
}

// femMassDistrNewm - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_newm.c:109
func femMassDistrNewm(step int32) int32 {
	// Computes inertia forces distribution for given load step
	// * @param step step number (0...)
	// * @return status
	//
	var i int32
	var j int32
	var pos_ind int32
	var pos int32
	var m_x float64
	var m_y float64
	var m_z float64
	m_x = transMult[dynAccX][step]
	m_y = transMult[dynAccY][step]
	m_z = transMult[dynAccZ][step]
	femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
	for i = 0; i < nLen; i++ {
		for j = 1; j <= 3; j++ {
			pos_ind = i*7 + (j - 1)
			if pos_ind < nDOFlen {
				pos = nDOFfld[pos_ind]
				if pos > 0 {
					switch j {
					case 1:
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], pos, -1*m_x*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], pos), 0)
					case 2:
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], pos, -1*m_y*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], pos), 0)
					case 3:
						femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&F))[:], pos, -1*m_z*femVecGet((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], pos), 0)
						break
					}
				}
			}
		}
	}
	femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F))[:], []byte("STEP LOAD VECTOR\x00"))
	return 0
}

// femSolveDynNewmark - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_newm.c:152
func femSolveDynNewmark(ofld []float64) int32 {
	// Simple dynamics solver: see Bitnar, Rericha: "Metoda
	// * konecnych prvku v dynamice konstrukci", SNTL, Prague, 1981, p. 122
	// * Newmark time integration procedure is used
	// *
	// * @param ofld random output data filed (only != NULL for Monte Carlo)
	// * @return statis
	//
	var rv int32
	var dt float64
	var steps int32
	var a []float64 = make([]float64, 11)
	var r_alpha float64 = 0.1
	var r_beta float64 = 0.1
	var i int32
	// for SaPo
	var pos int32
	// for SaPo
	var val float64
	// file name for step
	var fnm []byte
	dt = dynStp
	steps = dynNum
	r_alpha = dynAlpha
	r_beta = dynBeta
	if dt < 0 || steps < 1 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("No valid data for Newmark available\x00"))
		return -3
	}
	// Solution constants:
	a[0] = 4 / (dt * dt)
	a[1] = 2 / dt
	a[2] = 4 / dt
	a[3] = 1
	a[4] = 1
	a[5] = 0
	a[6] = a[0]
	a[7] = -1 * a[2]
	a[8] = -1 * a[3]
	a[9] = dt / 2
	a[10] = a[9]
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("data checking and allocations\x00"))
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("data checking and allocations done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("assembling of stiffness matrix\x00"))
	if (func() int32 {
		rv = fem_fill_K(0)
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("assembling of stiffness matrix done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("assembling of mass matrix\x00"))
	if (func() int32 {
		rv = femMatAllocCloneStruct((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_fill_M()
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("assembling of math matrix done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("assembling of Rayleigh damping matrix\x00"))
	if (func() int32 {
		rv = femMatAllocCloneStruct((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&KK))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAllocCloneStruct((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if M.type_ == 1 && K.type_ == 1 && C.type_ == 1 && KK.type_ == 1 {
		// this code assumes that structure of all matrices is identical!
		for i = 0; i < K.len_; i++ {
			C.data[i] = r_alpha*M.data[i] + r_beta*K.data[i]
		}
	} else {
		// slow as hell
		femMatLinComb(r_alpha, (*[1000000]tMatrix)(unsafe.Pointer(&M))[:], r_beta, (*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("assembling of damping matrix done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("loads and supports\x00"))
	for i = 0; i < nDOFAct; i++ {
		F_0.data[i] = 1
	}
	//
	femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
	if (func() int32 {
		rv = fem_add_disps(1, 0)
		return rv
	}()) != 0 {
		goto memFree
	}
	femVecClone((*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("loads and supports done\x00"))
	if M.type_ == 1 && K.type_ == 1 && C.type_ == 1 && KK.type_ == 1 {
		// newmark preparations (initial KK matrix):
		// this assumes that structure of all matrices is identical:
		for i = 0; i < K.len_; i++ {
			KK.data[i] = K.data[i] + a[0]*M.data[i] + a[1]*C.data[i]
		}
	} else {
		rv = -5
		goto memFree
	}
	// load vector for step 0:
	femMassDistrNewm(0)
	// initial acceleration:
	femLinEqSystemSolve((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
	{
		// iteration over time steps
		for i = 1; i < steps; i++ {
			noarch.Fprintf(msgout, []byte("[I] %s %li / %li:\n\x00"), []byte("Newmark step\x00"), i, steps-1)
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&ra))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&rb))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&ra))[:], a[0], (*[1000000]tVector)(unsafe.Pointer(&r0))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&ra))[:], a[2], (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&ra))[:], a[3], (*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
			femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], (*[1000000]tVector)(unsafe.Pointer(&ra))[:], (*[1000000]tVector)(unsafe.Pointer(&rb))[:])
			// 1st component of ra added
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&rb))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&ra))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&rb))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&ra))[:], a[1], (*[1000000]tVector)(unsafe.Pointer(&r0))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&ra))[:], a[4], (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&ra))[:], a[5], (*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
			femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], (*[1000000]tVector)(unsafe.Pointer(&ra))[:], (*[1000000]tVector)(unsafe.Pointer(&rb))[:])
			// 1st component of ra added
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&rb))[:])
			// load vector for step i:
			femMassDistrNewm(i)
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femLinEqSystemSolve((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:], (*[1000000]tVector)(unsafe.Pointer(&pp))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			// displacement change coputation
			femVecLinCombBig(1, (*[1000000]tVector)(unsafe.Pointer(&u))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&r0))[:], (*[1000000]tVector)(unsafe.Pointer(&dr))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:], a[6], (*[1000000]tVector)(unsafe.Pointer(&dr))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:], a[7], (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:], a[8], (*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&rr1))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&rr1))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&rr1))[:], a[9], (*[1000000]tVector)(unsafe.Pointer(&rrr1))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&rr1))[:], a[9], (*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
			if i < steps-1 {
				// clone new to old for next step:
				femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&r0))[:])
				femVecClone((*[1000000]tVector)(unsafe.Pointer(&rr1))[:], (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
				femVecClone((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:], (*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
			}
			if femTangentMatrix == 1 {
				if (func() int32 {
					pos = femKpos(femSaPoNode, 3)
					return pos
				}()) > 0 {
					// tracking points:
					val = femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], pos)
				} else {
					val = 0
				}
				femSaPoInput(dt*float64(i), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 2)), val, 0, 0)
			}
			if (func() int32 {
				rv = fem_fill_K(1)
				return rv
			}()) != 0 {
				// results on elements:
				goto memFree
			}
			if len((func() []byte {
				fnm = femSubStepFname(i)
				return fnm
			}())) != 0 {
				// if running as Monte library then data should be checked here:
				// writing of results
				solID = i
				// time data
				solSimNum = dt * float64(i)
				if (func() int32 {
					rv = femWriteRes(fnm)
					return rv
				}()) != 0 {
					_ = fnm
					fnm = nil
					goto memFree
				}
				_ = fnm
				fnm = nil
			}
			noarch.Fprintf(msgout, []byte("[i]   %s: %s %f \n\x00"), []byte("Newmark step done\x00"), []byte("cummulative time\x00"), float64(i)*dt)
		}
	}
memFree:
	;
	//end of time steps iteration
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// nols_brick_type - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_nols.c:31
//
//   File name: fem_nols.c
//   Date:      2006/11/05 16:02
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2006 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 Simple nonlocal-like material model procedures (for clay bricks and so)
//
var nols_brick_type []int32

// nols_brick_brck - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_nols.c:32
var nols_brick_brck []int32

// nols_brick_near_2d - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_nols.c:36
func nols_brick_near_2d(mat_id int32, br_list []int32, br_list_max int32) int32 {
	//
	//
	var num int32
	return num
}

// femMultNRM - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_nrm.c:123
func femMultNRM(incr_type int32, i int32, n int32) float64 {
	//
	//   File name: fem_nrm.c
	//   Date:      2007/02/05 15:17
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2007 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM solver: Newton-Raphson Method
	//
	// from fem_sol.c:
	// total number of ACTIVE DOFs in structure (== size of "K" matrix)
	// lenght of nDOFfld
	// description of DOFs in nodes
	// numbers of items in "K" rows K_rows[nDOFAct]
	// K_rows for full ALM
	// structure stiffness matrix
	// structure load vector
	// unballanced forces vector
	// structure displacement vector
	// structure displacement vector - total displacements (NRM)
	// substep displacement vector for ALM
	// substep unballanced displacement vector for ALM
	// substep unballanced displacement vector for ALM
	// substep unballanced displacement vector for ALM
	// step sum of unballanced forces for full ALM
	// whole load vector full ALM
	// structure and step matrix for full ALM
	// displacement and lambda vectro for full ALM
	// load and arc lenght vector for full ALM
	// Stop signal function for NRM
	// * @param sig_num (unused but required) signal number
	//
	// Computes multiplier for NRM
	// * @param incr_type type of increment computation
	// * @param i step number (1,2,..)
	// * @param number of steps
	// * @return multiplier value
	//
	var mult float64
	var x float64
	var x0 float64
	mult = 1
	if n == 1 {
		return 1
	}
	switch incr_type {
	case 0:
		if femTangentMatrix == 1 {
			// linear
			mult = 1 / float64(n)
		} else {
			mult = float64(i) / float64(n)
		}
	case 1:
		x = float64(i) / float64(n) * (0.5 * 3.141592653589793)
		if femTangentMatrix == 1 {
			x0 = float64(i-1) / float64(n) * (0.5 * 3.141592653589793)
			mult = math.Sin(x) - math.Sin(x0)
		} else {
			mult = math.Sin(x)
		}
		fallthrough
	case 2:
		if i <= int32(0.5*float64(n)) {
			if femTangentMatrix == 1 {
				mult = 1 * (0.75 / (0.5 * float64(n)))
			} else {
				mult = float64(i) * (0.75 / (0.5 * float64(n)))
			}
		} else {
			if femTangentMatrix == 1 {
				mult = 1 * (0.25 / (0.5 * float64(n)))
			} else {
				mult = (float64(i) - 0.5*float64(n)) * (0.25 / (0.5 * float64(n)))
				mult += 0.75
			}
		}
	default:
		// unknown
		mult = 1
		break
	}
	return mult
}

// femSolveNRM - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_nrm.c:192
func femSolveNRM(incr_type int32) int32 {
	// Non-linear analysis: Newton-Raphson Method
	// * @param incr_type method for computation on load increment
	// * @return state value
	//
	var rv int32
	// load multiplier
	var multF float64 = 1
	// total load multiplier
	var multSum float64
	// convergence criteria (might be 2%)
	var crit float64 = 2e-08
	// max residuum size
	var rsize float64 = 1e+20
	var normF float64
	var normFr float64
	// number of steps
	var steps int32 = 1
	// number of iterations
	var substeps int32 = 334
	var nobreak int32
	var converged int32
	var sum_jter int32
	var i int32
	var j int32
	var jb int32
	var lastnorm []float64 = make([]float64, 4)
	var lastnormpos int32 = -1
	var lni int32
	//crit     = solNoLinPre ;
	steps = solNoLinSteps
	substeps = solNoLinIter
	//rsize    = solNoLinBig ;
	nobreak = solNoBreakStep
	noarch.Fprintf(msgout, []byte("[I] NRM %s:\n\x00"), []byte("Solution\x00"))
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done _before_ adding of loads!
		goto memFree
	}
	if femTangentMatrix == 1 {
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	}
	// sum of reactions
	femGetSumReactInit(femSumReactName)
	{
		// loop:
		for i = 1; i <= steps; i++ {
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
			multF = femMultNRM(incr_type, i, steps)
			if femTangentMatrix == 1 {
				multSum += multF
			} else {
				multSum = multF
			}
			if (func() int32 {
				rv = fem_fill_K(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_loads(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_disps(1, 0)
				return rv
			}()) != 0 {
				goto memFree
			}
			femValVecMultSelf(multF, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			if femSaveSparMatFStat == 1 {
				femSparseMatPrnF(femSubStepMatrixFname(femSaveSparMatFName, i), (*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			}
			if femSaveVecFStat == 1 {
				femVecPrnF(femSubStepMatrixFname(femSaveVecFName, i), (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			}
			if solUseBiCGs != 1 {
				if solUseCGSSOR != 1 {
					if (func() int32 {
						rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/100, nDOFAct*2)
						return rv
					}()) != 0 {
						goto memFree
					}
				} else {
					if (func() int32 {
						rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/100, nDOFAct*2)
						return rv
					}()) != 0 {
						goto memFree
					}
				}
			} else {
				if (func() int32 {
					rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/100, nDOFAct*2)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
			if femRunSolIterBC == 1 {
				for jb = 0; jb < resRLen; jb++ {
					resRval0[jb] = resRval[jb]
				}
			}
			if femTangentMatrix == 1 {
				femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			}
			normF = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			{
				// set last convergence norms to zero  **********************8
				for lni = 0; lni < 4; lni++ {
					lastnorm[lni] = 0
				}
			}
			lastnormpos = -1
			{
				// *************************************8********************8
				// iteration:
				for j = 1; j <= substeps; j++ {
					sum_jter++
					noarch.Fprintf(msgout, []byte("[ ] NRM %s: %3i / %3i, %s: %3i / %3i\n\x00"), []byte("step\x00"), i, steps, []byte("iteration\x00"), j, substeps)
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
					femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
					if (func() int32 {
						rv = fem_fill_K(1)
						return rv
					}()) != 0 {
						goto memFree
					}
					normFr = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					noarch.Fprintf(msgout, []byte("[ ] NRM [%i,%i]: norm(Fr) = %e\n\x00"), i, j, normFr)
					femWriteSolNorm(sum_jter, multSum, normFr, normF*crit, normF*rsize)
					if normFr > normF*rsize {
						// residuum too big
						converged = 0
						noarch.Fprintf(msgout, []byte("[E] NRM: %s (%e)!\n\x00"), []byte("Unconverged solution - residuum too large\x00"), normFr)
						goto memFree
					}
					if normFr/normF <= crit {
						// convergence testing:
						converged = 1
						break
					} else {
						if lastnormpos < 4-1 {
							// see last convergence norms: *****************************8
							lastnormpos++
							lastnorm[lastnormpos] = normFr
						} else {
							if lastnormpos >= 4-1 {
								// to be sure
								lastnormpos = 4 - 1
								for lni = 0; lni < lastnormpos; lni++ {
									lastnorm[lni] = lastnorm[lni+1]
								}
								lastnorm[lastnormpos] = normFr
							}
						}
						if lastnormpos > 2 {
							if math.Abs((lastnorm[lastnormpos]-lastnorm[lastnormpos-2])/lastnorm[lastnormpos]) <= 0.01 {
								// similar norms detection:
								// do something:
								noarch.Fprintf(msgout, []byte("[W] %s [%i/%i] %e <> %e\n\x00"), []byte("Convergence norms are close at\x00"), i, j, lastnorm[lastnormpos-2], lastnorm[lastnormpos])
							}
						}
						// end of  last convergence norms **************************8
						converged = 0
						femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
						if (func() int32 {
							rv = fem_fill_K(0)
							return rv
						}()) != 0 {
							goto memFree
						}
						if femTangentMatrix == 1 {
							femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
							femVecClone((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:])
							femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
							femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
							if (func() int32 {
								rv = fem_add_disps(0, 0)
								return rv
							}()) != 0 {
								// is it OK?
								goto memFree
							}
						} else {
							femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
							femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
							if (func() int32 {
								rv = fem_add_loads(0)
								return rv
							}()) != 0 {
								// Next two lines were interchanged. Is it correct?
								goto memFree
							}
							femValVecMultSelf(multF, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
							if (func() int32 {
								rv = fem_add_disps(0, 0)
								return rv
							}()) != 0 {
								goto memFree
							}
						}
						if solUseBiCGs != 1 {
							if solUseCGSSOR != 1 {
								if (func() int32 {
									rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/100, nDOFAct*2)
									return rv
								}()) != 0 {
									goto memFree
								}
							} else {
								if (func() int32 {
									rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/100, nDOFAct*2)
									return rv
								}()) != 0 {
									goto memFree
								}
							}
						} else {
							if (func() int32 {
								rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/100, nDOFAct*2)
								return rv
							}()) != 0 {
								goto memFree
							}
						}
						if femRunSolIterBC == 1 {
							for jb = 0; jb < resRLen; jb++ {
								resRval0[jb] = resRval[jb]
							}
						}
						if femTangentMatrix == 1 {
							femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
						}
					}
				}
			}
			if converged == 0 {
				noarch.Fprintf(msgout, []byte("[E] NRM: %s: %i !\n\x00"), []byte("Unconverged step\x00"), i)
				if nobreak != 1 {
					goto memFree
				}
			}
			if femTangentMatrix == 1 {
				femSaPoInput(multSum, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 2)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 3)), 0, 0)
			} else {
				femSaPoInput(multSum, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 2)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 3)), 0, 0)
			}
			// reactions
			femGetSumReact(i, sum_jter, multSum, femSumReactName, femTangentMatrix)
			if femSubStepCheckNumber(i) == 1 {
				if femTangentMatrix == 1 {
					// substep results
					// really necessary?
					femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
				}
				solSimNum = multSum
				if (func() int32 {
					rv = femWriteRes(femSubStepFname(i))
					return rv
				}()) != 0 {
					goto memFree
				}
				if femTangentMatrix == 1 {
					// really necessary?
					femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
				}
				solID++
				if femComputePE == 1 {
					femCompPE((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1)
				}
			}
		}
	}
	if femTangentMatrix == 1 {
		femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	}
	solSimNum = multSum
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
	if femTangentMatrix == 1 {
		// really necessary?
		femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	}
	noarch.Fprintf(msgout, []byte("[I] NRM: %s.\n\x00"), []byte("Solution done\x00"))
memFree:
	;
	fem_sol_free()
	femDataFree()
	femResFree()
	noarch.Fprintf(msgout, []byte("[ ] NRM Solution return: %i\n\x00"), rv)
	femCloseSolNormFile()
	return rv
}

// femSolveDirDisps - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_nrm.c:559
func femSolveDirDisps(incr_type int32) int32 {
	// Direct displacement solver
	// * @param incr_type type of load increment
	// * @return solution status
	//
	var rv int32
	// load multiplier
	var multF float64 = 1
	// total load multiplier
	var multSum float64
	// convergence criteria
	var crit float64 = 1e-06
	// max residuum size
	var rsize float64 = 1e+18
	var normF float64
	var normFr float64
	// number of steps
	var steps int32 = 1
	// number of iterations
	var substeps int32 = 667
	var nobreak int32
	var converged int32
	var sum_jter int32
	var i int32
	var j int32
	//crit     = solNoLinPre ;
	steps = solNoLinSteps
	substeps = solNoLinIter
	//rsize    = solNoLinBig ;
	nobreak = solNoBreakStep
	noarch.Fprintf(msgout, []byte("[I] DDS %s:\n\x00"), []byte("Solution\x00"))
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done _before_ adding of loads!
		goto memFree
	}
	if femTangentMatrix == 1 {
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	}
	// sum of reactions
	femGetSumReactInit(femSumReactName)
	{
		// loop:
		for i = 1; i <= steps; i++ {
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
			multF = femMultNRM(incr_type, i, steps)
			if femTangentMatrix == 1 {
				multSum += multF
			} else {
				multSum = multF
			}
			noarch.Fprintf(msgout, []byte("[ ] DDS %s %i (%s %i): %f\n\x00"), []byte("step\x00"), i, []byte("from\x00"), steps, multF)
			if (func() int32 {
				rv = fem_fill_K(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_loads(0)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = fem_add_disps(1, 0)
				return rv
			}()) != 0 {
				goto memFree
			}
			femValVecMultSelf(multF, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			if femSaveSparMatFStat == 1 {
				femSparseMatPrnF(femSubStepMatrixFname(femSaveSparMatFName, i), (*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			}
			if femSaveVecFStat == 1 {
				femVecPrnF(femSubStepMatrixFname(femSaveVecFName, i), (*[1000000]tVector)(unsafe.Pointer(&F))[:])
			}
			if solUseBiCGs != 1 {
				if solUseCGSSOR != 1 {
					if (func() int32 {
						rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10, nDOFAct*2)
						return rv
					}()) != 0 {
						goto memFree
					}
				} else {
					if (func() int32 {
						rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10, nDOFAct*2)
						return rv
					}()) != 0 {
						goto memFree
					}
				}
			} else {
				if (func() int32 {
					rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10, nDOFAct*2)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
			if femTangentMatrix == 1 {
				femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
			}
			normF = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			{
				// "iteration"
				for j = 1; j <= substeps; j++ {
					sum_jter++
					noarch.Fprintf(msgout, []byte("[ ] DDS step=%i iter=%i (from %i)\n\x00"), i, j, substeps)
					femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
					if (func() int32 {
						rv = fem_fill_K(1)
						return rv
					}()) != 0 {
						goto memFree
					}
					normFr = femVecNormBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
					noarch.Fprintf(msgout, []byte("[ ] DDS [%i,%i]: norm(Fr) = %e\n\x00"), i, j, normFr)
					femWriteSolNorm(sum_jter, multSum, normFr, normF*crit, normF*rsize)
					converged = 1
					break
				}
			}
			if converged == 0 {
				noarch.Fprintf(msgout, []byte("[E] DDS: %s: %i !\n\x00"), []byte("Unconverged step\x00"), i)
				if nobreak != 1 {
					goto memFree
				}
			}
			if femTangentMatrix == 1 {
				femSaPoInput(multSum, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 2)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], femKpos(femSaPoNode, 3)), 0, 0)
			} else {
				femSaPoInput(multSum, femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 1)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 2)), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(femSaPoNode, 3)), 0, 0)
			}
			// reactions
			femGetSumReact(i, j, multSum, femSumReactName, femTangentMatrix)
			if femSubStepCheckNumber(i) == 1 {
				if femTangentMatrix == 1 {
					// substep results
					// really necessary?
					femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
				}
				solSimNum = multSum
				if (func() int32 {
					rv = femWriteRes(femSubStepFname(i))
					return rv
				}()) != 0 {
					goto memFree
				}
				if femTangentMatrix == 1 {
					// really necessary?
					femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
				}
				solID++
			}
		}
	}
	if femTangentMatrix == 1 {
		femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	}
	solSimNum = multSum
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
	if femTangentMatrix == 1 {
		// really necessary?
		femVecSwitch((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:])
	}
	noarch.Fprintf(msgout, []byte("[I] DDS: %s.\n\x00"), []byte("Solution done\x00"))
memFree:
	;
	fem_sol_free()
	femDataFree()
	femResFree()
	noarch.Fprintf(msgout, []byte("[ ] DDS Solution return: %i\n\x00"), rv)
	femCloseSolNormFile()
	return rv
}

// od3d_D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_od3d.c:42
func od3d_D(ePos int32, iPoint int32, Mode int32, epsilon []tVector, D []tMatrix) int32 {
	//
	//   File name: fem_od3d.c
	//   Date:      2007/09/25 20:25
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2007 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM solver: 3D material/elements with compression-only behaviour
	//               (requested by prof. Janas for ani-detonation barriers)
	//
	//   Note: meant for use with elements 010 to simulate a concrete
	//
	//
	// Computes D for linear 3D point "without tension"
	// * @param ePos element position
	// * @param iPoint integration point to be computed
	// * @param Mode AF_NO (old matrix) or AF_YES (new matrix)
	// * @param epsilon current TOTAL epsilon vector [6]
	// * @param D matrix to be created
	// * @return status
	//
	var rv int32
	var E float64
	var E1 float64
	var nu float64
	// tension is not allowed right now
	var max float64 = 1e-17
	// residual stiffness
	var res float64 = 1e-17
	var stat int32
	var i int32
	var sigma_x tVector
	var sigma_1 tVector
	var old_sigma tVector
	E = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	stat = int32(femGetRepVal(ePos, 38, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	if stat == 0 {
		// undamaged material
		stat = 1
		E1 = E
	} else {
		// damaged material
		E1 = femGetRepVal(ePos, 37, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	}
	if Mode == 1 {
		// NEW matrix
		max = femGetMPValPos(ePos, 7, 0)
		res = femGetMPValPos(ePos, 10, 0)
		if max < 1e-17 {
			max = 1e-17
		}
		if res < 10 {
			res = 10
		}
		femD_3D_iso(ePos, E1, nu, D)
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 0, 6, 6)
			return rv
		}()) != 0 {
			goto memFree
		}
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 1, femGetRepVal(ePos, 7, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 2, femGetRepVal(ePos, 8, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 3, femGetRepVal(ePos, 9, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 4, femGetRepVal(ePos, 11, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 5, femGetRepVal(ePos, 12, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 6, femGetRepVal(ePos, 10, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femMatVecMult(D, epsilon, (*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
		for i = 1; i <= 6; i++ {
			femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], i), 1)
		}
		femPrinc3D((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
		if femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) >= max {
			if stat != -1 {
				// damage test
				femIterEchange++
			}
			stat = -1
			E1 = res
		} else {
			if stat != 1 {
				//femIterEchange++;
				E1 = res
				stat = -1
			} else {
				E1 = E
				stat = 1
			}
		}
		if femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) < 0 && stat == -1 {
			// some help for compression
			E1 = 0.8 * E
		}
	memFree:
		;
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
		femAddPutRepVal(ePos, 37, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, E1)
		femAddPutRepVal(ePos, 38, iPoint, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(stat))
	} else {
		// old matrix
		femD_3D_iso(ePos, E1, nu, D)
	}
	return rv
}

// femPreparsedData - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:41
//
//   File name: fem_para.c
//   Date:      2003/05/26 23:42
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - command line parameters handling
//
//
// "fast" work with boundary conditions
// if input data are preparsed
var femPreparsedData int32

// femReadStdInput - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:42
// if input data comes through stdin
var femReadStdInput int32

// femWriteStdOutput - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:43
// if output data are send to stdout
var femWriteStdOutput int32

// femWriteStdThrOut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:44
// if therm output vector is send to stdout
var femWriteStdThrOut int32

// femUseSaPo - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:45
// if saves result data in selected point
var femUseSaPo int32

// femReadPrevStep - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:46
// if there are results from previous step
var femReadPrevStep int32

// femReadPrevThr - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:47
// if there are results from previous therm
var femReadPrevThr int32

// femPrevStdInput - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:48
// if prev. step's results are from stdin
var femPrevStdInput int32

// femPrevThrStdIn - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:49
// if prev. step's therm res. from stdin
var femPrevThrStdIn int32

// femExtraResOut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:50
// if extra LINEAR results will be written
var femExtraResOut int32

// femExtraResType - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:51
// type of extra result data
var femExtraResType int32

// femComputePE - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:52
// compute potential energy
var femComputePE int32

// femTensorScale - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:53
// prepare tensor scale data
var femTensorScale int32

// femTensorScaleDiv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:55
// prepare tensor scale division size
var femTensorScaleDiv int32 = 10

// fem_ifile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:63
// input file
var fem_ifile []byte

// fem_ofile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:64
// results
var fem_ofile []byte

// fem_rfile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:65
// previous results
var fem_rfile []byte

// fem_thrfile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:67
// previous thermal results
var fem_thrfile []byte

// fem_throfile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:68
// thermal results saving
var fem_throfile []byte

// fem_ssfile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:70
// substep result file
var fem_ssfile []byte

// fem_tsfile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:72
// tensor scale file
var fem_tsfile []byte

// fem_spec_out_file - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:75
var fem_spec_out_file []byte

// fem_spec_out_type - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:76
var fem_spec_out_type int32

// femSaveMatFStat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:79
var femSaveMatFStat int32

// femSaveSparMatFStat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:80
var femSaveSparMatFStat int32

// femSaveSparMarketMatFStat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:81
var femSaveSparMarketMatFStat int32

// femSaveVecFStat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:82
var femSaveVecFStat int32

// femSaveMatFName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:84
var femSaveMatFName []byte

// femSaveSparMatFName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:85
var femSaveSparMatFName []byte

// femSaveSparMarketMatFName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:86
var femSaveSparMarketMatFName []byte

// femSaveVecFName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:87
var femSaveVecFName []byte

// femSaveEveryNth - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:91
// save every Nth substep in NRM
var femSaveEveryNth int32

// femBreakSolu - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:93
// break linear solution after matrices were written - for MC etc.
var femBreakSolu int32

// femDynamics - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:95
// indicates non-static solution
var femDynamics int32

// femEigenModal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:96
// modal solution
var femEigenModal int32

// femEigenNum - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:97
// number of computed mode shapess
var femEigenNum int32

// femEigenInvI - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:98
// use inverse iterations method for 1st eigenvalue
var femEigenInvI int32 = 1

// femNewmarkEL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:99
// newmark integration solver
var femNewmarkEL int32

// femComputePriceOnly - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:100
// computer price and exit
var femComputePriceOnly int32

// femComputeGrCenOnly - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:101
// computer price and exit
var femComputeGrCenOnly int32

// femThermTrans - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:102
// indicates thermal transient solution
var femThermTrans int32

// fem_sol_norm_file - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:104
var fem_sol_norm_file *noarch.File

// fem_help - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:110
func fem_help(argc int32, argv [][]byte) {
	// Prints simple help to stdout
	// * @param argc the same as "argc" from main
	// * @param argv the same as "argv" from main
	//
	noarch.Fprintf(msgout, []byte("\nuFEM %s: %s\n\x00"), []byte("0.5.3\x00"), []byte("tool for finite element analysis\x00"))
	noarch.Fprintf(msgout, []byte("(C) Jiri Brozovsky\x00"))
	noarch.Fprintf(msgout, []byte("\n\n\x00"))
	noarch.Fprintf(msgout, []byte("%s: %s [%s]\n\n %s:\n\x00"), []byte(" Usage\x00"), argv[0], []byte("arguments\x00"), []byte("Arguments\x00"))
	noarch.Fprintf(msgout, []byte("   -i  IFILE ... %s\n\x00"), []byte("read data from IFILE\x00"))
	noarch.Fprintf(msgout, []byte("   -si       ... %s\n\x00"), []byte("read data from standard input\x00"))
	noarch.Fprintf(msgout, []byte("   -p        ... %s\n\x00"), []byte("input data are preparsed (indexed)\x00"))
	noarch.Fprintf(msgout, []byte("   -o  OFILE ... %s\n\x00"), []byte("write output data to OFILE\x00"))
	noarch.Fprintf(msgout, []byte("   -so       ... %s\n\x00"), []byte("write output data to standard output\x00"))
	noarch.Fprintf(msgout, []byte("   -e        ... %s\n\x00"), []byte("send all messages to stderr\x00"))
	noarch.Fprintf(msgout, []byte("   -r  RFILE ... %s\n\x00"), []byte("read previous step results from RFILE\x00"))
	noarch.Fprintf(msgout, []byte("   -sr       ... %s\n\x00"), []byte("read previous step results from standard input\x00"))
	noarch.Fprintf(msgout, []byte("   -ose N    ... %s\n\x00"), []byte("save every N-th substep results (if applicable)\x00"))
	noarch.Fprintf(msgout, []byte("   -osf NAME ... %s\n\x00"), []byte("template name for substeps results (if applicable)\x00"))
	noarch.Fprintf(msgout, []byte("   -ln  NODE ... %s\n\x00"), []byte("set logged node to NODE (optional)\x00"))
	noarch.Fprintf(msgout, []byte("   -lf  FILE ... %s\n\x00"), []byte("save data in logged node to FILE (required for -ln) \x00"))
	noarch.Fprintf(msgout, []byte("   -lrf FILE ... %s\n\x00"), []byte("save sums of reactions to FILE\x00"))
	noarch.Fprintf(msgout, []byte("   -lrso     ... %s\n\x00"), []byte("write sums of reactions to standard output\x00"))
	noarch.Fprintf(msgout, []byte("   -mf  FILE ... %s\n\x00"), []byte("save global stiffness matrix to FILE (linear solution only) \x00"))
	noarch.Fprintf(msgout, []byte("   -msf FILE ... %s\n\x00"), []byte("same as \"-mf\" but matrix is saved in sparse form \x00"))
	noarch.Fprintf(msgout, []byte("   -mmf FILE ... %s\n\x00"), []byte("save global stiffness matrix in Matrix Market format\x00"))
	noarch.Fprintf(msgout, []byte("   -vf  FILE ... %s\n\x00"), []byte("save global load vector to FILE (linear solution only) \x00"))
	noarch.Fprintf(msgout, []byte("   -d        ... %s\n\x00"), []byte("iterative solution for compression/tension only b. conditions\x00"))
	noarch.Fprintf(msgout, []byte("   -b        ... %s\n\x00"), []byte("halt program before DOF computation\x00"))
	noarch.Fprintf(msgout, []byte("   -nls   N  ... %s\n\x00"), []byte("non-linear solver type (2..Newton-Raphson, 3..Arc-Length)\x00"))
	noarch.Fprintf(msgout, []byte("   -nlstp N  ... %s\n\x00"), []byte("do N non-linear substeps (N have to be even)\x00"))
	noarch.Fprintf(msgout, []byte("   -nlit  N  ... %s\n\x00"), []byte("do max N non-linear iteration in substep\x00"))
	noarch.Fprintf(msgout, []byte("   -nlf FILE ... %s\n\x00"), []byte("save convergence norms (if any) to FILE\x00"))
	noarch.Fprintf(msgout, []byte("   -nlnbrk   ... %s\n\x00"), []byte("do not break non-linear solution on unconverged steps\x00"))
	noarch.Fprintf(msgout, []byte("   -mod N    ... %s\n\x00"), []byte("do modal analysis for first N eigenvalues\x00"))
	noarch.Fprintf(msgout, []byte("   -nwm      ... %s\n\x00"), []byte("do dynamic analysis by Newmark integration\x00"))
	noarch.Fprintf(msgout, []byte("   -tth      ... %s\n\x00"), []byte("do thermal transient analysis \x00"))
	noarch.Fprintf(msgout, []byte("   -teste N  ... %s\n\x00"), []byte("run test solution only for element N\x00"))
	noarch.Fprintf(msgout, []byte("   -testi M  ... %s\n\x00"), []byte("run \"-teste N\" for integration point M\x00"))
	noarch.Fprintf(msgout, []byte("   -testx X  ... %s\n\x00"), []byte("given strain X for \"-teste\" \x00"))
	noarch.Fprintf(msgout, []byte("   -testy Y  ... %s\n\x00"), []byte("given strain Y for \"-teste\" \x00"))
	noarch.Fprintf(msgout, []byte("   -testxy XY... %s\n\x00"), []byte("given strain XY for \"-teste\" \x00"))
	noarch.Fprintf(msgout, []byte("   -testa  A ... %s\n\x00"), []byte("area or volume for \"-teste\" (if needed) \x00"))
	noarch.Fprintf(msgout, []byte("   -nes      ... %s\n\x00"), []byte("use equation solver for non-symetric systems\x00"))
	noarch.Fprintf(msgout, []byte("   -ssor     ... %s\n\x00"), []byte("use SSOR instead of Jacobi preconditioning in CG solver\x00"))
	noarch.Fprintf(msgout, []byte("   -fbc      ... %s\n\x00"), []byte("faster handling of fixed supports in statics (no reactions)\x00"))
	noarch.Fprintf(msgout, []byte("   -ao FILE  ... %s\n\x00"), []byte("write alternative results of linear solution to FILE\x00"))
	noarch.Fprintf(msgout, []byte("   -at TYPE  ... %s\n\x00"), []byte("type of alternative results (0 .. text, 1 .. VTK, 2 .. SILO )\x00"))
	noarch.Fprintf(msgout, []byte("   -to FILE  ... %s\n\x00"), []byte("write thermal results to FILE\x00"))
	noarch.Fprintf(msgout, []byte("   -tos      ... %s\n\x00"), []byte("write thermal results to stdout\x00"))
	noarch.Fprintf(msgout, []byte("   -ti FILE  ... %s\n\x00"), []byte("read thermal results from FILE\x00"))
	noarch.Fprintf(msgout, []byte("   -tis      ... %s\n\x00"), []byte("read thermal results from stdin\x00"))
	noarch.Fprintf(msgout, []byte("   -po       ... %s\n\x00"), []byte("compute structure price and write it to stdout\x00"))
	noarch.Fprintf(msgout, []byte("   -pc       ... %s\n\x00"), []byte("compute structure centre of gravity and write it to stdout\x00"))
	noarch.Fprintf(msgout, []byte("   -e        ... %s\n\x00"), []byte("compute potential energy and write it to stdout\x00"))
	noarch.Fprintf(msgout, []byte("   -ts DIV   ... %s\n\x00"), []byte("prepare tensor scale data with X division DIV\x00"))
	noarch.Fprintf(msgout, []byte("   -tso FILE ... %s\n\x00"), []byte("save tensor scale data to FILE\x00"))
	noarch.Fprintf(msgout, []byte("   -h        ... %s\n\x00"), []byte("print this help\x00"))
}

// fem_set_iofile - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:207
func fem_set_iofile(str []byte) (c4goDefaultReturn []byte) {
	// Sets input file name
	// * @param source
	// * @return filename (NULL on error)
	//
	var ifile []byte
	if len((func() []byte {
		ifile = make([]byte, 1*noarch.Strlen(str)+int32(1))
		return ifile
	}())) == 0 {
		return nil
	} else {
		noarch.Strcpy(ifile, str)
		ifile[noarch.Strlen(str)] = '\x00'
		return ifile
	}
	return
}

// femMiscFileName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:228
func femMiscFileName(fname []byte, status_val []int32) []byte {
	// Sets filename for femSaPo data
	// *  @param fname name of file
	// *  @return status
	//
	var name_string []byte
	if len((func() []byte {
		name_string = make([]byte, 1*(noarch.Strlen(fname)+int32(1)))
		return name_string
	}())) == 0 {
		status_val[0] = 0
	} else {
		noarch.Strcpy(name_string, fname)
		name_string[noarch.Strlen(fname)] = '\x00'
		status_val[0] = 1
	}
	return name_string
}

// fem_parse_params - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:251
func fem_parse_params(argc int32, argv [][]byte) int32 {
	// Parses command line parameteres and sets some variables
	// * @param argc the same as "argc" from main
	// * @param argv the same as "argv" from main
	// * @return state value (AF_OK)
	//
	var rv int32
	var i int32
	if argc == 1 {
		fem_help(argc, argv)
		noarch.Exit(-3)
	}
	if argc == 2 && int32(argv[1][0]) != int32('-') {
		if len((func() []byte {
			fem_ifile = fem_set_iofile(argv[1])
			return fem_ifile
		}())) == 0 {
			return -3
		}
	}
	for i = 1; i < argc; i++ {
		if noarch.Strcmp(argv[i], []byte("-p\x00")) == 0 {
			// preparsed data
			femPreparsedData = 1
		}
		if noarch.Strcmp(argv[i], []byte("-i\x00")) == 0 {
			if argc < i+2 {
				// input file
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_ifile = fem_set_iofile(argv[i+1])
					return fem_ifile
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-si\x00")) == 0 {
			// std input
			femReadStdInput = 1
			fem_ifile = nil
		}
		if noarch.Strcmp(argv[i], []byte("-o\x00")) == 0 {
			if argc < i+2 {
				// output file
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_ofile = fem_set_iofile(argv[i+1])
					return fem_ofile
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-so\x00")) == 0 {
			// std output  (implies msgout = stderr)
			femWriteStdOutput = 1
			fem_ofile = nil
			msgout = noarch.Stderr
		}
		if noarch.Strcmp(argv[i], []byte("-e\x00")) == 0 {
			// send messages to stderr
			msgout = noarch.Stderr
		}
		if noarch.Strcmp(argv[i], []byte("-r\x00")) == 0 {
			if argc < i+2 {
				// previous step's file
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_rfile = fem_set_iofile(argv[i+1])
					return fem_rfile
				}())) == 0 {
					return -3
				}
				femReadPrevStep = 1
			}
		}
		if noarch.Strcmp(argv[i], []byte("-sr\x00")) == 0 {
			// std input
			femPrevStdInput = 1
			femReadPrevStep = 1
			fem_rfile = nil
		}
		if noarch.Strcmp(argv[i], []byte("-lf\x00")) == 0 {
			if argc < i+2 {
				// SaPo handling
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if femSaPoFileName(argv[i+1]) != 0 {
					femUseSaPo = 0
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-ln\x00")) == 0 {
			if argc < i+2 {
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femSaPoNode = noarch.Atoi(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-lrf\x00")) == 0 {
			if argc < i+2 {
				// file for saving of reactions:
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if femSumReactFileName(argv[i+1]) != 0 {
					femSumReactName = nil
					return -3
				}
				// use stdout?
				femSumReactStdOut = 0
			}
		}
		if noarch.Strcmp(argv[i], []byte("-lrso\x00")) == 0 {
			// saving of reactions to stdout:
			msgout = noarch.Stderr
			femSumReactName = nil
			// use stdout?
			femSumReactStdOut = 1
		}
		if noarch.Strcmp(argv[i], []byte("-mf\x00")) == 0 {
			if argc < i+2 {
				// saving of stiffness matrix and/or load vector
				// matrix
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					femSaveMatFName = femMiscFileName(argv[i+1], c4goUnsafeConvert_int32(&femSaveMatFStat))
					return femSaveMatFName
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-msf\x00")) == 0 {
			if argc < i+2 {
				// sparse matrix
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					femSaveSparMatFName = femMiscFileName(argv[i+1], c4goUnsafeConvert_int32(&femSaveSparMatFStat))
					return femSaveSparMatFName
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-mmf\x00")) == 0 {
			if argc < i+2 {
				// sparse matrix
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					femSaveSparMarketMatFName = femMiscFileName(argv[i+1], c4goUnsafeConvert_int32(&femSaveSparMarketMatFStat))
					return femSaveSparMarketMatFName
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-vf\x00")) == 0 {
			if argc < i+2 {
				// vector
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					femSaveVecFName = femMiscFileName(argv[i+1], c4goUnsafeConvert_int32(&femSaveVecFStat))
					return femSaveVecFName
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-2t\x00")) == 0 {
			// 2nd order theory
			fem2ndOrder = 1
		}
		if noarch.Strcmp(argv[i], []byte("-b\x00")) == 0 {
			femBreakSolu = 1
		}
		if noarch.Strcmp(argv[i], []byte("-osf\x00")) == 0 {
			if argc < i+2 {
				// substep's file template
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_ssfile = fem_set_iofile(argv[i+1])
					return fem_ssfile
				}())) == 0 {
					return -3
				}
				if femSaveEveryNth == 0 {
					femSaveEveryNth = 1
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-ose\x00")) == 0 {
			if argc < i+2 {
				// N for every Nth substep
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					femSaveEveryNth = noarch.Atoi(argv[i+1])
					return femSaveEveryNth
				}()) < 1 {
					femSaveEveryNth = 1
					return -9
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-d\x00")) == 0 {
			// iteration for b.c.
			femRunSolIterBC = 1
		}
		if noarch.Strcmp(argv[i], []byte("-nls\x00")) == 0 {
			if argc < i+2 {
				// non-linear solver
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					solNoLinS_cmd = noarch.Atoi(argv[i+1])
					return solNoLinS_cmd
				}()) < 0 {
					solNoLinS_cmd = 0
					return -9
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-nlstp\x00")) == 0 {
			if argc < i+2 {
				// non-linear substeps
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					solNoLinSteps_cmd = noarch.Atoi(argv[i+1])
					return solNoLinSteps_cmd
				}()) < 1 {
					solNoLinSteps_cmd = 0
					return -9
				}
				solNoLinSteps_cmd = 2 * int32(float64(solNoLinSteps_cmd)/2)
				if solNoLinSteps_cmd <= 0 {
					solNoLinSteps_cmd = 2
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-nlit\x00")) == 0 {
			if argc < i+2 {
				// non-linear iterations (might be ignored)
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					solNoLinIter = noarch.Atoi(argv[i+1])
					return solNoLinIter
				}()) < 1 {
					solNoLinIter = 0
					return -9
				}
				solNoLinIter = 2 * int32(float64(solNoLinIter)/2)
				if solNoLinIter <= 0 {
					solNoLinIter = 333
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-nlf\x00")) == 0 {
			if argc < i+2 {
				// files for convergence norms
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femOpenSolNormFile(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-nlnbrk\x00")) == 0 {
			// "unbreakable" non-linear solution
			solNoBreakStep = 1
		}
		if noarch.Strcmp(argv[i], []byte("-mod\x00")) == 0 {
			if argc < i+2 {
				// DYNAMICS: modal analysis (number of eigenvalues)
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					femEigenNum = noarch.Atoi(argv[i+1])
					return femEigenNum
				}()) < 1 {
					femEigenNum = 0
					femEigenModal = 0
					femNewmarkEL = 0
					femDynamics = 0
					return -9
				} else {
					// we need data for linear solution
					solNoLinS = 1
					femEigenModal = 1
					femDynamics = 1
					femNewmarkEL = 0
					femEigenInvI = 1
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-modl\x00")) == 0 {
			// DYNAMICS: Lanczos for modal analysis
			// we need data for linear solution
			solNoLinS = 1
			femEigenModal = 1
			femDynamics = 1
			femNewmarkEL = 0
			femEigenInvI = 0
			// just the first eigenvalue is computed!
			femEigenNum = 1
		}
		if noarch.Strcmp(argv[i], []byte("-nwm\x00")) == 0 {
			// DYNAMICS: Newmark implicit integration
			// we need data for linear solution
			solNoLinS = 1
			femEigenModal = 0
			femEigenNum = 0
			femDynamics = 1
			femNewmarkEL = 1
		}
		if noarch.Strcmp(argv[i], []byte("-tth\x00")) == 0 {
			// THERMAL TRANSIENT
			// we need data for linear solution
			solNoLinS = 1
			femThermTrans = 1
		}
		if noarch.Strcmp(argv[i], []byte("-teste\x00")) == 0 {
			if argc < i+2 {
				// TESTING: element number
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					femTestConstElem = noarch.Atoi(argv[i+1])
					return femTestConstElem
				}()) < 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testi\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					femTestConstIpn = noarch.Atoi(argv[i+1])
					return femTestConstIpn
				}()) < 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testx\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femTestConstEX = noarch.Atof(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testy\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femTestConstEY = noarch.Atof(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testz\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femTestConstEZ = noarch.Atof(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testxy\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femTestConstEXY = noarch.Atof(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testyz\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femTestConstEYZ = noarch.Atof(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testzx\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				femTestConstEZX = noarch.Atof(argv[i+1])
			}
		}
		if noarch.Strcmp(argv[i], []byte("-testa\x00")) == 0 {
			if argc < i+2 {
				// TESTING: integration point
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() float64 {
					femTestConstA = noarch.Atof(argv[i+1])
					return femTestConstA
				}()) <= 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-nes\x00")) == 0 {
			// forced use of non-symetric solver
			solUseBiCGs = 1
		}
		if noarch.Strcmp(argv[i], []byte("-ssor\x00")) == 0 {
			// forced use of SSOR preconditioner solver
			solUseCGSSOR = 1
			solUseBiCGs = 0
		}
		if noarch.Strcmp(argv[i], []byte("-ao\x00")) == 0 {
			if argc < i+2 {
				// alternative output: filename
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_spec_out_file = fem_set_iofile(argv[i+1])
					return fem_spec_out_file
				}())) == 0 {
					return -3
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-at\x00")) == 0 {
			if argc < i+2 {
				// alternative output: type
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				fem_spec_out_type = noarch.Atoi(argv[i+1])
				if fem_spec_out_type < 0 {
					fem_spec_out_type = 0
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-ti\x00")) == 0 {
			if argc < i+2 {
				// *** THERMAL LOADS ****
				// previous step's thermal data file
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_thrfile = fem_set_iofile(argv[i+1])
					return fem_thrfile
				}())) == 0 {
					return -3
				}
				femReadPrevThr = 1
				femPrevThrStdIn = 0
			}
		}
		if noarch.Strcmp(argv[i], []byte("-tis\x00")) == 0 {
			// std input for therm
			femPrevThrStdIn = 1
			femReadPrevThr = 1
			fem_thrfile = nil
		}
		if noarch.Strcmp(argv[i], []byte("-to\x00")) == 0 {
			if argc < i+2 {
				// thermal results file
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_throfile = fem_set_iofile(argv[i+1])
					return fem_throfile
				}())) == 0 {
					return -3
				}
				femWriteStdThrOut = 0
			}
		}
		if noarch.Strcmp(argv[i], []byte("-tos\x00")) == 0 {
			// std input for therm
			femWriteStdThrOut = 1
			fem_throfile = nil
		}
		if noarch.Strcmp(argv[i], []byte("-fbc\x00")) == 0 {
			// excules zero displacements from solution
			femFastBC = 1
		}
		if noarch.Strcmp(argv[i], []byte("-tso\x00")) == 0 {
			// tensor scale file
			femTensorScale = 0
			if argc < i+2 {
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if len((func() []byte {
					fem_tsfile = fem_set_iofile(argv[i+1])
					return fem_tsfile
				}())) == 0 {
					return -3
				}
				femTensorScale = 1
			}
		}
		if noarch.Strcmp(argv[i], []byte("-ts\x00")) == 0 {
			if argc < i+2 {
				// set tensor scale division
				return -9
			} else {
				if int32(argv[i+1][0]) == int32('-') {
					return -3
				}
				if (func() int32 {
					femTensorScaleDiv = noarch.Atoi(argv[i+1])
					return femTensorScaleDiv
				}()) < 1 {
					femTensorScaleDiv = 1
					return -9
				}
			}
		}
		if noarch.Strcmp(argv[i], []byte("-po\x00")) == 0 {
			femComputePriceOnly = 1
		}
		if noarch.Strcmp(argv[i], []byte("-pc\x00")) == 0 {
			femComputeGrCenOnly = 1
		}
		if noarch.Strcmp(argv[i], []byte("-e\x00")) == 0 {
			femComputePE = 1
		}
		if noarch.Strcmp(argv[i], []byte("-h\x00")) == 0 {
			// help line
			fem_help(argc, argv)
			noarch.Exit(0)
		}
	}
	return rv
}

// fem_output_file - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:1147
func fem_output_file() (c4goDefaultReturn []byte) {
	if len(fem_ofile) == 0 {
		if femWriteStdOutput == 1 {
			// Returnes name for output file
			// * @return filename
			//
			return nil
		} else {
			return []byte("results.txt\x00")
		}
	} else {
		return fem_ofile
	}
	return
}

// femMCGenFname - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:1168
func femMCGenFname(name []byte, sim int32, mode int32) []byte {
	// Returnes name of MC output file
	var tmp []byte
	var len_ int32
	var i int32
	len_ = noarch.Strlen(name) + int32(10)
	if mode == 1 || mode == 2 {
		len_ += 4
	} else {
		len_ += 25
	}
	len_++
	if len((func() []byte {
		tmp = make([]byte, uint32(len_)*uint32(1))
		return tmp
	}())) == 0 {
		return []byte("\x00")
	}
	for i = 0; i < len_; i++ {
		tmp[i] = '\x00'
	}
	if mode >= 1 && mode <= 4 {
		noarch.Sprintf(tmp, []byte("%s.sum%1li\x00"), name, mode)
	} else {
		noarch.Sprintf(tmp, []byte("%s.r%li\x00"), name, sim)
	}
	return tmp
}

// femSubStepFname - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:1208
func femSubStepFname(snumber int32) []byte {
	// Returnes name of N-th number substep file
	var name []byte
	var fem_ssfile_len int32
	var name_len int32
	var snumber_len int32 = 2
	var i int32
	if len(fem_ssfile) == 0 {
		return nil
	}
	if (func() int32 {
		fem_ssfile_len = noarch.Strlen(fem_ssfile)
		return fem_ssfile_len
	}()) < 1 {
		return nil
	}
	if float64(snumber) >= 1e+10 {
		// limits number of results
		return nil
	}
	for i = 1; float64(i) < 1e+09; i++ {
		if float64(snumber)/math.Pow(10, float64(i)) > 1 {
			snumber_len++
		} else {
			break
		}
	}
	name_len = 5 + snumber_len + fem_ssfile_len
	if len((func() []byte {
		name = make([]byte, 1*int32(uint32(name_len)))
		return name
	}())) == 0 {
		return nil
	}
	for i = 0; i < name_len; i++ {
		name[i] = '\x00'
	}
	noarch.Sprintf(name, []byte("%s%li.res\x00"), fem_ssfile, snumber)
	for i = 0; i < name_len; i++ {
		if int32(name[i]) == int32(' ') || int32(name[i]) == int32('*') || int32(name[i]) == int32('\\') || int32(name[i]) == int32('\n') || int32(name[i]) == int32('\t') {
			name[i] = '0'
		}
	}
	noarch.Fprintf(msgout, []byte("Substep filename is \"%s\"\n\x00"), name)
	return name
}

// femSubStepMatrixFname - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:1264
func femSubStepMatrixFname(name0 []byte, snumber int32) []byte {
	// Returnes name of N-th number substep file
	var name []byte
	var fem_ssfile_len int32
	var name_len int32
	var snumber_len int32 = 2
	var i int32
	if len(name0) == 0 {
		return nil
	}
	if (func() int32 {
		fem_ssfile_len = noarch.Strlen(name0)
		return fem_ssfile_len
	}()) < 1 {
		return nil
	}
	if float64(snumber) >= 1e+10 {
		// limits number of results
		return nil
	}
	for i = 1; float64(i) < 1e+09; i++ {
		if float64(snumber)/math.Pow(10, float64(i)) > 1 {
			snumber_len++
		} else {
			break
		}
	}
	name_len = 5 + snumber_len + fem_ssfile_len
	if len((func() []byte {
		name = make([]byte, 1*int32(uint32(name_len)))
		return name
	}())) == 0 {
		return nil
	}
	for i = 0; i < name_len; i++ {
		name[i] = '\x00'
	}
	noarch.Sprintf(name, []byte("%s%li.mat\x00"), name0, snumber)
	for i = 0; i < name_len; i++ {
		if int32(name[i]) == int32(' ') || int32(name[i]) == int32('*') || int32(name[i]) == int32('\\') || int32(name[i]) == int32('\n') || int32(name[i]) == int32('\t') {
			name[i] = '0'
		}
	}
	noarch.Fprintf(msgout, []byte("Substep filename is \"%s\"\n\x00"), name)
	return name
}

// femSubStepCheckNumber - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_para.c:1320
func femSubStepCheckNumber(number int32) int32 {
	// Tests if iteration have to be saved
	var num int32
	if femSaveEveryNth == 1 {
		return 1
	}
	if femSaveEveryNth < 1 {
		return 0
	}
	num = number / femSaveEveryNth
	if num*femSaveEveryNth == number {
		return 1
	} else {
		return 0
	}
	return 0
}

// fem_pl1d_E - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pl1d.c:36
func fem_pl1d_E(ePos int32, Eprev float64, depsilon float64, epsilon_old float64, sigma_old float64) float64 {
	//
	//   File name: fem_pl1d.c
	//   Date:      2006/09/19 10:38
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2006 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM solver (uFEM): 1D non-linear behaviour (plasticity)
	//
	// Computes stiffness for 1D case (tangential only)
	// * @param ePes element position
	// * @param Eprev previous size of the stiffness
	// * @param depsilon current epsilon
	// * @param epsilon_old previous total epsilon
	// * @param sigma_old previous total stress
	// * @return E (stiffness)
	// *
	var mpos int32
	var Ed float64
	var sigma float64
	var s_lim float64
	var sets int32 = 1
	var i int32
	mpos = femGetIntPos(ePos, eMP, eLen)
	sets = femFldItemLen(mpos, mpFrom, mpLen, mpLenL) / Mat[4].num
	Ed = femGetMPValPos(ePos, 2, 0)
	if femTangentMatrix != 1 {
		// doesn't work for non-tangent matrix!
		return Ed
	}
	noarch.Fprintf(msgout, []byte("[ ] MP pos: %li x %li\n\x00"), eMP[ePos], mpos)
	// new sigma
	sigma = Eprev*depsilon + sigma_old
	noarch.Fprintf(msgout, []byte("[ ] SIGMA: %e = %e * _%e_ + %e\n\x00"), sigma, Eprev, depsilon, sigma_old)
	if depsilon*epsilon_old >= 0 && math.Abs(depsilon+epsilon_old) < math.Abs(depsilon) {
		// unloading test:
		// Ed == E0 here
		return Ed
	}
	if sets == 1 {
		// limit test:
		s_lim = femGetMPValPos(ePos, 12, 0)
		if math.Abs(sigma) > math.Abs(s_lim) {
			Ed = femGetMPValPos(ePos, 20, 0)
			return Ed
		}
	} else {
		for i = sets - 2; i >= 0; i-- {
			s_lim = femGetMPValPos(ePos, 12, i)
			if math.Abs(sigma) > math.Abs(s_lim) {
				Ed = femGetMPValPos(ePos, 20, i+1)
				return Ed
			}
		}
	}
	return Ed
}

// femD_3D_iso - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pl3d.c:32
func femD_3D_iso(ePos int32, Ex float64, nu float64, D []tMatrix) int32 {
	//
	//   File name: fem_pl3d.c
	//   Date:      2004/01/03 17:48
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM Solver - 3D elasticity and plastitity
	//
	//   $Id: fem_pl3d.c,v 1.6 2004/11/11 21:39:25 jirka Exp $
	//
	// Material stiffness matrix (linear isotropic mat.) for 3D
	var d1 float64
	var d2 float64
	var d3 float64
	d1 = Ex * (1 - nu) / ((1 + nu) * (1 - 2*nu))
	d2 = Ex * nu / ((1 + nu) * (1 - 2*nu))
	d3 = Ex / (2 * (1 + nu))
	femMatSetZero(D)
	femMatPutAdd(D, 1, 1, d1, 0)
	femMatPutAdd(D, 2, 2, d1, 0)
	femMatPutAdd(D, 3, 3, d1, 0)
	femMatPutAdd(D, 1, 2, d2, 0)
	femMatPutAdd(D, 1, 3, d2, 0)
	femMatPutAdd(D, 2, 1, d2, 0)
	femMatPutAdd(D, 3, 1, d2, 0)
	femMatPutAdd(D, 2, 3, d2, 0)
	femMatPutAdd(D, 3, 2, d2, 0)
	femMatPutAdd(D, 4, 4, d3, 0)
	femMatPutAdd(D, 5, 5, d3, 0)
	femMatPutAdd(D, 6, 6, d3, 0)
	return 0
}

// femD_3D_ortho - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pl3d.c:60
func femD_3D_ortho(ePos int32, e_rep int32, Mode int32, D []tMatrix) int32 {
	var Ex float64
	var Ey float64
	var Ez float64
	var Gxy float64
	var Gyz float64
	var Gzx float64
	var nuxy float64
	var nuyz float64
	var nuzx float64
	var mult float64
	var nuyx float64
	var nuzy float64
	var nuxz float64
	Ex = femGetMPValPos(ePos, 2, 0)
	Ey = femGetMPValPos(ePos, 3, 0)
	Ez = femGetMPValPos(ePos, 4, 0)
	nuxy = femGetMPValPos(ePos, 21, 0)
	nuyz = femGetMPValPos(ePos, 22, 0)
	nuzx = femGetMPValPos(ePos, 23, 0)
	Gxy = femGetMPValPos(ePos, 24, 0)
	Gyz = femGetMPValPos(ePos, 25, 0)
	Gzx = femGetMPValPos(ePos, 26, 0)
	nuyx = Ey / Ex * nuxy
	nuzy = Ez / Ey * nuyz
	nuxz = Ex / Ez * nuzx
	mult = (1 - nuxy*nuyx - nuyz*nuzy - nuzx*nuxz - nuxy*nuyz*nuzx) / (Ex * Ey * Ez)
	femMatPutAdd(D, 1, 1, (1-nuyz*nuzx)/(Ey*Ez*mult), 0)
	femMatPutAdd(D, 2, 2, (1-nuxz*nuzx)/(Ex*Ez*mult), 0)
	femMatPutAdd(D, 3, 3, (1-nuxy*nuyx)/(Ey*Ex*mult), 0)
	femMatPutAdd(D, 4, 4, 1*Gyz, 0)
	femMatPutAdd(D, 5, 5, 1*Gzx, 0)
	femMatPutAdd(D, 6, 6, 1*Gxy, 0)
	femMatPutAdd(D, 1, 2, (nuxy+nuzx*nuyz)/(Ey*Ez*mult), 0)
	femMatPutAdd(D, 2, 1, (nuxy+nuzx*nuyz)/(Ey*Ez*mult), 0)
	femMatPutAdd(D, 1, 3, (nuzx+nuyx*nuzy)/(Ey*Ez*mult), 0)
	femMatPutAdd(D, 3, 1, (nuzx+nuyx*nuzy)/(Ey*Ez*mult), 0)
	femMatPutAdd(D, 2, 3, (nuzy+nuzx*nuxy)/(Ez*Ex*mult), 0)
	femMatPutAdd(D, 3, 2, (nuzy+nuzx*nuxy)/(Ez*Ex*mult), 0)
	femMatPrn(D, []byte("Dortho\x00"))
	return 0
}

// femD_3D_transv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pl3d.c:104
func femD_3D_transv(ePos int32, e_rep int32, Mode int32, D []tMatrix) int32 {
	var Ep float64
	var Ez float64
	var G float64
	var nup float64
	var nupz float64
	var nuzp float64
	var mult float64
	Ep = femGetMPValPos(ePos, 2, 0)
	Ez = femGetMPValPos(ePos, 4, 0)
	nup = femGetMPValPos(ePos, 21, 0)
	nupz = femGetMPValPos(ePos, 22, 0)
	G = femGetMPValPos(ePos, 24, 0)
	nuzp = nupz * (Ez / Ep)
	mult = (1 - nup*nup - 2*nupz*nuzp - nup*nupz*nuzp) / (Ep * Ep * Ez)
	femMatPutAdd(D, 1, 1, (1-nupz*nuzp)/(Ep*Ez*mult), 0)
	femMatPutAdd(D, 2, 2, (1-nupz*nuzp)/(Ep*Ez*mult), 0)
	femMatPutAdd(D, 3, 3, (1-nup*nup)/(Ep*Ep*mult), 0)
	femMatPutAdd(D, 4, 4, 1*G, 0)
	femMatPutAdd(D, 5, 5, 1*G, 0)
	femMatPutAdd(D, 6, 6, 0.5*Ep/(1+nup), 0)
	femMatPutAdd(D, 1, 2, (nup+nuzp*nupz)/(Ep*Ez*mult), 0)
	femMatPutAdd(D, 2, 1, femMatGet(D, 1, 2), 0)
	femMatPutAdd(D, 1, 3, (nuzp+nup*nuzp)/(Ep*Ez*mult), 0)
	femMatPutAdd(D, 3, 1, femMatGet(D, 1, 3), 0)
	femMatPutAdd(D, 2, 3, (nuzp+nuzp*nup)/(Ep*Ez*mult), 0)
	femMatPutAdd(D, 3, 2, femMatGet(D, 2, 3), 0)
	femMatPrn(D, []byte("Dtrans\x00"))
	return 0
}

// fem_D_3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pl3d.c:154
func fem_D_3D(ePos int32, e_rep int32, eT int32, mT int32, sigma []tVector, epsilon []tVector, Mode int32, D []tMatrix) int32 {
	// Creates material stiffness matrix
	// * @param ePos element position
	// * @param e_rep index of (integration) point on element
	// * @param eT element type
	// * @param eT material type
	// * @param sigma stress vector (NULL for Mode == AF_NO)
	// * @param sigma strain vector (NULL for Mode == AF_NO)
	// * @param Mode as AF_YES==D(sigma, epsilon) .. as usual
	// * @param D matrix to be computed
	// *
	var rv int32
	var type_ int32
	type_ = Mat[femGetIntPos(mT, mpType, mpLen)].type_
	switch type_ {
	case 11:
		rv = femD_3D_transv(ePos, e_rep, Mode, D)
	case 7:
		rv = femD_3D_ortho(ePos, e_rep, Mode, D)
	case 4:
		if femGetMPValPos(ePos, 12, 0) <= 0 {
			rv = fem_dp_D_3D(ePos, e_rep, eT, mT, sigma, epsilon, Mode, D)
		} else {
			rv = fem_vmis_D_3D(ePos, e_rep, eT, mT, sigma, epsilon, Mode, D)
		}
	case 3:
		rv = fem_chen_D_3D(ePos, e_rep, eT, mT, sigma, epsilon, Mode, D)
	case 2:
		rv = fem_D_ccr3D(ePos, e_rep, eT, mT, sigma, epsilon, Mode, D)
	case 10:
		rv = od3d_D(ePos, e_rep, Mode, epsilon, D)
	case 5:
		fallthrough
	case 1:
		fallthrough
	default:
		// the same as default - isotropic behaviour
		// the same as default - isotropic behaviour
		rv = femD_3D_iso(ePos, femGetMPValPos(ePos, 2, 0), femGetMPValPos(ePos, 5, 0), D)
		break
	}
	return rv
}

// femSort3dMaxMin - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pr3d.c:30
func femSort3dMaxMin(s1 []float64, s2 []float64, s3 []float64) {
	//
	//   File name: fem_pr3d.c
	//   Date:      2004/03/27 10:08
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM Solver: computaion of principal stresses in 3D
	//
	var val float64
	var a []float64 = make([]float64, 3)
	var posmax int32
	var posmid int32
	var posmin int32
	var i int32
	if s1[0] == s2[0] && s2[0] == s3[0] {
		return
	}
	a[0] = s1[0]
	a[1] = s2[0]
	a[2] = s3[0]
	val = a[0]
	posmax = 0
	for i = 1; i < 3; i++ {
		if a[i] >= val {
			val = a[i]
			posmax = i
		}
	}
	val = a[0]
	posmin = 0
	for i = 1; i < 3; i++ {
		if a[i] <= val {
			val = a[i]
			posmin = i
		}
	}
	for i = 0; i < 3; i++ {
		if i != posmax && i != posmin {
			posmid = i
			break
		}
	}
	s1[0] = a[posmax]
	s2[0] = a[posmid]
	s3[0] = a[posmin]
}

// femPrinc3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pr3d.c:73
func femPrinc3D(sx []tVector, s1 []tVector) int32 {
	// Computes principal stresses
	// * @param sx {s_x,s_y,s_z,s_yz,s_zx,s_xy}
	// * @param s1 {s_1,s_2,s_3}
	// * @return status
	//
	// s^3 - a*s^2 - b*s - c = 0
	var a float64
	var b float64
	var c float64
	var s_x float64
	var s_y float64
	var s_z float64
	var s_xy float64
	var s_yz float64
	var s_zx float64
	var s_1 float64
	var s_2 float64
	var s_3 float64
	var Q float64
	var R float64
	var Q3 float64
	var R2 float64
	var sQ float64
	var a3 float64
	var ang float64
	femVecSetZero(s1)
	s_x = femVecGet(sx, 1)
	s_y = femVecGet(sx, 2)
	s_z = femVecGet(sx, 3)
	s_yz = femVecGet(sx, 4)
	s_zx = femVecGet(sx, 5)
	s_xy = femVecGet(sx, 6)
	femVecPrn(sx, []byte("SIGMA_X\x00"))
	if math.Abs(femVecNorm(sx)) <= 1e-17 {
		return 0
	}
	// cubic equation coefficicents
	a = -1 * (s_x + s_y + s_z)
	b = s_x*s_y + s_y*s_z + s_z*s_x - s_xy*s_xy - s_yz*s_yz - s_zx*s_zx
	c = -1 * (s_x*s_y*s_z + 2*s_xy*s_yz*s_zx - (s_zx*s_y*s_zx + s_xy*s_xy*s_z + s_x*s_yz*s_yz))
	// root finding by Francois Viete: De emendatione, 1615
	Q = (a*a - 3*b) / 9
	R = (2*a*a*a - 9*a*b + 27*c) / 54
	Q3 = Q * Q * Q
	R2 = R * R
	if R2 <= Q3 {
		ang = math.Acos(R / math.Sqrt(Q3))
		sQ = math.Sqrt(Q)
		a3 = a / 3
		s_1 = -2*sQ*math.Cos(ang/3) - a3
		s_2 = -2*sQ*math.Cos((ang+2*3.141592653589793)/3) - a3
		s_3 = -2*sQ*math.Cos((ang-2*3.141592653589793)/3) - a3
	} else {
		if R2 > Q3 {
			// If only one root is real - impossible here!!!!!
			s_1 = -1 * (math.Pow(math.Sqrt(R*R-Q3)+math.Abs(R), 1/3) + Q/math.Pow(math.Sqrt(R*R-Q3)+math.Abs(R), 1/3))
			if R >= 0 {
				// do nothing
				{
				}
			} else {
				s_1 *= -1
			}
			s_2 = s_1
			s_3 = s_1
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Impossible stresses found - principal stresses will be invalid\x00"))
		} else {
			noarch.Fprintf(msgout, []byte("[E] %s: Q3=%e, R2=%e!\n\x00"), []byte("Complex principal values found\x00"), Q3, R*R)
			femVecSetZero(s1)
			return -3
		}
	}
	// s_1 > s_2 > s_3
	femSort3dMaxMin(c4goUnsafeConvert_float64(&s_1), c4goUnsafeConvert_float64(&s_2), c4goUnsafeConvert_float64(&s_3))
	femVecPutAdd(s1, 1, s_1, 0)
	femVecPutAdd(s1, 2, s_2, 0)
	femVecPutAdd(s1, 3, s_3, 0)
	femVecPutAdd(s1, 4, 0, 0)
	femVecPutAdd(s1, 5, 0, 0)
	femVecPutAdd(s1, 6, 0, 0)
	femVecPrn(s1, []byte("SIGMA_1\x00"))
	return 0
}

// femPrinc3dTranM - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pr3d.c:169
func femPrinc3dTranM(sx []tVector, s1 []tVector, M []tMatrix) int32 {
	// Computes M for "M_sigma_princ = M^T*M_sigma_xyz*M"
	// * @param sx xyz stresses
	// * @param s1 principal stresses (must be available)
	// * @param M transformation matrix (result)
	// * @return status
	// *
	var A float64
	var B float64
	var C float64
	var Mj []float64 = make([]float64, 4)
	var s_x float64
	var s_y float64
	var s_z float64
	var s_xy float64
	var s_yz float64
	var s_zx float64
	var s float64
	var mult float64
	var ABC float64
	var i int32
	var j int32
	s_x = femVecGet(sx, 1)
	s_y = femVecGet(sx, 2)
	s_z = femVecGet(sx, 3)
	s_yz = femVecGet(sx, 4)
	s_zx = femVecGet(sx, 5)
	s_xy = femVecGet(sx, 6)
	for i = 1; i <= 3; i++ {
		for j = 0; j < 4; j++ {
			Mj[j] = 0
		}
		s = femVecGet(s1, i)
		A = (s_y-s)*(s_z-s) - s_yz*s_yz
		B = (s_z-s)*(s_x-s) - s_zx*s_zx
		C = (s_x-s)*(s_y-s) - s_xy*s_xy
		ABC = A + B + C
		if ABC == 0 {
			femMatSetZero(M)
			for j = 1; j <= 3; j++ {
				femMatPutAdd(M, j, j, 1, 0)
			}
			return 0
		}
		mult = 1 / ABC
		Mj[1] = mult * A
		Mj[2] = mult * B
		Mj[3] = mult * C
		{
			// ?
			for j = 1; j <= 3; j++ {
				femMatPutAdd(M, j, i, Mj[j], 0)
			}
		}
	}
	return 0
}

// fem_get_struct_price - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_pric.c:28
func fem_get_struct_price(volume_only int32) float64 {
	//
	//   File name: fem_pric.c
	//   Date:      2011/05/01 18:31
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2011 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	var price float64
	var vprice float64
	var evol float64
	var i int32
	var eT int32
	price = 0
	for i = 0; i < eLen; i++ {
		if volume_only == 1 {
			vprice = 1
		} else {
			vprice = femGetMPValPos(i, 36, 0)
		}
		if vprice <= 0 {
			vprice = 1
		}
		eT = femGetIntPos(i, eType, eLen)
		Elem[eT].volume(i, c4goUnsafeConvert_float64(&evol))
		price += vprice * evol
	}
	noarch.Fprintf(msgout, []byte("[ ] %s: %e\n\x00"), []byte("SYSTEM PRICE\x00"), price)
	return price
}

// ft_curve - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sb1d.c:38
func ft_curve(E0 float64, ft float64, Gf float64, eps float64, Le float64, sigma []float64) int32 {
	//
	//   File name: fem_sb1d.c
	//   Date:      2007/07/16 10:45
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2007 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   SBETA-like material constitutive model for 1D (for BEAM3)
	//
	// Exponential softwening curve for concrete (type=2)
	// * @param E0 initial E (youn modullus)
	// * @param ft current tensile strenth
	// * @param Gf fracture energy
	// * @param eps strain
	// * @param Le crack band width
	// * @param sigma current stress (pointer to result)
	//
	var epso float64
	var epsi float64
	var epsc float64
	var eps_f float64
	var i int32
	eps_f = Gf / ft / Le
	epso = ft / E0
	if eps < epso {
		sigma[0] = eps * E0
	} else {
		epsi = eps
		sigma[0] = ft * math.Exp(-1*(eps-epso)/eps_f)
		epsc = epsi - sigma[0]/E0
		for i = 1; i <= 20; i++ {
			sigma[0] = ft * math.Exp(-1*epsc/eps_f)
			epsi = epsc + sigma[0]/E0
			epsc = epsc - (epsi - eps)
		}
	}
	if sigma[0] < 0 {
		sigma[0] = 0
	}
	return 0
}

// sb1d_get_Rt_tension - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sb1d.c:76
func sb1d_get_Rt_tension(ePos int32, E0 float64, smax float64, Gf float64, L float64, epsilon float64) float64 {
	// Computes Rt for tension (no epsilon-check, no Kupfer, no nothing)
	// * @param mPos material type index
	// * @epsilon current total strain
	// * @return Rt
	//
	var sigma float64
	var type_ int32
	if epsilon <= 0 {
		// nothing to do with non-linearity
		return E0
	}
	if Gf <= 0 {
		return 0
	}
	if type_ <= 1 {
		// linear interpolation
		sigma = smax - smax*smax*L/(2*Gf/1)*(epsilon-smax/E0)
		if sigma <= 0 {
			sigma = 0
		}
	} else {
		// curvilinear interpolation
		ft_curve(E0, smax, Gf, epsilon, L, c4goUnsafeConvert_float64(&sigma))
	}
	if sigma/epsilon < 0 {
		return 0
	}
	if sigma/epsilon > E0 {
		return E0
	}
	return sigma / epsilon
}

// sb1d_get_check_epsilon - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sb1d.c:113
func sb1d_get_check_epsilon(epsilon float64, prev_epsilon float64, epsilon_el_tension float64, epsilon_el_compression float64) int32 {
	if epsilon > 0 {
		if epsilon <= epsilon_el_tension {
			// Tests the type of stress (tension, compression, unloading)
			// * @param epsilon current total strain
			// * @param prev_epsilon total strain froum previous step
			// * @param epsilon_el_tension limit epsilon for elastic tension
			// * @param epsilon_el_compression limit epsilon for elastic compression
			// * @return type of stress number (see fem_sbet.c for values)
			// *
			// tension
			// elastic behaviour
			return 1
		} else {
			if epsilon < prev_epsilon {
				// unloading - use previous E
				// TODO - move this to inelastic section !!! TODO
				return 2
				return -1
			} else {
				// inelastic behaviour
				return 2
			}
		}
	} else {
		if math.Abs(epsilon) <= math.Abs(epsilon_el_compression) {
			// epsilon < 0.0
			// compression
			// elastic behaviour
			return 3
		} else {
			if epsilon > prev_epsilon {
				// values are negative!
				// unloading - use previous E
				return 3
				return -3
			} else {
				// inelastic behaviour
				return 3
				return 4
			}
		}
	}
	return 0
}

// sbet_rotcr_get_D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sber.c:176
func sbet_rotcr_get_D(ePos int32, iPoint int32, A float64, epsilon []tVector, sigma []tVector, sigma_r []tVector, Mode int32, Problem int32, D []tMatrix) int32 {
	//
	//   File name: fem_sber.c
	//   Date:      Thu Oct 22 20:00:46 CEST 2009
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2005 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   An analog to the "SBETA" material model (Cervenka et al)
	//   Rotating crack model - divided from fem_sbet.c
	//
	// #define DEVEL_SBET
	// Status numbers:
	// *  1: elastic tension
	// *  2: softening in tension (cracking)
	// *  3: elastic compression
	// *  4: softening in compression (crushing)
	// *  5: completely damaged (after cracking+crushing)
	// * -1: unloading in tension
	// * -3: unloading in compression
	//
	// What IS NOT included:
	// * - reinforcement
	// * - concrete-reinforcement interaction
	// * - E1-E2 interaction
	// * - cyclic loading
	// * ...
	//
	// compute fc and ft according to Kupfer
	// * @param s1 sigma 1 stress
	// * @param s2 sigma 2 stress
	// * @param f_ccyl cyllindric compression strenght (>0 ?)
	// * @param f_tu uniaxial tension strenght (>0)
	// * @param ttype tension-tension curve type [0,1,2]
	// * @param fc pointer to compression limit
	// * @param fc pointer to tension limit
	// *
	//TODO Computes E in compression (untested)
	// * @param epsilon epsilon size in given direction
	// * @param E0 initial Young modulus size
	// * @param Ec Young modulus in compression (TODO: check this!)
	// * @param fc compression strenght
	// * @param L  lenght of cracking zone
	// * @return modulus of cracking concrete
	//
	//TODO Computes E in compression (untested)
	// * @param epsilon epsilon size in given direction
	// * @param E0 initial Young modulus size
	// * @param Ec Young modulus in compression (TODO: check this!)
	// * @param fc compression strenght
	// * @return modulus of cracking concrete
	//
	// TODO Compute shear reduction coefficient
	//
	// Material stiffness matrix according to Hook (plane stress)
	// * @param E Young modullus
	// * @param nu Poisson ratio
	// * @param D matrix (result)
	//
	// Computes Cervenka's skew factor (works ONLY for element 002!)
	// * @param angle crack direction
	// * @param ePos  element position
	// * @return skew factor size
	//
	// TODO Computes D matrix for ROTATING CRACKS MODEL TODO
	// * @param ePos element index
	// * @param iPoint integration point index
	// * @param A element area
	// * @param epsilon strain vector
	// * @param sigma total stress vector (result, if newM=AF_YES)
	// * @param sigma_r residual stress vector (result, if newM=AF_YES)
	// * @param newM - if AF_YES the make new matrix, else make old
	// * @param Problem problem type (ignored - plane stress assumed)
	// * @param D pointer to (allocated!!!) D matrix (result)
	//
	var rv int32
	return rv
}

// sbet_zero - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:64
//
//   File name: fem_sbet.c
//   Date:      2005/12/20 19:58
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2005 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//   An analog to the "SBETA" material model (Cervenka et al)
//
// #define DEVEL_SBET
var sbet_zero float64 = 1e-17

// comp_2d_limits - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:95
func comp_2d_limits(s1 float64, s2 float64, f_ccyl float64, f_tu float64, ttype int32, fc []float64, ft []float64) int32 {
	// Status numbers:
	// *  1: elastic tension
	// *  2: softening in tension (cracking)
	// *  3: elastic compression
	// *  4: softening in compression (crushing)
	// *  5: completely damaged (after cracking+crushing)
	// * -1: unloading in tension
	// * -3: unloading in compression
	//
	// What IS NOT included:
	// * - reinforcement
	// * - concrete-reinforcement interaction
	// * - E1-E2 interaction
	// * - cyclic loading
	// * ...
	//
	// compute fc and ft according to Kupfer
	// * @param s1 sigma 1 stress
	// * @param s2 sigma 2 stress
	// * @param f_ccyl cyllindric compression strenght (>0 ?)
	// * @param f_tu uniaxial tension strenght (>0)
	// * @param ttype tension-tension curve type [0,1,2]
	// * @param fc pointer to compression limit
	// * @param fc pointer to tension limit
	// *
	var r float64
	var A float64
	var B float64
	var x float64
	var K float64
	fc[0] = f_ccyl
	ft[0] = f_tu
	if s1 < 0 && s2 < 0 {
		// compression-compression
		A = s1 / s2
		fc[0] = (1 + 3.65*A) / math.Pow(1+A, 2) * f_ccyl
	} else {
		if s1*s2 <= 0 {
			// compression-tension (compression strenght)
			// (compression strenght)
			r = 1 - 5.3278*math.Abs(s1/f_ccyl)
			if r > 1 {
				r = 1
			}
			if r < 0.9 {
				r = 0.9
			}
			fc[0] = f_ccyl * r
			r = 0
			switch ttype {
			case 1:
				// (tension strenght)
				x = math.Abs(s2 / f_ccyl)
				A = 0.75
				K = 1.125
				B = K*x + A
				r = (A + (A-1)*B) / (A * B)
			case 2:
				x = math.Abs(s2 / f_ccyl)
				A = 1.0635
				K = 6.0208
				B = K*x + A
				r = (A + (A-1)*B) / (A * B)
			case 0:
				fallthrough
			default:
				r = 1 - 0.8*math.Abs(s2/f_ccyl)
				break
			}
			ft[0] = f_tu * r
		} else {
			// default sizes (tension-tension zone)
			fc[0] = f_ccyl
			ft[0] = f_tu
		}
	}
	fc[0] = math.Abs(fc[0])
	ft[0] = math.Abs(ft[0])
	return 0
}

// sbet_compr_E - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:183
func sbet_compr_E(epsilon float64, E0 float64, Ec float64, fc float64, L float64, stat int32) float64 {
	//TODO Computes E in compression (untested)
	// * @param epsilon epsilon size in given direction
	// * @param E0 initial Young modulus size
	// * @param Ec Young modulus in compression (TODO: check this!)
	// * @param fc compression strenght
	// * @param L  lenght of cracking zone
	// * @return modulus of cracking concrete
	//
	var e_c float64
	var sig_ef float64
	var sigma float64
	var x float64
	var k float64
	// max. compr. strain
	var e_d float64
	var Ez float64
	// plastic strain for concrete ... van Mier
	var w_d float64 = 0.5
	if epsilon > 0 {
		noarch.Fprintf(msgout, []byte("[w] %s: %e, %li!\n\x00"), []byte("Compression E used in tension zone\x00"), epsilon, stat)
		return E0
	}
	e_c = math.Abs(fc / Ec)
	if math.Abs(epsilon) <= e_c {
		// epsilon on peak
		// elastic zone - CEB-FIP Model Code 90
		// normalized strain
		x = epsilon / e_c
		k = E0 / Ec
		sig_ef = fc * ((k*x - x*x) / (1 + (k-2)*x))
		noarch.Printf([]byte("SIGMA PRE %e, x = %e, k = %e (%e/%e)\n\x00"), math.Abs(sig_ef/epsilon), x, k, epsilon, e_c)
		return math.Abs(sig_ef / epsilon)
	} else {
		// plastic (post-peak) zone
		e_d = e_c / w_d
		if epsilon < 0 && math.Abs(epsilon) > math.Abs(e_d) {
			return 0
		}
		Ez = math.Abs(fc / (e_d - e_c))
		// sigma = -1.0*epsilon*Ez - fc*(1.0 - Ez/Ec);
		sigma = -fc + Ez*(math.Abs(epsilon)-math.Abs(fc/Ec))
		if sigma > 0 {
			sigma = 0
		}
		noarch.Printf([]byte("SIGMA POST %e (Ez = %e)%e(%e..%e..%e)\n\x00"), math.Abs(sigma/epsilon), Ez, epsilon, e_c, w_d, e_d)
		return math.Abs(sigma / epsilon)
	}
	// impossible to reach this:
	return E0
}

// sbet_compr_plast_E - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:257
func sbet_compr_plast_E(epsilon float64, E0 float64, Ec float64, fc float64, stat int32) float64 {
	//TODO Computes E in compression (untested)
	// * @param epsilon epsilon size in given direction
	// * @param E0 initial Young modulus size
	// * @param Ec Young modulus in compression (TODO: check this!)
	// * @param fc compression strenght
	// * @return modulus of cracking concrete
	//
	var e_c float64
	if epsilon >= 0 {
		noarch.Fprintf(msgout, []byte("[w] %s: %e, %li!\n\x00"), []byte("Compression E used in tension zone\x00"), epsilon, stat)
		return E0
	}
	e_c = math.Abs(fc / Ec)
	if math.Abs(epsilon) <= e_c {
		// epsilon on peak
		return math.Abs(E0)
	} else {
		return math.Abs(fc / epsilon)
	}
	// impossible to reach this:
	return E0
}

// sbeg_Gbeta - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:293
func sbeg_Gbeta(type_ int32, p float64, eps float64, eps_max float64, Ecr float64, E0 float64) float64 {
	// TODO Compute shear reduction coefficient
	//
	var val float64
	switch type_ {
	case 0:
		return 1
	case 2:
		if math.Abs(eps/eps_max) > 1 {
			// Damjanic + Owen
			return 0
		}
		return 1 - math.Abs(eps/eps_max)
	case 3:
		// Cervenka + Brdecko
		return 1 - math.Pow(eps/0.005, 0.3)
	case 4:
		// Cervenka + Mang
		return 1 - math.Pow(eps/0.005, 0.2)
	case 5:
		// Glemberg + Samuelsson
		val = Ecr / E0
		if val <= 0 {
			val = 2 * 1e-17
		}
		if val >= 1 {
			val = 1
		}
		return val
	case 6:
		return 0.001
	case 1:
		fallthrough
	case 7:
		if eps <= 0 {
			// Kolmar
			return 1
		}
		val = -1 * math.Log(1000*eps/(7+333*0.005)) / (10 - 167*0.005)
		if val > 1 {
			val = 1
		}
		if val < 0 {
			val = 0
		}
		return val
	default:
		return 1
		break
	}
	return 1
}

// sbet_HookD - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:347
func sbet_HookD(E float64, nu float64, D []tMatrix) {
	// Material stiffness matrix according to Hook (plane stress)
	// * @param E Young modullus
	// * @param nu Poisson ratio
	// * @param D matrix (result)
	//
	var Mul float64
	Mul = E / (1 - nu*nu)
	femMatPutAdd(D, 1, 1, Mul, 0)
	femMatPutAdd(D, 1, 2, Mul*nu, 0)
	femMatPutAdd(D, 2, 1, Mul*nu, 0)
	femMatPutAdd(D, 2, 2, Mul, 0)
	femMatPutAdd(D, 3, 3, Mul*0.5*(1-nu), 0)
}

// sbet_skew_factor_2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:365
func sbet_skew_factor_2D(angle float64, ePos int32) int32 {
	// Computes Cervenka's skew factor (works ONLY for element 002!)
	// * @param angle crack direction
	// * @param ePos  element position
	// * @return skew factor size
	//
	var skew_fact float64 = 1
	var skew_angle float64
	var max_fact float64 = 1.5
	var x1 float64
	var x2 float64
	var y1 float64
	var y2 float64
	var ang []float64 = make([]float64, 4)
	var ang1 float64
	var ang2 float64
	var ang0 float64
	var i int32
	var i1 int32
	for i = 0; i < 4; i++ {
		i1 = i + 1
		if i1 == 4 {
			i1 = 0
		}
		x1 = femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_x, nLen)
		x2 = femGetDblPos(femGetIntLPos(ePos, i1, eFrom, eNodesL, eLenL), n_x, nLen)
		y1 = femGetDblPos(femGetIntLPos(ePos, i, eFrom, eNodesL, eLenL), n_y, nLen)
		y2 = femGetDblPos(femGetIntLPos(ePos, i1, eFrom, eNodesL, eLenL), n_y, nLen)
		if math.Abs(x2-x1) <= 1e-17 {
			ang[i] = 90
		} else {
			ang[i] = math.Abs((y2 - y1) / (x2 - x1))
		}
	}
	ang1 = 0.5 * (ang[0] + ang[2])
	ang2 = 0.5 * (ang[1] + ang[3])
	if ang2 < ang1 {
		ang0 = ang2
	} else {
		ang0 = ang1
	}
	skew_angle = math.Abs(angle - ang0)
	if skew_angle > 45 {
		skew_angle = 90 - skew_angle
	}
	skew_fact = 1 + (max_fact-1)*(skew_angle/45)
	if skew_fact < 1 {
		skew_fact = 1
	}
	if skew_fact > max_fact {
		skew_fact = max_fact
	}
	return int32(skew_fact)
}

// sbet_get_D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sbet.c:424
func sbet_get_D(ePos int32, iPoint int32, A float64, epsilon []tVector, sigma []tVector, sigma_r []tVector, Mode int32, Problem int32, D []tMatrix) int32 {
	// Computes D matrix
	// * @param ePos element index
	// * @param iPoint integration point index
	// * @param A element area
	// * @param epsilon strain vector
	// * @param sigma total stress vector (result, if newM=AF_YES)
	// * @param sigma_r residual stress vector (result, if newM=AF_YES)
	// * @param newM - if AF_YES the make new matrix, else make old
	// * @param Problem problem type (ignored - plane stress assumed)
	// * @param D pointer to (allocated!!!) D matrix (result)
	//
	var rv int32
	var prev_stat1 int32
	var stat1 int32
	var prev_stat2 int32
	var stat2 int32
	var E0 float64
	var E1 float64
	var E2 float64
	var beta float64
	var angle float64
	var epsilon01 float64
	var epsilon02 float64
	var nu float64
	var G float64
	var Gf float64
	var f_ccyl float64
	var f_tu float64
	var fc float64
	var ft float64
	var L float64
	var E1_old float64
	var E2_old float64
	var beta_old float64
	var equi_e1 float64
	var equi_e2 float64
	var equi_eps float64
	var equi_eps2 float64
	var i int32
	var ii int32
	var beta_type int32 = 1
	var kupf_type int32 = 1
	var crck_type int32
	var tot_epsilon tVector
	var tot_epsilon_1 tVector
	var sigma_x tVector
	var sigma_1 tVector
	var Ts tMatrix
	//
	//   * E1=Rt   ... RES_ECR1 (main direction stiffness) .. 28
	//   * E2      ... RES_ECR2 (stiffness in other direction) .. 29
	//   * status1 ... RES_STAT1 (material status 1st dir) .. 63
	//   * status2 ... RES_STAT2 (material status 2nd dir) .. 64
	//   * beta    ... RES_GCR1 (shear reduction coefficient) .. 31
	//   * angle   ... RES_DIR1 (angle of cracks [rad]) .. 25
	//   * epsilon1... RES_DIR2 (epsilon in direction of cracks) .. 26
	//   * epsilon2... RES_DIR3 (epsilon in other direction) .. 27
	//   * fc      ... RES_SCMAX (2D limit compression stress from Kupfer) .. 62
	//   * ft      ... RES_STMAX (2D limit tension stress from Kupfer) .. 61
	//
	//
	femMatSetZero(D)
	prev_stat1 = int32(femGetRepVal(ePos, 63, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	stat1 = prev_stat1
	prev_stat2 = int32(femGetRepVal(ePos, 64, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	stat2 = prev_stat2
	E0 = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	G = E0 / (2 * (1 + nu))
	beta_type = int32(femGetMPValPos(ePos, 32, 0))
	kupf_type = int32(femGetMPValPos(ePos, 33, 0))
	if kupf_type < 0 {
		kupf_type = 0
	}
	E1 = femGetRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	E2 = femGetRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	beta = femGetRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	angle = femGetRepVal(ePos, 25, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	epsilon01 = femGetRepVal(ePos, 26, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	epsilon02 = femGetRepVal(ePos, 27, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	// TODO: check this!
	L = math.Sqrt(A)
	beta_type = 7
	if beta < 1e-17 {
		// (!)
		beta = 1e-17
	}
	if beta > 1 {
		beta = 1
	}
	if prev_stat1 == prev_stat2 && (prev_stat1 == 1 || prev_stat1 == 0) {
		// initial linear behaviour
		E1 = E0
		E2 = E0
		beta = 1
		angle = 0
	}
	if E1 < 0.001*E0 {
		// convergence stuff:
		E1 = 0.001 * E0
	}
	if E2 < 0.001*E0 {
		E2 = 0.001 * E0
	}
	if beta < 0.001 {
		beta = 0.001
	}
	// Compute old matrix
	D_Plane_OrthoCB(E1, E2, nu, G, beta, angle, D)
	if Mode == 1 {
		// new matrix
		E1 = femGetRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		E2 = femGetRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		beta = femGetRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
		if (prev_stat2 == 0 || prev_stat2 == 1) && (prev_stat1 == 1 || prev_stat1 == 0) {
			// initial linear behaviour -  repeating
			E1 = E0
			E2 = E0
			beta = 1
		}
		E1_old = E1
		E2_old = E2
		beta_old = beta
		femVecSetZero(sigma_r)
		femVecSetZero(sigma)
		// pre-iterational stresses
		femMatVecMult(D, epsilon, sigma_r)
		femVecPutAdd(sigma_r, 1, femGetRepVal(ePos, 7, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		femVecPutAdd(sigma_r, 2, femGetRepVal(ePos, 8, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		femVecPutAdd(sigma_r, 3, femGetRepVal(ePos, 10, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		{
			// begin of ii loop:
			for ii = 0; ii < 3; ii++ {
				if ii > 0 {
					E1 = femGetRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
					E2 = femGetRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
					beta = femGetRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
				}
				f_ccyl = femGetMPValPos(ePos, 8, 0)
				f_tu = femGetMPValPos(ePos, 7, 0)
				Gf = femGetMPValPos(ePos, 9, 0)
				// data preparation
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
				femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:])
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], 0, 3, 3)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 0, 3, 3)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], 0, 3, 3)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 0, 3, 3)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], 0, 3, 3, 0, nil)
					return rv
				}()) != 0 {
					goto memFree
				}
				// total strain and stress computation:
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], 1, femGetRepVal(ePos, 13, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], 2, femGetRepVal(ePos, 14, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], 3, femGetRepVal(ePos, 16, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
				for i = 1; i <= 3; i++ {
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], i, femVecGet(epsilon, i), 1)
				}
				if (prev_stat1 == 1 || prev_stat1 == 0 || prev_stat1 == 3) && (prev_stat2 == 1 || prev_stat2 == 0 || prev_stat2 == 3) {
					// computing of the state of initially undamaged material
					femMatVecMult(D, (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
					// also NEW angle
					femGetPrincStress2D((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], c4goUnsafeConvert_float64(&angle))
					// Kupfer
					comp_2d_limits(femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1), femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2), f_ccyl, f_tu, kupf_type, c4goUnsafeConvert_float64(&fc), c4goUnsafeConvert_float64(&ft))
					if ft < femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) {
						// can be 0,1,2
						// checking stat change:
						stat1 = 2
					}
					if ft < femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) {
						stat2 = 2
					}
					if -1*math.Abs(fc) > femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) && femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) < 0 {
						stat1 = 4
					}
					if -1*math.Abs(fc) > femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) && femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) < 0 {
						stat2 = 4
					}
					femTe_2d((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], angle)
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:])
					equi_e1 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 1)
					equi_e2 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 2)
					if E2 > 0 && E1 > 0 {
						equi_e1 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) / (E1 / (1 - nu*nu*(E1/E2)))
						equi_e2 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) / (E2 / (1 - nu*nu*(E1/E2)))
					}
					femAddPutRepVal(ePos, 62, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, fc)
					femAddPutRepVal(ePos, 61, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, ft)
				} else {
					fc = femGetRepVal(ePos, 62, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
					ft = femGetRepVal(ePos, 61, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
					// previously damaged material
					femTe_2d((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], angle)
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:])
					// sigma in previous direction:
					femTs_2d((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], angle)
					femMatVecMult(D, (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
					femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
					if ft < femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) {
						// additional tests:
						stat1 = 2
					}
					if ft < femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) {
						stat2 = 2
					}
					if -1*math.Abs(fc) > femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) && femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) < 0 {
						stat1 = 4
					}
					if -1*math.Abs(fc) > femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) && femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) < 0 {
						stat2 = 4
					}
					// compute equivalent strain here
					equi_e1 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 1)
					equi_e2 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 2)
					if E2 > 0 && E1 > 0 {
						equi_e1 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) / (E1 / (1 - nu*nu*(E1/E2)))
						equi_e2 = femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) / (E2 / (1 - nu*nu*(E1/E2)))
					}
					if prev_stat1 == 2 || prev_stat1 == -1 {
						if epsilon01 > equi_e1 {
							// check for unloading
							stat1 = -1
						} else {
							stat1 = 2
						}
					}
					if prev_stat1 == 4 || prev_stat1 == -3 {
						if epsilon01 < equi_e1 {
							stat1 = -3
						} else {
							stat1 = 4
						}
						if equi_e1 > 0 {
							stat1 = 5
						}
					}
					if prev_stat2 == 2 || prev_stat2 == -1 {
						if epsilon02 > equi_e2 {
							stat2 = -1
						} else {
							stat2 = 2
						}
					}
					if prev_stat2 == 4 || prev_stat2 == -3 {
						if epsilon02 < equi_e2 {
							stat2 = -3
						} else {
							stat2 = 4
						}
						if equi_e2 > 0 {
							stat2 = 5
						}
					}
					if prev_stat1 == 1 || prev_stat1 == 0 || prev_stat1 == 3 {
						if ft < femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) {
							// check of damage in undamaged direction
							stat1 = 2
						}
						if -1*math.Abs(fc) > femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) && femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 1) < 0 {
							stat1 = 4
						}
					}
					if prev_stat2 == 1 || prev_stat2 == 0 || prev_stat2 == 3 {
						if ft < femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) {
							stat2 = 2
						}
						if -1*math.Abs(fc) > femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) && femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:], 2) < 0 {
							stat2 = 4
						}
					}
				}
				if stat1 == 2 || stat1 == -1 || stat2 == 2 || stat2 == -1 {
					L = math.Sqrt(A) * float64(sbet_skew_factor_2D(angle, ePos))
				}
				switch stat1 {
				case 2:
					// computation of E1
					E1 = sb1d_get_Rt_tension(ePos, E0, ft, Gf, L, equi_e1)
				case 4:
					E1 = sbet_compr_E(equi_e1, E0, E0, fc, L, stat1)
				case 5:
					E1 = 0
					beta = 0
				case -1:
					// previous values are correct here
				case -3:
					// previous values are correct here -- TODO: check this!
				case 3:
					fallthrough
				case 1:
					fallthrough
				case 0:
					fallthrough
				default:
					// 3 might have to be changed later!
					E1 = E0
					break
				}
				switch stat2 {
				case 2:
					// computation of E2
					E2 = sb1d_get_Rt_tension(ePos, E0, ft, Gf, L, equi_e2)
				case 4:
					E2 = sbet_compr_E(equi_e2, E0, E0, fc, L, stat2)
				case 5:
					E2 = 0
					beta = 0
				case -1:
					// previous values are correct here
				case -3:
					// previous values are correct here -- TODO: check this!
				case 3:
					fallthrough
				case 1:
					fallthrough
				case 0:
					fallthrough
				default:
					// 3 might have to be changed later!
					E2 = E0
					break
				}
				if stat1 == 2 || stat1 == -1 || stat2 == 2 || stat2 == -1 {
					if stat1 == 2 || stat1 == -1 {
						// computation of beta
						equi_eps = equi_e1
						beta = sbeg_Gbeta(beta_type, 0.02, equi_eps, 0.005, E1, E0)
						if math.Abs(beta*G*equi_eps) > ft {
							beta = ft / (G * equi_eps)
						}
					}
					if stat2 == 2 || stat2 == -1 {
						equi_eps2 = equi_e2
						if stat1 == 2 || stat1 == -1 {
							if equi_eps2 < equi_eps {
								equi_eps = -1e+06
							} else {
								equi_eps = equi_eps2
							}
						} else {
							equi_eps = equi_eps2
						}
						if equi_eps > 0 {
							beta = sbeg_Gbeta(beta_type, 0.02, equi_eps, 0.005, E2, E0)
							if math.Abs(beta*G*equi_eps) > ft {
								beta = ft / (G * equi_eps)
							}
						}
					}
					if beta > 1 {
						beta = 1
					}
					if beta < 0 {
						beta = 0
					}
				} else {
					// on other cases the beta remains unchanged
					beta = 1
				}
				if E1_old > 0 {
					if E1 > E1_old {
						// E quality control (it cannot be better, only worse):
						E1 = E1_old
					}
				}
				if E2_old > 0 {
					if E2 > E2_old {
						E2 = E2_old
					}
				}
				if beta_old >= 0 {
					if beta > beta_old {
						beta = beta_old
					}
				}
				femMatSetZero(D)
				// new D matrix
				D_Plane_OrthoCB(E1, E2, nu, G, beta, angle, D)
				// correct actual stress:
				femMatVecMult(D, (*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:], sigma)
				// material status data
				femAddPutRepVal(ePos, 63, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(stat1))
				femAddPutRepVal(ePos, 64, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(stat2))
				femAddPutRepVal(ePos, 28, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, E1)
				femAddPutRepVal(ePos, 29, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, E2)
				femAddPutRepVal(ePos, 31, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, beta)
				femAddPutRepVal(ePos, 25, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, angle)
				femAddPutRepVal(ePos, 26, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 1))
				femAddPutRepVal(ePos, 27, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:], 2))
			}
		}
		{
			// end of ii loop
			// unballanced (residual) stresses
			for i = 1; i <= 3; i++ {
				femVecPutAdd(sigma_r, i, femVecGet(sigma_r, i)-femVecGet(sigma, i), 0)
			}
		}
		femAddPutRepVal(ePos, 65, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet(sigma_r, 1))
		femAddPutRepVal(ePos, 66, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet(sigma_r, 2))
		femAddPutRepVal(ePos, 68, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet(sigma_r, 3))
		femVecPutAdd(sigma, 1, -1*femGetRepVal(ePos, 7, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		femVecPutAdd(sigma, 2, -1*femGetRepVal(ePos, 8, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
		femVecPutAdd(sigma, 3, -1*femGetRepVal(ePos, 10, iPoint+1, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 1)
	memFree:
		;
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&tot_epsilon_1))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_x))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma_1))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Ts))[:])
	}
	return rv
}

// fem_e005_soil - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_soil.c:38
func fem_e005_soil(ePos int32, jac []tMatrix, coord []tMatrix, xyz []tMatrix, Me []tMatrix) int32 {
	//
	//   File name: fem_soil.c
	//   Date:      2011/12/12 17:54
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2011 Jiri Brozovsky
	//
	//   This library is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU Library General Public
	//   License as published by the Free Software Foundation; either
	//   version 2 of the License, or (at your option) any later version.
	//
	//   This library is distributed in the hope that it will be useful,
	//   but WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   Library General Public License for more details.
	//
	//   You should have received a copy of the GNU Library General Public
	//   License along with this library; if not, write to the Free Software
	//   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
	//   USA.
	//
	//   More advanced model for e005 foundation
	//
	// TODO: some code here: different number of integration points
	// * than for the stiffness matrix
	// *
	var rv int32
	var i int32
	var j int32
	var ii int32
	var jj int32
	var ipos int32
	// number of integration points
	var ipoints int32 = 2
	var x float64
	var y float64
	var detj float64
	var weight_x float64
	var weight_y float64
	var mult float64
	var C1 float64
	var C2x float64
	var C2y float64
	var gauss tMatrix
	var H tMatrix
	var HT tMatrix
	var C tMatrix
	var HTC tMatrix
	var M_i tMatrix
	// cleaning of matrices:
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&HTC))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], 0, ipoints, 2, 0, nil)
		return rv
	}()) != 0 {
		// initialization of matrices:
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], 0, 3, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], 0, 12, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&HTC))[:], 0, 12, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], 0, 12, 12, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = e005_init_gauss(ipoints, (*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	ipos = -1
	for i = 1; i <= ipoints; i++ {
		for j = 1; j <= ipoints; j++ {
			ipos++
			// int. point coordinates:
			x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 1)
			y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 1)
			weight_x = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], i, 2)
			weight_y = femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:], j, 2)
			// jacobi matrix:
			//?
			e005_fill_J(jac, coord, x, y, xyz)
			if (func() int32 {
				rv = e005_jac_det(jac, c4goUnsafeConvert_float64(&detj))
				return rv
			}()) != 0 {
				// determinant
				//?
				goto memFree
			}
			if (func() int32 {
				rv = e005_fill_N((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], coord, x, y)
				return rv
			}()) != 0 {
				//?
				goto memFree
			}
			femMatTran((*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
			// "C" matrix:
			C1 = femGetRSValPos(ePos, 13, 0)
			C2x = 0
			C2y = 0
			femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], 1, 1, C1, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], 2, 2, C2x, 0)
			femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], 3, 3, C2y, 0)
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&C))[:], (*[1000000]tMatrix)(unsafe.Pointer(&HTC))[:])
			femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&HTC))[:], (*[1000000]tMatrix)(unsafe.Pointer(&H))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
			mult = detj * weight_x * weight_y
			{
				//  add "mult*M_i" to M_e:
				for ii = 1; ii <= 12; ii++ {
					for jj = 1; jj <= 12; jj++ {
						femMatPutAdd(Me, ii, jj, mult*femMatGet((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:], ii, jj), 1)
					}
				}
			}
		}
	}
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&H))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&HTC))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_i))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&gauss))[:])
	return rv
}

// femFastBC - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:33
//
//   File name: fem_sol.c
//   Date:      2003/04/09 14:00
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more etails.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - solver
//
// "fast" work with boundary conditions
var femFastBC int32

// femTangentMatrix - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:35
var femTangentMatrix int32 = 1

// fem2ndOrder - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:36
var fem2ndOrder int32

// fem2ndOrderIter - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:37
var fem2ndOrderIter int32

// femRunSolIterBC - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:38
var femRunSolIterBC int32

// femTestIterBC - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:39
var femTestIterBC int32

// femIterBCchange - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:40
var femIterBCchange int32

// femIterEchange - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:41
var femIterEchange int32

// femHaveThermDOFs - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:43
var femHaveThermDOFs int32

// femHaveThermLoad - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:44
var femHaveThermLoad int32

// nDOFAct - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:46
// total number of ACTIVE DOFs in structure (== size of "K" matrix)
var nDOFAct int32

// nDOFlen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:47
// lenght of nDOFfld
var nDOFlen int32

// nDOFfld - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:48
// description of DOFs in nodes
var nDOFfld []int32

// nDOFnon - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:49
// description of ommited DOFs in nodes
var nDOFnon []int32

// K_rows - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:50
// numbers of items in "K" rows K_rows[nDOFAct]
var K_rows []int32

// K_rowsAL - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:51
// K_rows for full ALM
var K_rowsAL []int32

// K - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:53
// structure stiffness matrix
var K tMatrix

// F - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:54
// structure load vector
var F tVector

// Fr - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:55
// unballanced forces vector
var Fr tVector

// u - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:56
// structure displacement vector
var u tVector

// u_tot - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:57
// structure displacement vector - total displacements (NRM)
var u_tot tVector

// u_i - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:59
// status field for BC iterations
var u_i tVector

// du0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:61
// substep displacement vector for ALM
var du0 tVector

// dut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:62
// substep unballanced displacement vector for ALM
var dut tVector

// dur - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:63
// substep unballanced displacement vector for ALM
var dur tVector

// du - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:64
// substep unballanced displacement vector for ALM
var du tVector

// F_0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:66
// backup load vector for ALM and full ALM; also for NRM
var F_0 tVector

// dFr - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:68
// step sum of unballanced forces for full ALM
var dFr tVector

// FF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:69
// whole load vector full ALM
var FF tVector

// KF - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:71
// structure and step matrix for full ALM
var KF tMatrix

// uLa - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:72
// displacement and lambda vectro for full ALM
var uLa tVector

// Fra - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:73
// load and arc lenght vector for full ALM
var Fra tVector

// uTemp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:75
// thermal loads field
var uTemp tVector

// M - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:79
// dynamics - general :
// structure mass matrix
var M tMatrix

// eig_omega - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:82
// dynamics - eigenproblems :
// vector of eigenvalues
var eig_omega tVector

// eig_x - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:83
// i-th iteration vector of eigenvalues
var eig_x tVector

// eig_xM - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:84
// i-th iteration vector of eigenvalues
var eig_xM tVector

// eig_shap - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:85
// matrix of eigenvectors
var eig_shap tMatrix

// eig_y - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:86
// FIELD of Gram-Schmidt data
var eig_y []tVector

// C - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:89
// dynamics - newmark:
// damping matrix
var C tMatrix

// KK - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:90
// combined stiffness matrix combined stiffness matrix
var KK tMatrix

// pp - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:91
// combined load vector
var pp tVector

// dr - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:92
// displacement change
var dr tVector

// ra - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:93
// temporary vector
var ra tVector

// rb - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:94
// temporary vector
var rb tVector

// r0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:95
// previous displacement
var r0 tVector

// rr0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:96
// previous velocity
var rr0 tVector

// rrr0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:97
// previous acceleration
var rrr0 tVector

// rr1 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:98
// current velocity
var rr1 tVector

// rrr1 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:99
// current acceleration
var rrr1 tVector

// F_0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:100
// initial load vector
var F_0 tVector

// femCompPE - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:171
func femCompPE(K []tMatrix, u []tVector, Print int32) float64 {
	// Computes total potential energy of the structure
	var Pi float64
	var size int32
	var Ku tVector
	size = K[0].rows
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&Ku))[:])
	if femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&Ku))[:], 0, size, size) != 0 {
		goto memFree
	}
	femMatVecMultBig(K, u, (*[1000000]tVector)(unsafe.Pointer(&Ku))[:])
	Pi = femVecVecMultBig((*[1000000]tVector)(unsafe.Pointer(&Ku))[:], u)
	if Print == 1 {
		noarch.Fprintf(msgout, []byte("[ ] %s: %e\n\x00"), []byte("Potential energy\x00"), Pi)
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&Ku))[:])
	return Pi
}

// fem_gravity_centre - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:192
func fem_gravity_centre(x []float64, y []float64, z []float64) int32 {
	// Computes centre of gravity coordinates
	var rv int32
	var i int32
	var j int32
	var inum int32
	var eT int32
	var xi float64
	var yi float64
	var zi float64
	var Vi float64
	var Sx float64
	var Sy float64
	var Sz float64
	var Vm float64
	x[0] = 0
	y[0] = 0
	z[0] = 0
	Vi = 0
	Vm = 0
	Sx = 0
	Sy = 0
	Sz = 0
	for i = 0; i < eLen; i++ {
		eT = femGetIntPos(i, eType, eLen)
		xi = 0
		yi = 0
		zi = 0
		if (func() int32 {
			inum = Elem[eT].nodes
			return inum
		}()) <= 0 {
			rv = -3
			return rv
		}
		// density*volume
		Vi = femGetMPValPos(i, 1, 0)
		Vm += Vi
		{
			// Static moments:
			for j = 0; j < inum; j++ {
				xi += femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_x, nLen)
				yi += femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_y, nLen)
				zi += femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_z, nLen)
			}
		}
		Sx = Vi * (xi / float64(inum))
		Sy = Vi * (yi / float64(inum))
		Sz = Vi * (zi / float64(inum))
	}
	if Vm < 1e-17 {
		// final coordinates:
		rv = -12
	} else {
		x[0] = Sx / Vm
		y[0] = Sy / Vm
		z[0] = Sz / Vm
	}
	return rv
}

// fem_sol_null - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:245
func fem_sol_null() {
	// sets some of matrices and vectors to NULL
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_i))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&uTemp))[:])
	nDOFfld = nil
	if femFastBC == 1 {
		nDOFnon = nil
	}
	K_rows = nil
	K_rowsAL = nil
	if femDynamics == 1 {
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		if femEigenModal == 1 {
			solNoLinS = 1
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&eig_omega))[:])
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&eig_shap))[:])
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&eig_x))[:])
			femVecNull((*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
			eig_y = nil
		} else {
			if femNewmarkEL == 1 {
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&dr))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&ra))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&rb))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&r0))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&rr1))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
			}
		}
	}
	if femThermTrans == 1 {
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:])
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&r0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
	}
	switch solNoLinS {
	case 1:
		// nothing to do for linear solution
	case 2:
		fallthrough
	case 6:
		// NRM
		// DDS
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	case 3:
		// ALM
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&du0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&dut))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&dur))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&du))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	case 4:
		// full ALM
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&dFr))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&FF))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&du0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&uLa))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&Fra))[:])
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:])
	case 5:
		// iterative 2nd order solver
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&du))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		break
	}
}

// fem_sol_free - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:350
func fem_sol_free() {
	// sets some of matrices and vectors to NULL
	var i int32
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&F))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&u))[:])
	femIntFree(nDOFfld)
	if femFastBC == 1 {
		femIntFree(nDOFnon)
	}
	femIntFree(K_rows)
	nDOFAct = 0
	nDOFlen = 0
	if femRunSolIterBC == 1 {
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_i))[:])
	}
	if femHaveThermLoad == 1 || femReadPrevThr == 1 {
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&uTemp))[:])
	}
	if femDynamics == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		if femEigenModal == 1 {
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&eig_omega))[:])
			femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&eig_shap))[:])
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&eig_x))[:])
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:])
			if femEigenNum > 0 && len(eig_y) != 0 {
				for i = 0; i < femEigenNum; i++ {
					femVecFree(eig_y[i:])
				}
				_ = eig_y
			}
		} else {
			if femNewmarkEL == 1 {
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&dr))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&ra))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&rb))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&r0))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&rrr0))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&rr1))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
			}
		}
	}
	if femThermTrans == 1 {
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&r0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&pp))[:])
	}
	switch solNoLinS {
	case 1:
		if femReadPrevStep == 1 {
			// nothing to do for linear solution
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		}
	case 2:
		fallthrough
	case 6:
		// NRM
		// DDS
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	case 3:
		// ALM
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&du0))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&dut))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&dur))[:])
		femVecNull((*[1000000]tVector)(unsafe.Pointer(&du))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	case 4:
		// full ALM
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&dFr))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&FF))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&du0))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&uLa))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&Fra))[:])
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:])
		femIntFree(K_rowsAL)
	case 5:
		// iterative 2nd
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&du))[:])
		femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		break
	}
}

// fem_sol_alloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:479
func fem_sol_alloc() int32 {
	// allocates K,u,F
	// * @return state value
	//
	var rv int32
	var i int32
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], 1, nDOFAct, nDOFAct, 0, K_rows)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u))[:], 0, nDOFAct, nDOFAct)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F))[:], 0, nDOFAct, nDOFAct)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], 0, nDOFAct, nDOFAct)
		return rv
	}()) != 0 {
		goto memFree
	}
	if femRunSolIterBC == 1 {
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_i))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	if (func() int32 {
		femHaveThermLoad = femTestThermStructElems()
		return femHaveThermLoad
	}()) == 1 || femReadPrevThr == 1 {
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&uTemp))[:], 0, nLen, nLen)
			return rv
		}()) != 0 {
			// test for thermal loads
			goto memFree
		}
		{
			// filling of temp field:
			for i = 0; i < nlLen; i++ {
				if nlDir[i] == 7 {
					femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&uTemp))[:], nlNode[i]+1, nlVal[i], 1)
				}
			}
		}
	}
	if femDynamics == 1 {
		if femEigenModal == 1 {
			if (func() int32 {
				rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 1, nDOFAct, nDOFAct, 0, K_rows)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&eig_shap))[:], 0, nDOFAct, femEigenNum, 0, nil)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&eig_omega))[:], 0, nDOFAct, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&eig_x))[:], 0, nDOFAct, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&eig_xM))[:], 0, nDOFAct, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
			if femEigenNum > 0 {
				if len((func() []tVector {
					eig_y = (*[1000000]tVector)(unsafe.Pointer(uintptr(func() int64 {
						c4go_temp_name := make([]byte, uint32(femEigenNum)*uint32(1))
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}())))[:]
					return eig_y
				}())) == 0 {
					rv = -4
					goto memFree
				}
				for i = 0; i < femEigenNum; i++ {
					if (func() int32 {
						rv = femVecAlloc(eig_y[i:], 0, nDOFAct, nDOFAct)
						return rv
					}()) != 0 {
						goto memFree
					}
				}
			}
		} else {
			if femNewmarkEL == 1 {
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&dr))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&ra))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rb))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r0))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rr0))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rrr0))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rr1))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rrr1))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
				if (func() int32 {
					rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, nDOFAct, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
		}
	}
	if femThermTrans == 1 {
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M))[:], 1, nDOFAct, nDOFAct, 0, K_rows)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:], 1, nDOFAct, nDOFAct, 0, K_rows)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], 1, nDOFAct, nDOFAct, 0, K_rows)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&r0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&rr0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	switch solNoLinS {
	case 2:
		fallthrough
	case 6:
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			// NRM
			// DDS
			goto memFree
		}
	case 3:
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			// ALM
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&du0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&dut))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&dur))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&du))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
	case 4:
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&KF))[:], 1, nDOFAct+1, nDOFAct+1, 0, K_rowsAL)
			return rv
		}()) != 0 {
			// full ALM
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&uLa))[:], 0, nDOFAct+1, nDOFAct+1)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&Fra))[:], 0, nDOFAct+1, nDOFAct+1)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&dFr))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&FF))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&du0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
	case 5:
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			// iterative 2nd
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&du))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_0))[:], 0, nDOFAct, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
	case 1:
		fallthrough
	default:
		if femReadPrevStep == 1 {
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&u_tot))[:], 0, nDOFAct, nDOFAct)
				return rv
			}()) != 0 {
				// nothing to do for linear solution
				goto memFree
			}
		}
		break
	}
	if rv == 0 {
		return rv
	}
memFree:
	;
	fem_sol_free()
	return rv
}

// fem_sol_res_alloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:639
func fem_sol_res_alloc() int32 {
	// allocates result fields
	var rv int32
	var sum int32
	var val int32
	var i int32
	femResNull()
	if len((func() []int32 {
		resEFrom = femIntAlloc(eLen)
		return resEFrom
	}())) == 0 {
		// results on elements
		rv = -4
		goto memFree
	}
	for i = 0; i < eLen; i++ {
		sum += Elem[eType[i]].rvals(i)
	}
	if len((func() []float64 {
		resEVal = femDblAlloc(sum)
		return resEVal
	}())) == 0 {
		rv = -4
		goto memFree
	}
	for i = 0; i < eLen; i++ {
		resEFrom[i] = Elem[eType[i]].rvals(i)
	}
	resELen = sum
	sum = 0
	for i = 0; i < eLen; i++ {
		val = resEFrom[i]
		resEFrom[i] = sum
		sum += val
	}
	// reactions
	resRLen = 0
	for i = 0; i < nlLen; i++ {
		if nlType[i] == 1 || nlType[i] == 2 || nlType[i] == 4 || nlType[i] == 5 || nlType[i] == 6 || nlType[i] == 7 {
			if nlType[i] == 1 && nlVal[i] != 0 {
				continue
			}
			resRLen++
		}
	}
	if resRLen <= 0 {
		noarch.Fprintf(msgout, []byte("[W] %s!\n\x00"), []byte("No boundary conditions defined\x00"))
		resRnode = nil
		resRdof = nil
		resRval = nil
		resRval0 = nil
	} else {
		if len((func() []int32 {
			resRnode = femIntAlloc(resRLen)
			return resRnode
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []int32 {
			resRdof = femIntAlloc(resRLen)
			return resRdof
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []float64 {
			resRval = femDblAlloc(resRLen)
			return resRval
		}())) == 0 {
			rv = -4
			goto memFree
		}
		if len((func() []float64 {
			resRval0 = femDblAlloc(resRLen)
			return resRval0
		}())) == 0 {
			rv = -4
			goto memFree
		}
		sum = 0
		for i = 0; i < nlLen; i++ {
			if nlType[i] == 1 || nlType[i] == 2 || nlType[i] == 4 || nlType[i] == 5 || nlType[i] == 6 || nlType[i] == 7 {
				if nlType[i] == 1 && nlVal[i] != 0 {
					continue
				}
				resRnode[sum] = nlNode[i]
				resRdof[sum] = nlDir[i]
				resRval[sum] = 0
				resRval0[sum] = 0
				sum++
			}
		}
	}
	if femReadPrevStep == 1 {
		// there will be reading of data from previous step (if any)
		rv = femReadRes(fem_rfile)
	}
	if femReadPrevThr == 1 {
		// there will be reading of data from previous step (if any)
		rv = femReadThermRes(fem_thrfile, (*[1000000]tVector)(unsafe.Pointer(&uTemp))[:])
	}
	if rv == 0 {
		return rv
	}
memFree:
	;
	femResFree()
	return rv
}

// fem_fill_part_of_K - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:748
func fem_fill_part_of_K(mode int32, e_from int32, e_to int32) int32 {
	// creates K_e matrices and fills K
	// * @param mode mode
	// * @return state value
	//
	var rv int32
	var ii int32
	var eT int32
	var size int32
	var K_e tMatrix
	var F_e tVector
	var Fr_e tVector
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
	for ii = e_from; ii < e_to; ii++ {
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
		noarch.Fprintf(msgout, []byte("K_e[%li] start:\n\x00"), eID[ii])
		// element type
		eT = femGetIntPos(ii, eType, eLen)
		if eT < 1 || eT >= elemLen {
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
			return -5
		}
		// K_e size
		size = Elem[eT].nodes * Elem[eT].dofs
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:], 0, size, size, 0, nil)
			return rv
		}()) != 0 {
			// K_e allocation
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
			return rv
		}
		if mode == 1 {
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], 0, size, size)
				return rv
			}()) != 0 {
				// Allocation of vectors
				femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
				return rv
			}
			if (func() int32 {
				rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:], 0, size, size)
				return rv
			}()) != 0 {
				femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
				femVecNull((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
				return rv
			}
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
		}
		if (func() int32 {
			rv = Elem[eT].stiff(ii, mode, (*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:], (*[1000000]tVector)(unsafe.Pointer(&F_e))[:], (*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
			return rv
		}()) != 0 {
			// filling of element stiffness matrix:
			femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
			return rv
		}
		if (func() int32 {
			rv = femLocKM_e((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:], (*[1000000]tMatrix)(unsafe.Pointer(&K))[:], ii)
			return rv
		}()) != 0 {
			// localization K-e -> K
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
			return rv
		}
		if mode == 1 {
			if (func() int32 {
				rv = femLocF_e((*[1000000]tVector)(unsafe.Pointer(&F_e))[:], ii, (*[1000000]tVector)(unsafe.Pointer(&F))[:], 1)
				return rv
			}()) != 0 {
				// results are computed
				// localization F-e -> F
				femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
				return rv
			}
			if (func() int32 {
				rv = femLocF_e((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:], ii, (*[1000000]tVector)(unsafe.Pointer(&Fr))[:], 0)
				return rv
			}()) != 0 {
				femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
				femVecFree((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
				return rv
			}
		}
		if mode == 1 {
			// results are computed
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
			femVecFree((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
		}
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&K_e))[:])
	}
	return rv
}

// fem_fill_K_React - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:844
func fem_fill_K_React(mode int32, r_from int32, r_to int32) int32 {
	// computes reactions
	var i int32
	var pos int32
	if mode == 1 {
		for i = r_from; i < r_to; i++ {
			if (func() int32 {
				pos = femKpos(resRnode[i], resRdof[i])
				return pos
			}()) <= 0 {
				if femFastBC == 1 {
					// femFastBC workaround
					continue
				}
				return -3
			}
			resRval[i] += femVecGet((*[1000000]tVector)(unsafe.Pointer(&F))[:], pos)
		}
	}
	return 0
}

// fem_fill_K - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:897
func fem_fill_K(mode int32) int32 {
	if mode == 1 {
		// Creates K matrix from Ke matrices
		// * @param mode mode: AF_YES for making of new matrix, AF_NO to use old
		// * @return status
		//
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
	}
	if fem_fill_part_of_K(mode, 0, eLen) != 0 {
		// serial code
		return -1
	}
	if fem_fill_K_React(mode, 0, resRLen) != 0 {
		return -1
	}
	return 0
}

// fem_fill_part_of_M - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:996
func fem_fill_part_of_M(e_from int32, e_to int32) int32 {
	// FILL M START ************************************************
	// creates M_e matrices and fills M
	// * @return status value
	//
	var rv int32
	var ii int32
	var eT int32
	var size int32
	var M_e tMatrix
	var F_e tVector
	var Fr_e tVector
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&F_e))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&Fr_e))[:])
	for ii = e_from; ii < e_to; ii++ {
		femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
		noarch.Fprintf(msgout, []byte("M_e[%li] start:\n\x00"), eID[ii])
		// element type
		eT = femGetIntPos(ii, eType, eLen)
		if eT < 1 || eT >= elemLen {
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			return -5
		}
		// M_e size
		size = Elem[eT].nodes * Elem[eT].dofs
		if (func() int32 {
			rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:], 0, size, size, 0, nil)
			return rv
		}()) != 0 {
			// M_e allocation
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			return rv
		}
		if (func() int32 {
			rv = Elem[eT].mass(ii, (*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			return rv
		}()) != 0 {
			// filling of element mass matrix:
			femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			return rv
		}
		if (func() int32 {
			rv = femLocKM_e((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M))[:], ii)
			return rv
		}()) != 0 {
			// localization M-e -> M
			femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
			return rv
		}
		femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&M_e))[:])
	}
	return rv
}

// fem_fill_M - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1059
func fem_fill_M() int32 {
	if fem_fill_part_of_M(0, eLen) != 0 {
		// Creates M matrix from Me matrices
		// * @param mode mode: AF_YES for making of new matrix, AF_NO to use old
		// * @return status
		//
		// serial code
		return -1
	}
	return 0
}

// fem_add_loads - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1119
func fem_add_loads(step int32) int32 {
	// FILL M END **************************************************
	// Adds loads and boundary conditions
	// * @param transient analysis step (0 for all other!); starts from 1!
	//
	var rv int32
	var i int32
	var mult float64
	if math.Abs(grVal) > 0 {
		if (func() int32 {
			rv = femAddGravLoad(grDir, grVal)
			return rv
		}()) != 0 {
			// gravitation
			return rv
		}
	}
	{
		// loads on elements
		for i = 0; i < elLen; i++ {
			if (func() int32 {
				rv = femAddElemLoad()
				return rv
			}()) != 0 {
				return rv
			}
		}
	}
	if femHaveThermLoad == 1 {
		if (func() int32 {
			rv = femAddThermLoads()
			return rv
		}()) != 0 {
			// Thermal loads from structural analysis
			return rv
		}
	}
	{
		// loads on nodes:
		for i = 0; i < nlLen; i++ {
			if step > 0 && transNum > 0 {
				if nlTrPos[i] > -1 {
					mult = transMult[nlTrPos[i]][step-1] * nlVal[i]
					if (func() int32 {
						rv = femApplyNLoad(nlNode[i], nlType[i], nlDir[i], mult)
						return rv
					}()) != 0 {
						noarch.Fprintf(msgout, []byte("[W] %s: %s=%li %s=%li\n\x00"), []byte("Transient load not applied\x00"), []byte("node\x00"), nID[nlNode[i]], []byte("direction\x00"), nlDir[i])
					}
				} else {
					if (func() int32 {
						rv = femApplyNLoad(nlNode[i], nlType[i], nlDir[i], nlVal[i])
						return rv
					}()) != 0 {
						noarch.Fprintf(msgout, []byte("[W] %s: %s=%li %s=%li\n\x00"), []byte("Load not applied\x00"), []byte("node\x00"), nID[nlNode[i]], []byte("direction\x00"), nlDir[i])
					}
				}
			} else {
				if (func() int32 {
					rv = femApplyNLoad(nlNode[i], nlType[i], nlDir[i], nlVal[i])
					return rv
				}()) != 0 {
					noarch.Fprintf(msgout, []byte("[W] %s: %s=%li %s=%li\n\x00"), []byte("Load not applied\x00"), []byte("node\x00"), nID[nlNode[i]], []byte("direction\x00"), nlDir[i])
				}
			}
		}
	}
	return rv
}

// fem_add_disps - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1195
func fem_add_disps(disp_mode int32, step int32) int32 {
	// Adds displacements to the model
	// * @param disp_mode .. AF_YES..default behaviour, AF_NO..zero diplacements are assumed
	// * @param step .. time step (for Newmark etc.), otherwise use 0
	//
	var rv int32
	var i int32
	var mult float64
	{
		// boundary conditions on nodes - __must__ be added __last__:
		for i = 0; i < nlLen; i++ {
			if disp_mode == 1 {
				if step > 0 && transNum > 0 {
					if nlTrPos[i] > -1 {
						// default behaviour
						mult = transMult[nlTrPos[i]][step-1] * nlVal[i]
						if (func() int32 {
							rv = femApplyNBC(nlNode[i], nlType[i], nlDir[i], mult)
							return rv
						}()) != 0 {
							return rv
						}
					} else {
						if (func() int32 {
							rv = femApplyNBC(nlNode[i], nlType[i], nlDir[i], nlVal[i])
							return rv
						}()) != 0 {
							return rv
						}
					}
				} else {
					if (func() int32 {
						rv = femApplyNBC(nlNode[i], nlType[i], nlDir[i], nlVal[i])
						return rv
					}()) != 0 {
						return rv
					}
				}
			} else {
				if (func() int32 {
					rv = femApplyNBC(nlNode[i], nlType[i], nlDir[i], 0)
					return rv
				}()) != 0 {
					//
					// replaces disp value with 0.0
					return rv
				}
			}
		}
	}
	return rv
}

// fem_dofs - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1263
func fem_dofs() int32 {
	// computes number of DOFs, creates some field for DOF describing
	// original code
	var rv int32
	var i int32
	var j int32
	var k int32
	var sum int32
	var act_sum int32
	var npos int32
	var dpos int32
	var etype int32
	sum = nLen * 7
	if len((func() []int32 {
		nDOFfld = femIntAlloc(sum)
		return nDOFfld
	}())) == 0 {
		rv = -4
		goto memFree
	}
	nDOFlen = sum
	if femFastBC == 1 {
		if len((func() []int32 {
			nDOFnon = femIntAlloc(sum)
			return nDOFnon
		}())) == 0 {
			// computes DOFs exclusion field
			rv = -4
			goto memFree
		}
		{
			// slow but necessary
			for i = 0; i < sum; i++ {
				nDOFnon[i] = 0
			}
		}
		for i = 0; i < nlLen; i++ {
			if nlType[i] == 1 {
				if math.Abs(nlVal[i]) <= 1e-17 {
					// displacements
					nDOFnon[nlNode[i]*7+nlDir[i]-1] = 1
				}
			}
		}
	}
	// computes number of active DOFs in nodes (nDOFfld)
	act_sum = 0
	for i = 0; i < eLen; i++ {
		etype = femGetIntPos(i, eType, eLen)
		for j = 0; j < Elem[etype].nodes; j++ {
			npos = femGetIntLPos(i, j, eFrom, eNodesL, eLenL)
			if npos < 0 {
				noarch.Fprintf(msgout, []byte("[E] %s (n=%li pos=%li): %li!\n\x00"), []byte("Invalid node position in element\x00"), nID[i], j+1, npos)
				rv = -3
				goto memFree
			}
			for k = 0; k < Elem[etype].dofs; k++ {
				// "-1" because DOF starts from "1" not "0"
				dpos = npos*7 + Elem[etype].ndof[k] - 1
				noarch.Fprintf(msgout, []byte("line %li (n=%li, dof=%li)\n\x00"), dpos, npos, Elem[etype].ndof[k])
				if femFastBC == 1 {
					if nDOFnon[dpos] == 1 {
						// omit BCs.
						continue
					}
				}
				if nDOFfld[dpos] == 0 {
					nDOFfld[dpos] = 1
					act_sum++
				}
			}
		}
	}
	if act_sum < 1 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("No degrees of freedom found\x00"))
		return -9
	}
	// size of "K" matrix:
	nDOFAct = act_sum
	// creates K matrix description
	act_sum = 1
	for i = 0; i < nDOFlen; i++ {
		if nDOFfld[i] != 0 {
			nDOFfld[i] = act_sum
			act_sum++
		}
	}
	// as result of previous loop nDOFfld includes unused DOFS (0)
	//  * and used ones (1...nDOFAct)
	//  * so K indexes are [1..nDOFAct][1..nDOFAct]
	//
	noarch.Fprintf(msgout, []byte("\nK matrix structure: \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(msgout, []byte("%li: \x00"), nID[i])
		for j = 0; j < 7; j++ {
			noarch.Fprintf(msgout, []byte("%li \x00"), nDOFfld[i*7+j])
		}
		noarch.Fprintf(msgout, []byte("\n\x00"))
	}
	if len((func() []int32 {
		K_rows = femIntAlloc(nDOFAct)
		return K_rows
	}())) == 0 {
		// field for row lenghts ("K" matrix)
		rv = -4
		goto memFree
	}
	if (func() int32 {
		rv = femKhit()
		return rv
	}()) != 0 {
		goto memFree
	}
	for i = 0; i < nDOFAct; i++ {
		noarch.Fprintf(msgout, []byte("K[%li] = %li\n\x00"), i+1, K_rows[i])
	}
	if solNoLinS == 4 {
		if len((func() []int32 {
			K_rowsAL = femIntAlloc(nDOFAct + 1)
			return K_rowsAL
		}())) == 0 {
			// full ALM only
			rv = -4
			goto memFree
		}
		for i = 0; i < nDOFAct; i++ {
			K_rowsAL[i] = K_rows[i] + 1
		}
		K_rowsAL[nDOFAct] = nDOFAct + 1
	}
	if rv == 0 {
		// end of full ALM code
		return rv
	}
memFree:
	;
	return rv
}

// femSolveBC - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1397
func femSolveBC() int32 {
	// finite element analysis - special boundary conditions can be used (iteration!)
	// * TODO: special filed (u_tot) for support status needed
	// *  @return state value
	//
	var rv int32
	// number of iterations
	var substeps int32 = 60
	var i int32
	var j int32
	noarch.Fprintf(msgout, []byte("[I] %s:\n\x00"), []byte("Solution\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("one-directional supports are used (if any)\x00"))
	// !!!
	femTangentMatrix = 0
	if solNoLinSteps_cmd > 0 {
		substeps = solNoLinSteps_cmd
	}
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	for i = 0; i < substeps; i++ {
		noarch.Fprintf(msgout, []byte("[i]   %s: %4li\n\x00"), []byte("iteration\x00"), i+1)
		if i > 0 {
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
			femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
			femIterBCchange = 0
			for j = 0; j < resRLen; j++ {
				resRval[j] = 0
			}
		}
		if (func() int32 {
			rv = fem_fill_K(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_loads(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_disps(1, 0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if i > 0 {
			noarch.Fprintf(msgout, []byte("[ ]   %s: %li\n\x00"), []byte("iteration\x00"), i)
		}
		if solUseBiCGs != 1 {
			if solUseCGSSOR != 1 {
				if (func() int32 {
					rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			} else {
				if (func() int32 {
					rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
		} else {
			if (func() int32 {
				rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		}
		femIterEchange = 0
		if (func() int32 {
			rv = fem_fill_K(1)
			return rv
		}()) != 0 {
			goto memFree
		}
		for j = 0; j < resRLen; j++ {
			resRval0[j] = resRval[j]
		}
		if i > 1 {
			noarch.Fprintf(msgout, []byte("[ ]    %s: %4li, %s : %4li\n\x00"), []byte("BC change\x00"), femIterBCchange, []byte("ES change\x00"), femIterEchange)
		}
		if i > 0 {
			if (femIterBCchange <= nlLen/100 || femIterBCchange <= 1) && femIterEchange < 1 {
				break
			}
		}
	}
	if femReadPrevStep == 1 {
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	}
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
	if femComputePE == 1 {
		femCompPE((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1)
	}
memFree:
	;
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// femSolve2ndIter - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1512
func femSolve2ndIter() int32 {
	// finite element analysis - attempt to use 2nd order theory with
	// *  an iterative solver
	// *  @return state value
	//
	var rv int32 = -1
	// number of iterations
	var substeps int32 = 4
	var i int32
	var j int32
	var jj int32
	var pos int32
	var count int32
	var normF float64
	var normKu float64
	femTangentMatrix = 1
	noarch.Fprintf(msgout, []byte("[I] %s:\n\x00"), []byte("Solution\x00"))
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	for i = 0; i < substeps; i++ {
		if (func() int32 {
			rv = fem_fill_K(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_loads(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_add_disps(1, 0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if i > 0 {
			noarch.Fprintf(msgout, []byte("[ ]   %s: %li\n\x00"), []byte("iteration\x00"), i+1)
		}
		if solUseBiCGs != 1 {
			if solUseCGSSOR != 1 {
				if (func() int32 {
					rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			} else {
				if (func() int32 {
					rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
					return rv
				}()) != 0 {
					goto memFree
				}
			}
		} else {
			if (func() int32 {
				rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		}
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&F))[:], []byte("FF\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], []byte("Fr1\x00"))
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&u))[:], []byte("uu\x00"))
		if (func() int32 {
			rv = fem_fill_K(1)
			return rv
		}()) != 0 {
			goto memFree
		}
		femVecPrn((*[1000000]tVector)(unsafe.Pointer(&Fr))[:], []byte("Fr2\x00"))
		if i == 0 {
			normF = femVecNorm((*[1000000]tVector)(unsafe.Pointer(&Fr))[:])
		} else {
			normKu = femVecNorm((*[1000000]tVector)(unsafe.Pointer(&u))[:])
			noarch.Fprintf(msgout, []byte("[ ] Iter %li %e/%e=%e.\n\x00"), i, normF, normKu, normF/normKu)
			if normKu/normF < 0.001 {
				rv = 0
				noarch.Fprintf(msgout, []byte("[i] %s.\n\x00"), []byte("Solution converged\x00"))
				break
			}
		}
		// adding of disps to x,y,z:
		count = 0
		for j = 0; j < nLen; j++ {
			pos = j*7 + 0
			if nDOFfld[pos] == 1 {
				n_x[j] += femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], count+0)
			}
			pos = j*7 + 1
			if nDOFfld[pos] == 1 {
				n_y[j] += femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], count+1)
			}
			pos = j*7 + 2
			if nDOFfld[pos] == 1 {
				n_z[j] += femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], count+2)
			}
			for jj = 0; jj < 7; jj++ {
				if nDOFfld[j*7+jj] == 1 {
					count++
				}
			}
		}
	}
	if femReadPrevStep == 1 {
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	}
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
memFree:
	;
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// femSolve - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1655
func femSolve() int32 {
	// finite element analysis ;-) ------------------------------------
	// *  @return state value
	//
	var rv int32
	if femRunSolIterBC == 1 {
		// special b.c.:
		return femSolveBC()
	}
	if fem2ndOrderIter == 1 {
		// iterative 2nd order:
		return femSolve2ndIter()
	}
	// "normal" solution:
	noarch.Fprintf(msgout, []byte("[I] %s:\n\x00"), []byte("Solution\x00"))
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	femResNull()
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("data checking and allocations\x00"))
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("data checking and allocations done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("assembling of stiffness matrix\x00"))
	if (func() int32 {
		rv = fem_fill_K(0)
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("assembling of stiffness matrix done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("loads and supports\x00"))
	if (func() int32 {
		rv = fem_add_loads(0)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_add_disps(1, 0)
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("loads and supports done\x00"))
	if femSaveMatFStat == 1 {
		femMatPrnF(femSaveMatFName, (*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
	}
	if femSaveSparMatFStat == 1 {
		femSparseMatPrnF(femSaveSparMatFName, (*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
	}
	if femSaveSparMarketMatFStat == 1 {
		femSparseMarketMatPrnF(femSaveSparMarketMatFName, (*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
	}
	if femSaveVecFStat == 1 {
		femVecPrnF(femSaveVecFName, (*[1000000]tVector)(unsafe.Pointer(&F))[:])
	}
	if femBreakSolu == 1 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("solution of linear equations\x00"))
	if solUseBiCGs != 1 {
		if solUseCGSSOR != 1 {
			if (func() int32 {
				rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		} else {
			if (func() int32 {
				rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		}
	} else {
		if (func() int32 {
			rv = femEqsBiCCSwJ((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
			return rv
		}()) != 0 {
			goto memFree
		}
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("solution of linear equations done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("element results\x00"))
	if (func() int32 {
		rv = fem_fill_K(1)
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("element results done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("saving of results\x00"))
	if femReadPrevStep == 1 {
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&u))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&u_tot))[:])
	}
	if (func() int32 {
		rv = femWriteRes(fem_output_file())
		return rv
	}()) != 0 {
		goto memFree
	}
	if femHaveThermDOFs == 1 {
		if len(fem_throfile) != 0 {
			// thermal DOFS (if any)
			rv = femWriteThermDOFS(fem_throfile, (*[1000000]tVector)(unsafe.Pointer(&u))[:])
		}
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("saving of results done\x00"))
	if len(fem_spec_out_file) != 0 {
		noarch.Fprintf(msgout, []byte("[i]  %s:\n\x00"), []byte("Saving results in custom format\x00"))
		switch fem_spec_out_type {
		case 1:
			if femWriteNodeResVTK(fem_spec_out_file) == 0 {
				noarch.Fprintf(msgout, []byte("[i]    %s.\n\x00"), []byte("succesfully saved as VTK (legacy)\x00"))
			} else {
				noarch.Fprintf(msgout, []byte("[i]    %s!\n\x00"), []byte("writing of data failed\x00"))
			}
		case 0:
			fallthrough
		default:
			if femWriteNodeResTxt(fem_spec_out_file) == 0 {
				noarch.Fprintf(msgout, []byte("[i]    %s.\n\x00"), []byte("succesfully saved as ANSI text\x00"))
			} else {
				noarch.Fprintf(msgout, []byte("[i]    %s!\n\x00"), []byte("writing of data failed\x00"))
			}
			break
		}
	}
	if femComputePE == 1 {
		femCompPE((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1)
	}
memFree:
	;
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// femComputePrice - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1823
func femComputePrice() int32 {
	// computes total price of sturcture based on element volumes
	// *  @return state value
	//
	var rv int32
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(noarch.Stdout, []byte("%f\n\x00"), fem_get_struct_price(0))
memFree:
	;
	fem_sol_free()
	femDataFree()
	return rv
}

// femComputeGravCentre - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_sol.c:1848
func femComputeGravCentre() int32 {
	// computes centre of grafity of structure based on element volumes
	// *  @return state value
	//
	var rv int32
	var x float64
	var y float64
	var z float64
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	fem_sol_null()
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if fem_gravity_centre(c4goUnsafeConvert_float64(&x), c4goUnsafeConvert_float64(&y), c4goUnsafeConvert_float64(&z)) == 0 {
		noarch.Fprintf(noarch.Stdout, []byte("%f %f %f\n\x00"), x, y, z)
	}
memFree:
	;
	fem_sol_free()
	femDataFree()
	return rv
}

// femFindResTypeET - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spio.c:46
func femFindResTypeET(eT int32, type_ int32) int32 {
	//
	//   File name: fem_spio.c
	//   Date:      2009/02/19 17:08
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2009 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   Finite Element Solver - special types of I/O operations
	//
	// SILO library interface: https://wci.llnl.gov/codes/silo
	// Find is given element type provides given kind of element result
	// * @param eT type of element
	// * @param type results type
	// * @return AF_YES if provides, AF_NO if not
	//
	var i int32
	for i = 0; i < Elem[eT].res; i++ {
		if Elem[eT].nres[i] == type_ {
			return 1
		}
	}
	for i = 0; i < Elem[eT].res_rp; i++ {
		if Elem[eT].nres_rp[i] == type_ {
			return 1
		}
	}
	return 0
}

// femGetAvNodeRes - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spio.c:66
func femGetAvNodeRes(type_ int32, fld []float64, intfld []int32, fldLen int32) int32 {
	// Computes average results in nodes
	// * @param type result type
	// * @param fld field for results
	// * @param intfld field for numbers of results in node
	// * @param fldLen length of fld ( must be identical to nLen!)
	// * @return status
	// *
	var rv int32
	var i int32
	var j int32
	var eT int32
	var npos int32
	var val float64
	for i = 0; i < nLen; i++ {
		fld[i] = 0
		intfld[i] = 0
	}
	for i = 0; i < eLen; i++ {
		eT = femGetIntPos(i, eType, eLen)
		if femFindResTypeET(eT, type_) == 1 {
			for j = 0; j < Elem[eT].nodes; j++ {
				npos = eNodesL[eFrom[i]+j]
				val = 0
				Elem[eT].res_node(i, j, type_, c4goUnsafeConvert_float64(&val))
				fld[npos] += val
				intfld[npos]++
			}
		}
	}
	for i = 0; i < nLen; i++ {
		if intfld[i] > 0 {
			fld[i] /= float64(intfld[i])
		}
	}
	return rv
}

// femWriteNodeResTxt - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spio.c:109
func femWriteNodeResTxt(fname []byte) int32 {
	// Writes brick data and results to file
	//
	var rv int32
	var fr *noarch.File
	var i int32
	var j int32
	var resfld [][]float64 = make([][]float64, 12)
	var intfld []int32
	{
		// space for results in nodes
		for i = 0; i < 12; i++ {
			if len((func() []float64 {
				resfld[i] = femDblAlloc(nLen)
				return resfld[i]
			}())) == 0 {
				for j = 0; j < i; j++ {
					femDblFree(resfld[j])
				}
				noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Out of memory during VTK export\x00"))
				return -4
			}
		}
	}
	if len((func() []int32 {
		intfld = femIntAlloc(nLen)
		return intfld
	}())) == 0 {
		for j = 0; j < 12; j++ {
			femDblFree(resfld[j])
		}
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Out of memory during VTK export\x00"))
		return -4
	}
	femGetAvNodeRes(13, resfld[0], intfld, nLen)
	femGetAvNodeRes(14, resfld[1], intfld, nLen)
	femGetAvNodeRes(15, resfld[2], intfld, nLen)
	femGetAvNodeRes(7, resfld[3], intfld, nLen)
	femGetAvNodeRes(8, resfld[4], intfld, nLen)
	femGetAvNodeRes(9, resfld[5], intfld, nLen)
	if len(fname) == 0 {
		// open file: **************************************
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid name for listing file\x00"))
		return -3
	} else {
		if (func() *noarch.File {
			fr = noarch.Fopen(fname, []byte("w\x00"))
			return fr
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Cannot open data file\x00"))
			return -2
		}
	}
	// Write nodes:
	noarch.Fprintf(fr, []byte("%li %i\n\x00"), nLen, 4+12)
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%li %e %e %e\x00"), nID[i], n_x[i], n_y[i], n_z[i])
		for j = 0; j < 12; j++ {
			noarch.Fprintf(fr, []byte(" %e\x00"), resfld[j][i])
		}
		noarch.Fprintf(fr, []byte("\n\x00"))
	}
	{
		// freeing of data files
		for j = 0; j < 12; j++ {
			femDblFree(resfld[j])
		}
	}
	femIntFree(intfld)
	if (int64(uintptr(unsafe.Pointer(fr)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fr) != 0 {
			// close file: *************************************
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of previous result file\x00"))
			fr = nil
			return -2
		}
	}
	return rv
}

// femToTypeVTK - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spio.c:199
func femToTypeVTK(e_type int32) int32 {
	switch e_type {
	case 1:
		// line
		return 3
	case 2:
		// rectangle
		return 9
	case 3:
		// line
		return 1
	case 4:
		// tetrahedron
		return 10
	case 5:
		// rectangle
		return 9
	case 6:
		// line
		return 1
	case 7:
		// line
		return 1
	case 8:
		// brick20
		return 25
	case 9:
		// brick8
		return 12
	case 10:
		// brick8
		return 12
	case 11:
		// triangle
		return 5
	case 14:
		// line
		return 3
	case 15:
		// line
		return 3
	default:
		// point
		return 1
		break
	}
	return 1
}

// femWriteNodeResVTK - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spio.c:225
func femWriteNodeResVTK(fname []byte) int32 {
	// Writes VTK file
	//
	var rv int32
	var fr *noarch.File
	var i int32
	var j int32
	var num int32
	var et int32
	var resfld [][]float64 = make([][]float64, 12)
	var intfld []int32
	var sigma tVector
	var sigma1 tVector
	// vectors for principal stresses:
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma1))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma1))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if nLen < 4 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Dataset is too small\x00"))
		return -9
	}
	{
		// space for results in nodes
		for i = 0; i < 12; i++ {
			if len((func() []float64 {
				resfld[i] = femDblAlloc(nLen)
				return resfld[i]
			}())) == 0 {
				for j = 0; j < i; j++ {
					femDblFree(resfld[j])
				}
				noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Out of memory during VTK export\x00"))
				return -4
			}
		}
	}
	if len((func() []int32 {
		intfld = femIntAlloc(nLen)
		return intfld
	}())) == 0 {
		for j = 0; j < 12; j++ {
			femDblFree(resfld[j])
		}
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Out of memory during VTK export\x00"))
		return -4
	}
	femGetAvNodeRes(13, resfld[0], intfld, nLen)
	femGetAvNodeRes(14, resfld[1], intfld, nLen)
	femGetAvNodeRes(15, resfld[2], intfld, nLen)
	femGetAvNodeRes(7, resfld[3], intfld, nLen)
	femGetAvNodeRes(8, resfld[4], intfld, nLen)
	femGetAvNodeRes(9, resfld[5], intfld, nLen)
	femGetAvNodeRes(11, resfld[6], intfld, nLen)
	femGetAvNodeRes(12, resfld[7], intfld, nLen)
	femGetAvNodeRes(10, resfld[8], intfld, nLen)
	{
		// Computing of principal stresses (in 3D):
		for i = 0; i < nLen; i++ {
			for j = 3; j < 9; j++ {
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], j-2, resfld[j][i], 0)
			}
			femPrinc3D((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&sigma1))[:])
			for j = 0; j < 3; j++ {
				resfld[9+j][i] = femVecGet((*[1000000]tVector)(unsafe.Pointer(&sigma1))[:], j+1)
			}
		}
	}
	if len(fname) == 0 {
		// open file: **************************************
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid name for listing file\x00"))
		return -3
	} else {
		if (func() *noarch.File {
			fr = noarch.Fopen(fname, []byte("w\x00"))
			return fr
		}()) == nil {
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Can not open file\x00"))
			return -2
		}
	}
	noarch.Fprintf(fr, []byte("# vtk DataFile Version 2.0\n\x00"))
	noarch.Fprintf(fr, []byte("uFEM_model\n\x00"))
	noarch.Fprintf(fr, []byte("ASCII\n\x00"))
	noarch.Fprintf(fr, []byte("DATASET UNSTRUCTURED_GRID\n\x00"))
	noarch.Fprintf(fr, []byte("POINTS %li float\n\x00"), nLen)
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e %e %e\n\x00"), n_x[i], n_y[i], n_z[i])
	}
	noarch.Fprintf(fr, []byte("\nCELLS %li %li\n\x00"), eLen, eLenL+eLenL)
	for i = 0; i < eLen; i++ {
		et = femGetIntPos(i, eType, eLen)
		num = Elem[et].nodes
		noarch.Fprintf(fr, []byte("%li\x00"), num)
		for j = 0; j < num; j++ {
			noarch.Fprintf(fr, []byte(" %li\x00"), eNodesL[eFrom[i]+j])
		}
		noarch.Fprintf(fr, []byte("\n\x00"))
	}
	noarch.Fprintf(fr, []byte("\nCELL_TYPES %li\n\x00"), eLen)
	for i = 0; i < eLen; i++ {
		et = femGetIntPos(i, eType, eLen)
		noarch.Fprintf(fr, []byte("%li\n\x00"), femToTypeVTK(et))
	}
	// result:
	noarch.Fprintf(fr, []byte("\nPOINT_DATA %li\n\x00"), nLen)
	noarch.Fprintf(fr, []byte("SCALARS nodenumbers float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), float64(nID[i]))
	}
	// result:
	//fprintf(fr,"\nPOINT_DATA %li\n", nLen);
	noarch.Fprintf(fr, []byte("SCALARS u_x float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(i, 1)))
	}
	//fprintf(fr,"\nPOINT_DATA %li\n", nLen);
	noarch.Fprintf(fr, []byte("SCALARS u_y float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(i, 2)))
	}
	//fprintf(fr,"\nPOINT_DATA %li\n", nLen);
	noarch.Fprintf(fr, []byte("SCALARS u_z float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), femVecGet((*[1000000]tVector)(unsafe.Pointer(&u))[:], femKpos(i, 3)))
	}
	// Strains and stresses:
	noarch.Fprintf(fr, []byte("SCALARS e_x float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[0][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS e_y float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[1][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS e_z float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[2][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_x float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[3][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_y float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[4][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_z float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[5][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_yz float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[6][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_zx float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[7][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_xy float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[8][i])
	}
	// Principal stresses:
	noarch.Fprintf(fr, []byte("SCALARS s_1 float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[9][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_2 float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[10][i])
	}
	noarch.Fprintf(fr, []byte("SCALARS s_3 float 1 \n\x00"))
	noarch.Fprintf(fr, []byte("LOOKUP_TABLE default \n\x00"))
	for i = 0; i < nLen; i++ {
		noarch.Fprintf(fr, []byte("%e \n\x00"), resfld[11][i])
	}
	{
		// freeing of data files
		for j = 0; j < 12; j++ {
			femDblFree(resfld[j])
		}
	}
	femIntFree(intfld)
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma1))[:])
	if (int64(uintptr(unsafe.Pointer(fr)))/int64(8) - int64(uintptr(unsafe.Pointer(noarch.Stdout)))/int64(8)) != 0 {
		if noarch.Fclose(fr) != 0 {
			// close file: *************************************
			noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Error during closing of previous result file\x00"))
			fr = nil
			return -2
		}
	}
	return rv
}

// femSaPoFName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:36
//
//   File name: fem_spnt.c
//   Date:      2003/06/08 16:40
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2003 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//	 FEM Solver - routines to save results in selected points (for NRM etc.)
//
//	 $Id: fem_spnt.c,v 1.4 2004/11/11 21:39:26 jirka Exp $
//
// filename
var femSaPoFName []byte

// femSaPoNode - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:37
// node number
var femSaPoNode int32

// femSaPoLen - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:38
// lenght of femSaPo
var femSaPoLen int32

// femSaPoActual - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:39
// actual item in femSaPo
var femSaPoActual int32

// femSaPo - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:40
// structure for saving of data in ONE selected point
var femSaPo []tSaPo

// femSaPoHaveIt - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:41
// rellevent only for USE_MPI
var femSaPoHaveIt int32

// femSumReactName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:43
// filename for reactions
var femSumReactName []byte

// femSumReactVal - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:44
// reaction data
var femSumReactVal []float64 = make([]float64, 7)

// femSumReactStdOut - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:45
// use stdout?
var femSumReactStdOut int32

// femSaPoAlloc - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:53
func femSaPoAlloc(NewLen int32, OldLen int32) int32 {
	// Allocates space for SaPo
	// * @param NewLen lenght of allocated field
	// * @param OldLen current lenght of allocated field (0 for new )
	// * @return status
	//
	var rv int32
	var i int32
	var tmp []tSaPo
	if femUseSaPo != 1 {
		femSaPo = nil
		return rv
	}
	if len((func() []tSaPo {
		tmp = (*[1000000]tSaPo)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := make([]byte, uint32(NewLen)*uint32(1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		return tmp
	}())) == 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Failed to allocate result tracking structure\x00"))
		return -4
	}
	if OldLen > 0 && NewLen > OldLen {
		for i = 0; i < OldLen; i++ {
			tmp[i].mult = femSaPo[i].mult
			tmp[i].x = femSaPo[i].x
			tmp[i].y = femSaPo[i].y
			tmp[i].z = femSaPo[i].z
			tmp[i].unused = femSaPo[i].unused
		}
	}
	for i = OldLen; i < NewLen; i++ {
		tmp[i].mult = 0
		tmp[i].x = 0
		tmp[i].y = 0
		tmp[i].z = 0
		tmp[i].unused = 0
	}
	if OldLen > 0 {
		_ = femSaPo
	}
	femSaPo = tmp
	tmp = nil
	return rv
}

// femSaPoFree - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:102
func femSaPoFree() {
	if femUseSaPo != 1 {
		// Frees SaPo field
		//
		return
	}
	_ = femSaPo
	femSaPo = nil
}

// femSaPoInput - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:118
func femSaPoInput(mult float64, x float64, y float64, z float64, append_ int32, unused int32) int32 {
	// Fills line in femSaPo
	// * @param mult load multiplier (total)
	// * @param x x-displacement (total)
	// * @param y y-displacement (total)
	// * @param z z-displacement (total)
	// * @param append if AF_YES multiplier size is appended, not rewrited
	// * @param unused if AF_YES data will not be saved
	// * @return status
	//
	var rv int32
	if femUseSaPo != 1 {
		return rv
	}
	if femSaPoActual >= femSaPoLen {
		if (func() int32 {
			rv = femSaPoAlloc(femSaPoActual+2, femSaPoLen)
			return rv
		}()) != 0 {
			return rv
		}
		femSaPoLen = femSaPoActual + 1
	}
	if append_ == 1 {
		if femSaPoActual > 0 {
			femSaPo[femSaPoActual].mult = femSaPo[femSaPoActual-1].mult
			femSaPo[femSaPoActual].x = femSaPo[femSaPoActual-1].x
			femSaPo[femSaPoActual].y = femSaPo[femSaPoActual-1].y
			femSaPo[femSaPoActual].z = femSaPo[femSaPoActual-1].z
		}
		femSaPo[femSaPoActual].mult += mult
		femSaPo[femSaPoActual].x += x
		femSaPo[femSaPoActual].y += y
		femSaPo[femSaPoActual].z += z
	} else {
		femSaPo[femSaPoActual].mult = mult
		femSaPo[femSaPoActual].x = x
		femSaPo[femSaPoActual].y = y
		femSaPo[femSaPoActual].z = z
	}
	femSaPo[femSaPoActual].unused = unused
	femSaPoActual++
	return rv
}

// femSaPoSave - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:230
func femSaPoSave() int32 {
	// Save SaPo data to file
	// * @return status
	//
	var rv int32
	var i int32
	var fw *noarch.File
	if femUseSaPo != 1 {
		return rv
	}
	if (func() *noarch.File {
		fw = noarch.Fopen(femSaPoFName, []byte("w\x00"))
		return fw
	}()) == nil {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Failed to write result-tracking data\x00"))
		return -2
	} else {
		noarch.Fprintf(fw, []byte("0.0 0.0 0.0 0.0\n\x00"))
		for i = 0; i < femSaPoActual; i++ {
			if femSaPo[i].unused == 1 {
				continue
			}
			noarch.Fprintf(fw, []byte("%e %e %e %e\n\x00"), femSaPo[i].mult, femSaPo[i].x, femSaPo[i].y, femSaPo[i].z)
		}
		if noarch.Fclose(fw) != 0 {
			return -2
		}
	}
	return rv
}

// femSaPoDestroy - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:308
func femSaPoDestroy() {
	if femUseSaPo != 1 {
		// Eliminates all SaPo-related stuff
		return
	}
	femSaPoFree()
	_ = femSaPoFName
	femSaPoFName = nil
	femSaPoNode = 0
	femSaPoLen = 0
	femSaPoActual = 0
}

// femSaPoFileName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:325
func femSaPoFileName(fname []byte) (c4goDefaultReturn int32) {
	if len((func() []byte {
		femSaPoFName = make([]byte, 1*(noarch.Strlen(fname)+int32(1)))
		return femSaPoFName
	}())) == 0 {
		// Sets filename for femSaPo data
		// *  @param fname name of file
		// *  @return status
		//
		femUseSaPo = 0
		return -2
	} else {
		noarch.Strcpy(femSaPoFName, fname)
		femSaPoFName[noarch.Strlen(fname)] = '\x00'
		femUseSaPo = 1
		return 0
	}
	return
}

// femSaPoSetNode - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:365
func femSaPoSetNode(from int32, num int32) (c4goDefaultReturn int32) {
	// Sets SaPo node
	// * @param str node number (string)
	// * @return status
	//
	var found int32
	var i int32
	if femUseSaPo != 1 {
		return 0
	}
	if femSaPoNode <= 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid logging node\x00"))
		femSaPoDestroy()
		goto memFree
	}
	for i = from; i < from+num; i++ {
		if femSaPoNode == nID[i] {
			femSaPoNode = i
			found = 1
			break
		}
	}
memFree:
	;
	if found == 0 {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Invalid logging node\x00"))
		return -3
	} else {
		return 0
	}
	return
}

// femGetSumReactInit - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:419
func femGetSumReactInit(fname []byte) int32 {
	// SUM OF REACTIONS
	// Makes empty file "fname" for reactions
	var i int32
	var fw *noarch.File
	if len(fname) == 0 {
		return 0
	}
	if (func() *noarch.File {
		fw = noarch.Fopen(fname, []byte("w\x00"))
		return fw
	}()) == nil {
		return -2
	}
	noarch.Fprintf(fw, []byte("0 0 0 \x00"))
	for i = 0; i < 7; i++ {
		femSumReactVal[i] = 0
		noarch.Fprintf(fw, []byte(" 0\x00"))
	}
	noarch.Fprintf(fw, []byte("\n\x00"))
	noarch.Fclose(fw)
	return 0
}

// femGetSumReact - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:443
func femGetSumReact(step int32, iter int32, mult float64, fname []byte, TangentMatrix int32) int32 {
	// Writes sum of reactions to file (with given step/iter/multiplier)
	var i int32
	var val []float64 = make([]float64, 7)
	var fw *noarch.File
	if femSumReactStdOut != 1 {
		if len(fname) == 0 {
			return 0
		}
		if (func() *noarch.File {
			fw = noarch.Fopen(fname, []byte("a\x00"))
			return fw
		}()) == nil {
			return -2
		}
	} else {
		fw = noarch.Stdout
	}
	for i = 0; i < 7; i++ {
		val[i] = 0
	}
	for i = 0; i < resRLen; i++ {
		if resRdof[i] <= 7 {
			val[resRdof[i]-1] += resRval[i]
		}
	}
	noarch.Fprintf(fw, []byte("%li %li %e \x00"), step, iter, mult)
	for i = 0; i < 7; i++ {
		noarch.Fprintf(fw, []byte(" %e\x00"), val[i])
	}
	noarch.Fprintf(fw, []byte(" \n\x00"))
	if femSumReactStdOut != 1 {
		noarch.Fclose(fw)
	} else {
		fw = nil
	}
	return 0
}

// femSumReactFileName - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_spnt.c:494
func femSumReactFileName(fname []byte) (c4goDefaultReturn int32) {
	if len((func() []byte {
		femSumReactName = make([]byte, 1*(noarch.Strlen(fname)+int32(1)))
		return femSumReactName
	}())) == 0 {
		// Sets filename for sum of reactions data
		// *  @param fname name of file
		// *  @return status
		//
		femSumReactName = nil
		return -2
	} else {
		noarch.Strcpy(femSumReactName, fname)
		femSumReactName[noarch.Strlen(fname)] = '\x00'
		return 0
	}
	return
}

// D_HookIso_planeRaw - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_stf2.c:43
func D_HookIso_planeRaw(E float64, nu float64, Problem int32, D []tMatrix) int32 {
	//
	//   File name: fem_stf2.c
	//   Date:      2003/05/01 17:52
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2003 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//  FEM Solver - material stifness matrix for 2D problems (plane stress/strain)
	//
	//  $Id: fem_stf2.c,v 1.10 2003/10/18 16:45:19 jirka Exp $
	//
	// fem_sbet.c
	var Mul float64
	if nu <= 0 || nu >= 1 {
		noarch.Fprintf(msgout, []byte("[E] %s: %e!\n\x00"), []byte("Invalid Poisson ration\x00"), nu)
		return -3
	}
	switch Problem {
	case 0:
		Mul = E / (1 - nu*nu)
		femMatPutAdd(D, 1, 1, Mul, 0)
		femMatPutAdd(D, 1, 2, Mul*nu, 0)
		femMatPutAdd(D, 2, 1, Mul*nu, 0)
		femMatPutAdd(D, 2, 2, Mul, 0)
		femMatPutAdd(D, 3, 3, Mul*0.5*(1-nu), 0)
	case 1:
		Mul = E / ((1 + nu) * (1 - 2*nu))
		femMatPutAdd(D, 1, 1, Mul*(1-nu), 0)
		femMatPutAdd(D, 1, 2, Mul*nu, 0)
		femMatPutAdd(D, 2, 1, Mul*nu, 0)
		femMatPutAdd(D, 2, 2, Mul*(1-nu), 0)
		femMatPutAdd(D, 3, 3, Mul*0.5*(1-nu), 0)
	default:
		return -5
		break
	}
	femMatPutAdd(D, 1, 3, 0, 0)
	femMatPutAdd(D, 2, 3, 0, 0)
	femMatPutAdd(D, 3, 1, 0, 0)
	return 0
}

// D_PlaneHookIso - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_stf2.c:92
func D_PlaneHookIso(ePos int32, iPoint int32, A float64, epsilon []tVector, newM int32, Problem int32, D []tMatrix) int32 {
	// Creates material stifness matrix for 2D plane stress/strain
	// *  @param Type   type of "D": 0..plane stress, 1..plane strain
	// *  @param D   matrix (must be [4,4] and only indexes 1,2,3 are filled!)
	//
	var E float64
	var nu float64
	E = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	return D_HookIso_planeRaw(E, nu, Problem, D)
}

// D_PlaneOrthoPlain - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_stf2.c:107
func D_PlaneOrthoPlain(ePos int32, iPoint int32, Problem int32, D []tMatrix) int32 {
	// Creates orthotropic material stifness matrix for 2D plane stress/strain
	// *  @param Problem   type of "D": 0..plane stress, 1..plane strain
	// *  @param angle  matrix orientation
	// *  @param D  matrix (must be [4,4] and only indexes 1,2,3 are filled!)
	//
	var rv int32
	var Ex float64
	var Ey float64
	var nuxy float64
	var nuyx float64
	var G float64
	var mult float64
	var angle float64
	var Dc0 tMatrix
	var Dt tMatrix
	var TeT tMatrix
	var Te tMatrix
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		// Allocating of matrix in local coordinates and transformation matrices:
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femMatSetZero((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	femMatSetZero(D)
	Ex = femGetMPValPos(ePos, 2, 0)
	Ey = femGetMPValPos(ePos, 3, 0)
	if Ey < 1e-17 {
		Ey = femGetMPValPos(ePos, 4, 0)
	}
	nuxy = femGetMPValPos(ePos, 21, 0)
	G = femGetMPValPos(ePos, 24, 0)
	angle = femGetMPValPos(ePos, 40, 1)
	nuyx = Ey / Ex * nuxy
	mult = 1 / (1 - nuxy*nuyx)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 1, mult*Ex, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 1, 2, mult*Ex*nuxy, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 1, mult*Ey*nuyx, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 2, 2, mult*Ey, 0)
	femMatPutAdd((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], 3, 3, G, 0)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_ort\x00"))
	// Transformation of Dc0 to global coordinates (Dcr):
	D_Fill_Te((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], (*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], angle)
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], []byte("TE\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], []byte("TET\x00"))
	femMatPrn((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], []byte("D_00\x00"))
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatMatMult((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Te))[:], D)
	femMatPrn(D, []byte("D\x00"))
memFree:
	;
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dc0))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dt))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&TeT))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Te))[:])
	return rv
}

// femGetPrincStress2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_stf2.c:193
func femGetPrincStress2D(sigma_x []tVector, sigma_1 []tVector, phi []float64) int32 {
	// Computes principal stresses in 2D
	// * @param sigma_x xy stresses
	// * @param sigma_1 principal stresses s_1, s_2) - result
	// * @param phi direction of s_1 stress
	// * @return state value
	//
	var rv int32
	var Part1 float64
	var Part2 float64
	var tmpVal float64
	var s_x float64
	var s_y float64
	var s_xy float64
	var s_1 float64
	var s_2 float64
	s_x = femVecGet(sigma_x, 1)
	s_y = femVecGet(sigma_x, 2)
	s_xy = femVecGet(sigma_x, 3)
	Part1 = 0.5 * (s_x + s_y)
	Part2 = 0.5 * math.Sqrt((s_x-s_y)*(s_x-s_y)+4*(s_xy*s_xy))
	s_1 = Part1 + Part2
	s_2 = Part1 - Part2
	if s_2 > s_1 {
		// because s1 > s2
		tmpVal = s_1
		s_1 = s_2
		s_2 = tmpVal
	}
	if s_xy == 0 {
		phi[0] = 0
		if s_x < s_y {
			phi[0] = 90
		}
	} else {
		// tmpVal = ((*phi - s_x)/(s_xy)); ??? WHAT PHI ????
		tmpVal = (s_1 - s_x) / s_xy
		phi[0] = 180 * (math.Atan(tmpVal) / 3.141592653589793)
	}
	femVecPutAdd(sigma_1, 1, s_1, 0)
	femVecPutAdd(sigma_1, 2, s_2, 0)
	femVecPutAdd(sigma_1, 3, phi[0], 0)
	return rv
}

// fem_D_2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_stf2.c:248
func fem_D_2D(ePos int32, iPoint int32, A float64, epsilon []tVector, sigma []tVector, sigma_r []tVector, newM int32, Problem int32, D []tMatrix) int32 {
	// fills (allocated!) D matrix
	// * @param ePos finite element position
	// * @param iPoint finite element (integration) point position
	// * @param A area size
	// * @param epsilon strain vector (NULL if unused)
	// * @param sigma stress vector for newM=AF_YES AND mtype=8 - result (NULL if unused)
	// * @param sigma_r residual stress vector for newM=AF_YES AND mtype=8 - result (NULL if unused)
	// * @param newM mode  AF_YES means changes, AF_NO=previous state
	// * @param Problem 0=plane stress, 1=plane strain
	// * @param D matrix to be filled
	//
	var rv int32
	var mT int32
	mT = mpType[femGetIntPos(ePos, eMP, eLen)]
	switch mT {
	case 1:
		if femGetMPRepNumPos(ePos) > 0 {
			rv = D_Plane_Ortho(femGetMPValPos(ePos, 2, 0), femGetMPValPos(ePos, 2, 1), femGetMPValPos(ePos, 5, 0), 1, 0, D)
		} else {
			// angle !?
			rv = D_PlaneHookIso(ePos, iPoint, A, epsilon, newM, Problem, D)
		}
		if len(sigma) != 0 && newM == 1 {
			femMatVecMult(D, epsilon, sigma)
		}
	case 2:
		rv = D_ConcCrack2D(ePos, iPoint, A, epsilon, newM, Problem, D)
		if len(sigma) != 0 && newM == 1 {
			femMatVecMult(D, epsilon, sigma)
		}
	case 3:
		rv = chen2d_D(ePos, iPoint+1, Problem, epsilon, newM, D)
	case 4:
		rv = fem_vmis_D_2D(ePos, iPoint+1, Problem, epsilon, newM, D)
	case 7:
		fallthrough
	case 11:
		rv = D_PlaneOrthoPlain(ePos, iPoint+1, Problem, D)
	case 8:
		rv = sbet_get_D(ePos, iPoint, A, epsilon, sigma, sigma_r, newM, Problem, D)
	case 9:
		rv = fem_m09_D_2d(ePos, iPoint, A, epsilon, newM, Problem, D)
		if len(sigma) != 0 && newM == 1 {
			femMatVecMult(D, epsilon, sigma)
		}
	default:
		rv = D_PlaneHookIso(ePos, iPoint, A, epsilon, newM, Problem, D)
		if len(sigma) != 0 && newM == 1 {
			femMatVecMult(D, epsilon, sigma)
		}
		break
	}
	return rv
}

// ts_div_main - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:32
//
//   File name: fem_ts.c
//   Date:      2015/09/20 11:57
//   Author:    Jiri Brozovsky
//
//   Copyright (C) 2015 Jiri Brozovsky
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of the
//   License, or (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   in a file called COPYING along with this program; if not, write to
//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
//   02139, USA.
//
//   Rasterisation od 2D f.e. models for use with tensor scale.
//   Element 002 must be used
//
// main division parameter to be controlled bya  program switch:
var ts_div_main int32

// ts_area_x0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:35
// area limits in real coordiantes
var ts_area_x0 float64

// ts_area_y0 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:36
var ts_area_y0 float64

// ts_area_x1 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:37
var ts_area_x1 float64

// ts_area_y1 - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:38
var ts_area_y1 float64

// ts_x_size - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:40
var ts_x_size float64

// ts_y_size - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:41
var ts_y_size float64

// ts_dx - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:43
var ts_dx float64

// ts_dy - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:44
var ts_dy float64

// ts_x_div - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:47
// area limits in integer coordinates:
var ts_x_div int32

// ts_y_div - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:48
var ts_y_div int32

// ts_n_mat - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:50
var ts_n_mat int32

// ts_data - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:53
// area of 0-1-? values:
var ts_data [][]int32

// ts_get_area - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:55
func ts_get_area() {
	var i int32
	var j int32
	var x1 float64
	var y1 float64
	var xmin float64
	var ymin float64
	var xmax float64
	var ymax float64
	// initial data:
	xmin = femGetDblPos(femGetIntLPos(0, 0, eFrom, eNodesL, eLenL), n_x, nLen)
	ymin = femGetDblPos(femGetIntLPos(0, 0, eFrom, eNodesL, eLenL), n_y, nLen)
	xmax = xmin
	ymax = ymin
	{
		// find limits:
		for i = 0; i < eLen; i++ {
			for j = 0; j < 4; j++ {
				x1 = femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_x, nLen)
				y1 = femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_y, nLen)
				if x1 > xmax {
					xmax = x1
				}
				if y1 > ymax {
					ymax = y1
				}
				if x1 < xmin {
					xmin = x1
				}
				if y1 < ymin {
					ymin = y1
				}
			}
		}
	}
	ts_area_x0 = xmin
	ts_area_y0 = ymin
	ts_area_x1 = xmax
	ts_area_y1 = ymax
	ts_x_size = math.Abs(xmax - xmin)
	ts_y_size = math.Abs(ymax - ymin)
	if ts_div_main > 0 {
		ts_x_div = ts_div_main
	} else {
		ts_x_div = 1
	}
	ts_y_div = int32(ts_y_size / ts_x_size * float64(ts_x_div))
	if ts_y_div < 1 {
		ts_y_div = 1
	}
	ts_dx = ts_x_size / float64(ts_x_div)
	ts_dy = ts_y_size / float64(ts_y_div)
	noarch.Printf([]byte("DIV: %i| %ex%e !%ex%e (%ix%i)\n\x00"), ts_div_main, ts_x_size, ts_y_size, ts_dx, ts_dy, ts_x_div, ts_y_div)
}

// ts_prep_data - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:103
func ts_prep_data() int32 {
	// Prepares 2D ts_data field
	var i int32
	var j int32
	ts_data = nil
	if len((func() [][]int32 {
		ts_data = (*[1000000][]int32)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := make([]byte, 1*int32(uint32(ts_y_div)))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		return ts_data
	}())) == 0 {
		ts_data = nil
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("No memory for tensor scale data\x00"))
		return -4
	} else {
		for i = 0; i < ts_x_div; i++ {
			if len((func() []int32 {
				ts_data[i] = (*[1000000]int32)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := make([]byte, 1*int32(uint32(ts_x_div)))
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				return ts_data[i]
			}())) == 0 {
				for j = 0; j < i; j++ {
					_ = ts_data[j]
					ts_data[j] = nil
				}
				_ = ts_data
				ts_data = nil
				return -4
			} else {
				for j = 0; j < ts_x_div; j++ {
					ts_data[i][j] = 0
				}
			}
		}
	}
	return 0
}

// ts_clean_data - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:140
func ts_clean_data() {
	// Prepares 1D ts_data field
	var j int32
	for j = 0; j < ts_y_div; j++ {
		_ = ts_data[j]
		ts_data[j] = nil
	}
	_ = ts_data
	ts_data = nil
}

// ts_tri_test - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:152
func ts_tri_test(px float64, py float64, x []float64, y []float64) int32 {
	// Tests if given point lies inside the triangle:
	var s float64
	var t float64
	var Area float64
	Area = 0.5 * (-y[1]*x[2] + y[0]*(-x[1]+x[2]) + x[0]*(y[1]-y[2]) + x[1]*y[2])
	s = 1 / (2 * Area) * (y[0]*x[2] - x[0]*y[2] + (y[2]-y[0])*px + (x[0]-x[2])*py)
	t = 1 / (2 * Area) * (x[0]*y[1] - y[0]*x[1] + (y[0]-y[1])*px + (x[1]-x[0])*py)
	noarch.Printf([]byte("Area:%e s=%e t=%e\n\x00"), Area, s, t)
	if s > 0 && t > 0 && 1-s-t > 0 {
		return 1
	}
	return 0
}

// ts_raster - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:169
func ts_raster() int32 {
	// Provides a rasterisation of 2D f.e. model. There are some simplifications.
	//
	var i int32
	var j int32
	var k int32
	var x []float64 = make([]float64, 4)
	var y []float64 = make([]float64, 4)
	var x2 []float64 = make([]float64, 4)
	var y2 []float64 = make([]float64, 4)
	var xmax float64
	var xmin float64
	var ymax float64
	var ymin float64
	var px float64
	var py float64
	var ix0 int32
	var ix1 int32
	var iy0 int32
	var iy1 int32
	var mType int32
	ts_n_mat = 2
	for i = 0; i < eLen; i++ {
		mType = femGetIntPos(i, eMP, eLen)
		if mType > ts_n_mat-1 {
			ts_n_mat++
		}
		{
			// first triangle and limits:
			for j = 0; j < 4; j++ {
				x[j] = femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_x, nLen)
				y[j] = femGetDblPos(femGetIntLPos(i, j, eFrom, eNodesL, eLenL), n_y, nLen)
				if j == 0 {
					xmax = x[0]
					xmin = xmax
					ymax = y[0]
					ymin = ymax
				} else {
					if x[j] > xmax {
						xmax = x[j]
					}
					if y[j] > ymax {
						ymax = y[j]
					}
					if x[j] < xmin {
						xmin = x[j]
					}
					if y[j] < ymin {
						ymin = y[j]
					}
				}
			}
		}
		// second triangle
		x2[0] = x[0]
		y2[0] = y[0]
		x2[1] = x[2]
		y2[1] = y[2]
		x2[2] = x[3]
		y2[2] = y[3]
		//for (j=0; j<4; j++) { printf("(%li) [%e, %e] | [%e, %e]\n",i+1,x[j],y[j],x2[j],y2[j]); }
		ix0 = int32((xmin - ts_area_x0) / ts_dx)
		ix1 = int32((xmax - ts_area_x0) / ts_dx)
		iy1 = int32((ymax - ts_area_y0) / ts_dy)
		iy0 = int32((ymin - ts_area_y0) / ts_dy)
		{
			// printf("ZZ %i %i %i %i\n",ix0, ix1,  iy0, iy1);
			for j = 0; j < ix1-ix0; j++ {
				for k = 0; k < iy1-iy0; k++ {
					px = ts_area_x0 + (0.5+float64(k))*ts_dx
					py = ts_area_y1 - (0.5+float64(j))*ts_dy
					if ts_tri_test(px, py, x, y) == 1 || ts_tri_test(px, py, x2, y2) == 1 {
						// printf("Y[%li,%li] x=%e, y=%e\n",k,j, px, py);
						// printf("X [%i,%i]\n",iy1-k,ix0+j);
						ts_data[iy1-k][ix0+j] = mType
					}
				}
			}
		}
	}
	return 0
}

// fem_ts_write - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:245
func fem_ts_write(fw *noarch.File) int32 {
	// Write data to a given file
	//
	var j int32
	var k int32
	noarch.Fprintf(fw, []byte("%e %e\n\x00"), ts_x_size, ts_y_size)
	noarch.Fprintf(fw, []byte("%i %i\n\x00"), ts_x_div, ts_y_div)
	noarch.Fprintf(fw, []byte("%i\n\x00"), ts_n_mat)
	noarch.Fprintf(fw, []byte("8 %e %e\n\x00"), ts_dx*10, ts_dx/4)
	for j = 0; j < ts_y_div; j++ {
		for k = 0; k < ts_x_div; k++ {
			noarch.Fprintf(fw, []byte(" %i\x00"), ts_data[j][k])
		}
		noarch.Fprintf(fw, []byte("\n\x00"))
	}
	return 0
}

// fem_ts_run - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_ts.c:267
func fem_ts_run(fw *noarch.File, div int32) int32 {
	// Prepares and writes tensor scale data
	var rv int32
	ts_div_main = div
	ts_get_area()
	if (func() int32 {
		rv = ts_prep_data()
		return rv
	}()) == 0 {
		if (func() int32 {
			rv = ts_raster()
			return rv
		}()) == 0 {
			rv = fem_ts_write(fw)
		}
	}
	return rv
}

// femCheckTTHstepSize - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_tth.c:77
func femCheckTTHstepSize(d_t float64) int32 {
	//
	//   File name: fem_tth.c
	//   Date:      2012/06/17 21:49
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2012 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   Transient thermal analysis
	//
	// from fem_sol.c:
	// from fem_e010.c:
	// total number of ACTIVE DOFs in structure (== size of "K" matrix)
	// lenght of nDOFfld
	// description of DOFs in nodes
	// numbers of items in "K" rows K_rows[nDOFAct]
	// structure stiffness matrix
	// structure load vector
	// unballanced forces vector
	// structure displacement vector
	// dynamics:
	// mass matrix
	// thermal capacity matrix
	// conductivity matrix
	// prev step load
	// prev step temperatures
	// prev step temperatures
	// combined load
	// Wrapper for linear system solvers
	// * @param Ks stiffness matrix
	// * @param Fs load vector
	// * @param us displacement vector (result)
	// * @return status
	//
	// Filling of results data field (ofld)
	// * @param ofld field to put data in
	// * @return status
	//
	// Checks default size of time steps
	var ePos int32
	var eT int32
	var kxx_num int32
	var char_size float64
	var kxx float64
	var d_comp float64
	var A float64
	var kxx1 float64
	var char_size1 float64
	for ePos = 0; ePos < eLen; ePos++ {
		// element type
		eT = femGetIntPos(ePos, eType, eLen)
		if eT == 18 {
			A = e011_area(ePos)
			kxx1 = femGetMPValPos(ePos, 37, 0)
			if math.Abs(kxx1) > 1e-17 {
				char_size1 = math.Sqrt(A)
				char_size += char_size1
				kxx += kxx1
				kxx_num++
			}
		}
	}
	char_size = char_size / float64(kxx_num)
	kxx = kxx / float64(kxx_num)
	if math.Abs(kxx) < 1e-17 {
		return -3
	}
	d_comp = char_size * char_size / (4 * kxx)
	if d_comp < 1.5*d_t {
		noarch.Fprintf(msgout, []byte("[w] %s (%s: %f, %s: %f)!\n\x00"), []byte("Step size too small\x00"), []byte("ideal\x00"), d_comp, []byte("actual\x00"), d_t)
		return -3
	}
	if d_comp > 1.5*d_t {
		noarch.Fprintf(msgout, []byte("[w] %s (%s: %f, %s: %f)!\n\x00"), []byte("Step size too big\x00"), []byte("ideal\x00"), d_comp, []byte("actual\x00"), d_t)
		return -3
	}
	noarch.Fprintf(msgout, []byte("[i] %s: %f, %s: %f\n\x00"), []byte("Recommended step size\x00"), d_comp, []byte("actual size\x00"), d_t)
	return 0
}

// femSolveThermTrans - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_tth.c:131
func femSolveThermTrans(ofld []float64) int32 {
	// Simple dynamics solver: Newmark time integration procedure is used
	// *
	// * @param ofld random output data filed (only != NULL for Monte Carlo)
	// * @return statis
	//
	var rv int32
	var i int32
	// number of time steps
	var steps int32 = 10
	// time (step lenght)
	var d_t float64 = 1
	// time step ratio
	var tau float64 = 0.5
	// total elapsed time
	var tot_time float64
	// file name for step
	var fnm []byte
	steps = dynNum
	d_t = dynStp
	if (func() int32 {
		rv = femElemTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatTypeInit()
		return rv
	}()) != 0 {
		goto memFree
	}
	// return not checked so far
	femCheckTTHstepSize(d_t)
	fem_sol_null()
	femResNull()
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("data checking and allocations\x00"))
	if (func() int32 {
		rv = fem_dofs()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_alloc()
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_sol_res_alloc()
		return rv
	}()) != 0 {
		// __must__ be done before adding of loads!
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("data checking and allocations done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("assembling of stiffness matrix\x00"))
	if (func() int32 {
		rv = fem_fill_K(0)
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("assembling of stiffness matrix done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("assembling of mass/capacity matrix\x00"))
	if (func() int32 {
		rv = femMatAllocCloneStruct((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAllocCloneStruct((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&KK))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAllocCloneStruct((*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = fem_fill_M()
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("assembling of mass/capacity matrix done\x00"))
	noarch.Fprintf(msgout, []byte("[i]   %s:\n\x00"), []byte("loads and supports\x00"))
	fem_add_loads(1)
	if (func() int32 {
		rv = fem_add_disps(1, 1)
		return rv
	}()) != 0 {
		goto memFree
	}
	noarch.Fprintf(msgout, []byte("[i]   %s.\n\x00"), []byte("loads and supports done\x00"))
	noarch.Fprintf(msgout, []byte("[I] %s:\n\x00"), []byte("Time integration started\x00"))
	// 0th step...
	// clone load to old load vector
	femVecClone((*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
	// clone temperatures to old temperature vector
	femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&r0))[:])
	femVecPrn((*[1000000]tVector)(unsafe.Pointer(&r0))[:], []byte("RR0\x00"))
	for i = 1; i < steps; i++ {
		noarch.Fprintf(msgout, []byte("[I] %s %li / %li:\n\x00"), []byte("Transient step\x00"), i, steps-1)
		if transTS > -1 {
			// substep size:
			d_t = transMult[transTS][i] - transMult[transTS][i-1]
		}
		// loads should be inside loop
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&F))[:])
		femVecSetZeroBig((*[1000000]tVector)(unsafe.Pointer(&u))[:])
		femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
		femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:])
		// new K and M matrices (slowdown):
		femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&K))[:])
		femMatSetZeroBig((*[1000000]tMatrix)(unsafe.Pointer(&M))[:])
		if (func() int32 {
			rv = fem_fill_K(0)
			return rv
		}()) != 0 {
			goto memFree
		}
		if (func() int32 {
			rv = fem_fill_M()
			return rv
		}()) != 0 {
			goto memFree
		}
		fem_add_loads(i + 1)
		if (func() int32 {
			rv = fem_add_disps(1, i+1)
			return rv
		}()) != 0 {
			goto memFree
		}
		// right hand side vector ((F_0*1-tau) + F*tau) = pp0:
		femVecLinComb(1-tau, (*[1000000]tVector)(unsafe.Pointer(&F_0))[:], tau, (*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&pp))[:])
		// right hand side:  pp0+(M/tau - K*(1-tau))*r0
		femMatLinCombClones(1/d_t, (*[1000000]tMatrix)(unsafe.Pointer(&M))[:], -(1 - tau), (*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&C))[:])
		femMatVecMultBig((*[1000000]tMatrix)(unsafe.Pointer(&C))[:], (*[1000000]tVector)(unsafe.Pointer(&r0))[:], (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
		// adds rr0 to pp
		femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&pp))[:], 1, (*[1000000]tVector)(unsafe.Pointer(&rr0))[:])
		// left hand side:  M/tau + K*(tau)
		femMatLinCombClones(1/d_t, (*[1000000]tMatrix)(unsafe.Pointer(&M))[:], tau, (*[1000000]tMatrix)(unsafe.Pointer(&K))[:], (*[1000000]tMatrix)(unsafe.Pointer(&KK))[:])
		if solUseCGSSOR != 1 {
			if (func() int32 {
				rv = femEqsCGwJ((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:], (*[1000000]tVector)(unsafe.Pointer(&pp))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				// equation solution:
				goto memFree
			}
		} else {
			if (func() int32 {
				rv = femEqsCGwSSOR((*[1000000]tMatrix)(unsafe.Pointer(&KK))[:], (*[1000000]tVector)(unsafe.Pointer(&pp))[:], (*[1000000]tVector)(unsafe.Pointer(&u))[:], 1e-17/10000, nDOFAct)
				return rv
			}()) != 0 {
				goto memFree
			}
		}
		// total elapsed time
		tot_time += d_t
		if (func() int32 {
			rv = fem_fill_K(1)
			return rv
		}()) != 0 {
			// results on elements:
			goto memFree
		}
		if len((func() []byte {
			fnm = femSubStepFname(i)
			return fnm
		}())) != 0 {
			// writing of results
			solID = i
			// time data
			solSimNum = tot_time
			if (func() int32 {
				rv = femWriteRes(fnm)
				return rv
			}()) != 0 {
				_ = fnm
				fnm = nil
				goto memFree
			}
			_ = fnm
			fnm = nil
		}
		noarch.Fprintf(msgout, []byte("[i]   %s: %s %f \n\x00"), []byte("Transient step done\x00"), []byte("cummulative time\x00"), tot_time)
		// clone load to old load vector
		femVecClone((*[1000000]tVector)(unsafe.Pointer(&F))[:], (*[1000000]tVector)(unsafe.Pointer(&F_0))[:])
		// clone load to old load vector
		femVecClone((*[1000000]tVector)(unsafe.Pointer(&u))[:], (*[1000000]tVector)(unsafe.Pointer(&r0))[:])
	}
memFree:
	;
	// if running as Monte library then data should be checked here:
	fem_sol_free()
	femDataFree()
	femResFree()
	if rv == 0 {
		noarch.Fprintf(msgout, []byte("[I] %s.\n\x00"), []byte("Solution done\x00"))
	} else {
		noarch.Fprintf(msgout, []byte("[E] %s!\n\x00"), []byte("Solution failed\x00"))
	}
	return rv
}

// retmap_CPA - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:55
func retmap_CPA(ePos int32, e_rep int32, eT int32, mT int32, sigma []tVector, epsilon []tVector, Mode int32, Dep []tMatrix) int32 {
	//
	//   File name: fem_vmis.c
	//   Date:      2004/03/27 13:41
	//   Author:    Jiri Brozovsky
	//
	//   Copyright (C) 2004 Jiri Brozovsky
	//
	//   This program is free software; you can redistribute it and/or
	//   modify it under the terms of the GNU General Public License as
	//   published by the Free Software Foundation; either version 2 of the
	//   License, or (at your option) any later version.
	//
	//   This program is distributed in the hope that it will be useful, but
	//   WITHOUT ANY WARRANTY; without even the implied warranty of
	//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	//   General Public License for more details.
	//
	//   You should have received a copy of the GNU General Public License
	//   in a file called COPYING along with this program; if not, write to
	//   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
	//   02139, USA.
	//
	//   FEM Solver - 3D von Mises plasticity condition
	//
	// from "fem_chen.c":
	// Material status values: 0=linear, 1=plastic, -1=unloading
	// Return mapping procedure: CPA method ("consistent elastoplatic
	// ** modulus")
	// * @param sigma: stress vector (returned with total sigma)
	// * @param epsilon: strain vector (addition from current step)
	// * @param Mode: AF_YES=new state, AF_NO=old
	//
	var rv int32
	var d_dim int32 = 3
	var i int32
	var lambda float64
	var F float64
	var Ex float64
	var nu float64
	var fy float64
	var epsilon_n tVector
	var epsilon_p tVector
	var epsilon_d tVector
	var d_sigma tVector
	var a tVector
	var De tMatrix
	var Dei tMatrix
	if Elem[eT].dim == 3 {
		// check dimensionality of problem:
		// 3D element
		d_dim = 6
	} else {
		if Elem[eT].dim == 2 {
			// wall element
			d_dim = 3
		} else {
			noarch.Fprintf(msgout, []byte("[E] %s: %li!\n\x00"), []byte("Return mapping - bad dimension for element\x00"), ePos)
			return -3
		}
	}
	// sed lambda to zero
	lambda = 0
	femVecSetZero(sigma)
	// TODO: allocate sigma, epsilon vectors
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&epsilon_d))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&a))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&Dei))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 0, d_dim, d_dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 0, d_dim, d_dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&epsilon_d))[:], 0, d_dim, d_dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], 0, d_dim, d_dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&a))[:], 0, d_dim, d_dim)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], 0, d_dim, d_dim, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&Dei))[:], 0, d_dim, d_dim, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	fy = femGetMPValPos(ePos, 12, 0)
	switch d_dim {
	case 3:
		// get previous PLASTIC and TOTAL strain and set De:
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 1, femGetRepVal(ePos, 73, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 2, femGetRepVal(ePos, 74, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 3, femGetRepVal(ePos, 76, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 1, femGetRepVal(ePos, 13, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 2, femGetRepVal(ePos, 14, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 3, femGetRepVal(ePos, 16, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		// hardcoded plane stress !
		D_HookIso_planeRaw(Ex, nu, 0, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	case 6:
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 1, femGetRepVal(ePos, 73, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 2, femGetRepVal(ePos, 74, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 3, femGetRepVal(ePos, 75, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 4, femGetRepVal(ePos, 77, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 5, femGetRepVal(ePos, 78, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 6, femGetRepVal(ePos, 76, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 1, femGetRepVal(ePos, 13, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 2, femGetRepVal(ePos, 14, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 3, femGetRepVal(ePos, 15, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 4, femGetRepVal(ePos, 17, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 5, femGetRepVal(ePos, 18, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 6, femGetRepVal(ePos, 16, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
		femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		break
	}
	// make inversion of De:
	femMatCloneDiffToEmpty((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], (*[1000000]tMatrix)(unsafe.Pointer(&Dei))[:])
	femLUinverse((*[1000000]tMatrix)(unsafe.Pointer(&Dei))[:])
	// total initial epsilon (n+1):
	femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], 1, epsilon)
	// initial elastic stress:
	femVecLinComb(1, (*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_d))[:])
	// initial sigma:
	femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], (*[1000000]tVector)(unsafe.Pointer(&epsilon_d))[:], sigma)
	{
		// iteration loop:
		for i = 0; i < 100; i++ {
			if (func() float64 {
				F = 3*stress3D_J2dev(sigma) - fy*fy
				return F
			}()) < 1e-17 {
				// check plasticity condition:
				// we are done
				break
			}
			switch d_dim {
			case 3:
				// compute lambda:
				// check what "alpha=0.0" does!
				vmis_deriv2D((*[1000000]tVector)(unsafe.Pointer(&a))[:], sigma, 1, 0)
			case 6:
				vmis_deriv((*[1000000]tVector)(unsafe.Pointer(&a))[:], sigma, 1, 0)
				break
			}
			lambda = femVecMatVecMult((*[1000000]tVector)(unsafe.Pointer(&a))[:], (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], (*[1000000]tVector)(unsafe.Pointer(&a))[:])
			if lambda >= 1e-17 {
				lambda = F / lambda
			} else {
				rv = -13
				goto memFree
			}
			// compute d_sigma:
			femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], (*[1000000]tVector)(unsafe.Pointer(&a))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
			femValVecMultSelf(-1*lambda, (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
			// compute new epsilon_p:
			// using "a" as mid-product!
			femMatVecMult((*[1000000]tMatrix)(unsafe.Pointer(&Dei))[:], (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:], (*[1000000]tVector)(unsafe.Pointer(&a))[:])
			femVecAddVec((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], -1, (*[1000000]tVector)(unsafe.Pointer(&a))[:])
			// compute total sigma:
			femVecAddVec(sigma, 1, (*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
		}
	}
	switch d_dim {
	case 3:
		// end "for i"
		// TODO write plastic stress !
		femAddPutRepVal(ePos, 73, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 1))
		femAddPutRepVal(ePos, 74, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 2))
		femAddPutRepVal(ePos, 76, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 3))
	case 6:
		femAddPutRepVal(ePos, 73, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 1))
		femAddPutRepVal(ePos, 74, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 2))
		femAddPutRepVal(ePos, 75, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 3))
		femAddPutRepVal(ePos, 77, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 4))
		femAddPutRepVal(ePos, 78, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 5))
		femAddPutRepVal(ePos, 76, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, femVecGet((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:], 6))
		break
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_n))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_p))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&epsilon_d))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&d_sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&a))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&Dei))[:])
	return rv
}

// vmis_deriv - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:228
func vmis_deriv(deriv []tVector, stress []tVector, type_ int32, alpha float64) int32 {
	// elasticity condition derivatives:
	var s_x float64
	var s_y float64
	var s_z float64
	var s_q float64
	var t_xy float64
	var t_yz float64
	var t_zx float64
	var mult float64
	var mult1 float64
	var J2 float64
	s_q = (femVecGet(stress, 1) + femVecGet(stress, 2) + femVecGet(stress, 3)) / 3
	s_x = femVecGet(stress, 1) - s_q
	s_y = femVecGet(stress, 2) - s_q
	s_z = femVecGet(stress, 3) - s_q
	t_yz = femVecGet(stress, 4)
	t_zx = femVecGet(stress, 5)
	t_xy = femVecGet(stress, 6)
	J2 = 0.5*(s_x*s_x+s_y*s_y+s_z*s_z) + t_xy*t_xy + t_yz*t_yz + t_zx*t_zx
	if type_ == 1 {
		// von mises
		mult = math.Sqrt(3) / (2 * math.Sqrt(J2))
		mult1 = 0
	} else {
		// drucker-prager
		mult = 1 / (2 * math.Sqrt(J2))
		mult1 = 1
	}
	femVecPutAdd(deriv, 1, alpha*mult1+mult*s_x, 0)
	femVecPutAdd(deriv, 2, alpha*mult1+mult*s_y, 0)
	femVecPutAdd(deriv, 3, alpha*mult1+mult*s_z, 0)
	femVecPutAdd(deriv, 4, mult*(2*t_yz), 0)
	femVecPutAdd(deriv, 5, mult*(2*t_zx), 0)
	femVecPutAdd(deriv, 6, mult*(2*t_xy), 0)
	return 0
}

// compute_sigma_e - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:264
func compute_sigma_e(sigma []tVector) float64 {
	return math.Sqrt(0.5 * (math.Pow(femVecGet(sigma, 1)-femVecGet(sigma, 2), 2) + math.Pow(femVecGet(sigma, 2)-femVecGet(sigma, 3), 2) + math.Pow(femVecGet(sigma, 3)-femVecGet(sigma, 1), 2) + 6*(math.Pow(femVecGet(sigma, 4), 2)+math.Pow(femVecGet(sigma, 5), 2)+math.Pow(femVecGet(sigma, 6), 2))))
}

// fem_vmis_D_3D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:279
func fem_vmis_D_3D(ePos int32, e_rep int32, eT int32, mT int32, sigma []tVector, epsilon []tVector, Mode int32, Dep []tMatrix) int32 {
	// von Mises elastoplastic matrix
	var rv int32
	var state int32
	var Ex float64
	var E1 float64
	var nu float64
	var fy float64
	var n float64
	var k float64
	var s_eqv2 float64
	var f float64
	var cohes float64
	var frict float64
	var H float64
	var deriv tVector
	var old_sigma tVector
	var De tMatrix
	var type_ int32 = 1
	var alpha float64
	var kk float64
	var prev float64
	var i int32
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 0, 6, 6)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], 0, 6, 6, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 1, femGetRepVal(ePos, 7, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 2, femGetRepVal(ePos, 8, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 3, femGetRepVal(ePos, 9, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 4, femGetRepVal(ePos, 11, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 5, femGetRepVal(ePos, 12, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 6, femGetRepVal(ePos, 10, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	state = int32(femGetRepVal(ePos, 37, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	H = femGetRepVal(ePos, 38, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	fy = femGetMPValPos(ePos, 12, 0)
	E1 = femGetMPValPos(ePos, 20, 0)
	if math.Abs(fy) > 1e-17 {
		type_ = 1
	} else {
		type_ = 0
		cohes = femGetMPValPos(ePos, 18, 0)
		frict = femGetMPValPos(ePos, 19, 0)
		alpha = 2 * math.Sin(frict) / (math.Sqrt(3) * (3 - math.Sin(frict)))
		kk = 6 * cohes * math.Cos(frict) / (math.Sqrt(3) * (3 - math.Sin(frict)))
	}
	if E1 <= 1e-17 {
		n = femGetMPValPos(ePos, 31, 0)
		k = femGetMPValPos(ePos, 30, 0)
		E1 = 0
	} else {
		k = 0
		n = 0
	}
	if state < 1 || E1 == Ex {
		// linear solution
		return femD_3D_iso(ePos, Ex, nu, Dep)
	} else {
		femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		vmis_deriv((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], type_, alpha)
		chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
	}
	if Mode == 1 {
		if E1 == Ex {
			// linear solution
			femD_3D_iso(ePos, Ex, nu, Dep)
		} else {
			femD_3D_iso(ePos, Ex, nu, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
			femMatVecMult(Dep, epsilon, sigma)
			for i = 1; i <= 6; i++ {
				femVecPutAdd(sigma, i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], i), 1)
			}
			if type_ == 1 {
				s_eqv2 = 3 * stress3D_J2dev(sigma)
				prev = 3 * stress3D_J2dev((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
				f = s_eqv2 - fy*fy
			} else {
				s_eqv2 = alpha*stress3D_I1(sigma) + stress3D_J2dev(sigma)
				prev = alpha*stress3D_I1((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:]) + stress3D_J2dev((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
				f = s_eqv2 - kk
			}
			if state == 0 {
				if f <= 0 {
					// still elastic
					// continues to be elastic
					state = 0
				} else {
					// yields
					state = 1
				}
			} else {
				if s_eqv2 < prev {
					// unloading
					state = -1
				} else {
					// plastic
					state = 1
				}
			}
			switch state {
			case 1:
				// new matrix computation:
				// plastic
				H = fem_plast_H_linear(ePos, Ex, E1, fy, compute_sigma_e((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:]))
				// works better with old_sigma !?
				vmis_deriv((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], type_, alpha)
				chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
			case 0:
				fallthrough
			case -1:
				fallthrough
			default:
				// elastic
				// plastic unloading
				// error
				femD_3D_iso(ePos, Ex, nu, Dep)
				break
			}
			femAddPutRepVal(ePos, 37, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(state))
			femAddPutRepVal(ePos, 38, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, H)
		}
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	return rv
}

// vmis_deriv2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:444
func vmis_deriv2D(deriv []tVector, stress []tVector, type_ int32, alpha float64) int32 {
	// 2D VERSION OF VON MISES ***************************
	// elasticity condition derivatives:
	var s_x float64
	var s_y float64
	var t_xy float64
	var s_q float64
	var J2 float64
	var mult float64
	var mult1 float64
	s_q = (femVecGet(stress, 1) + femVecGet(stress, 2)) / 3
	s_x = femVecGet(stress, 1) - s_q
	s_y = femVecGet(stress, 2) - s_q
	t_xy = femVecGet(stress, 3)
	J2 = 0.5*(s_x*s_x+s_y*s_y) + t_xy*t_xy
	if type_ == 1 {
		// von mises
		mult = math.Sqrt(3) / (2 * math.Sqrt(J2))
		mult1 = 0
	} else {
		// drucker-prager
		mult = 1 / (2 * math.Sqrt(J2))
		mult1 = 1
	}
	femVecPutAdd(deriv, 1, alpha*mult1+mult*s_x, 0)
	femVecPutAdd(deriv, 2, alpha*mult1+mult*s_y, 0)
	femVecPutAdd(deriv, 3, mult*(2*t_xy), 0)
	return 0
}

// sigma_vmis2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:473
func sigma_vmis2D(sigma []tVector) float64 {
	var sx float64
	var sy float64
	var sxy float64
	sx = femVecGet(sigma, 1)
	sy = femVecGet(sigma, 2)
	sxy = femVecGet(sigma, 3)
	return math.Sqrt(sx*sx + sy*sy - sx*sy + 3*sxy*sxy)
}

// fem_vmis_D_2D - transpiled function from  GOPATH/src/github.com/Konstantin8105/TranspileUfem/ufem/fem/fem_vmis.c:485
func fem_vmis_D_2D(ePos int32, e_rep int32, Problem int32, epsilon []tVector, Mode int32, Dep []tMatrix) int32 {
	// von Mises elastoplastic matrix
	var rv int32
	var state int32
	var Ex float64
	var E1 float64
	var nu float64
	var fy float64
	var f float64
	var H float64
	var cohes float64
	var frict float64
	var k float64
	var n float64
	var s_eqv2 float64
	var deriv tVector
	var sigma tVector
	var old_sigma tVector
	var De tMatrix
	var type_ int32 = 1
	var alpha float64
	var kk float64
	var prev float64
	var i int32
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femVecNull((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femMatNull((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femVecAlloc((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 0, 3, 3)
		return rv
	}()) != 0 {
		goto memFree
	}
	if (func() int32 {
		rv = femMatAlloc((*[1000000]tMatrix)(unsafe.Pointer(&De))[:], 0, 3, 3, 0, nil)
		return rv
	}()) != 0 {
		goto memFree
	}
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 1, femGetRepVal(ePos, 7, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 2, femGetRepVal(ePos, 8, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], 3, femGetRepVal(ePos, 10, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp), 0)
	state = int32(femGetRepVal(ePos, 63, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp))
	H = femGetRepVal(ePos, 64, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp)
	Ex = femGetMPValPos(ePos, 2, 0)
	nu = femGetMPValPos(ePos, 5, 0)
	fy = femGetMPValPos(ePos, 12, 0)
	E1 = femGetMPValPos(ePos, 20, 0)
	if math.Abs(fy) > 1e-17 {
		type_ = 1
	} else {
		type_ = 0
		cohes = femGetMPValPos(ePos, 18, 0)
		frict = femGetMPValPos(ePos, 19, 0)
		alpha = 2 * math.Sin(frict) / (math.Sqrt(3) * (3 - math.Sin(frict)))
		kk = 6 * cohes * math.Cos(frict) / (math.Sqrt(3) * (3 - math.Sin(frict)))
	}
	if E1 <= 1e-17 {
		n = femGetMPValPos(ePos, 31, 0)
		k = femGetMPValPos(ePos, 30, 0)
		E1 = 0
	} else {
		k = 0
		n = 0
	}
	if state < 1 || E1 == Ex {
		D_HookIso_planeRaw(Ex, nu, Problem, Dep)
	} else {
		D_HookIso_planeRaw(Ex, nu, Problem, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
		vmis_deriv2D((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], type_, alpha)
		// should work in 2D, too
		chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
	}
	if Mode == 1 {
		if E1 == Ex {
			// NEW matrix:
			// linear solution
			D_HookIso_planeRaw(Ex, nu, Problem, Dep)
		} else {
			D_HookIso_planeRaw(Ex, nu, Problem, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
			femMatVecMult(Dep, epsilon, (*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
			for i = 1; i <= 3; i++ {
				femVecPutAdd((*[1000000]tVector)(unsafe.Pointer(&sigma))[:], i, femVecGet((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], i), 1)
			}
			if type_ == 1 {
				s_eqv2 = 3 * stress2D_J2dev((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
				prev = 3 * stress2D_J2dev((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
				f = s_eqv2 - fy*fy
			} else {
				s_eqv2 = alpha*stress2D_I1((*[1000000]tVector)(unsafe.Pointer(&sigma))[:]) + stress2D_J2dev((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
				prev = alpha*stress2D_I1((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:]) + stress2D_J2dev((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
				f = s_eqv2 - kk
			}
			if state == 0 {
				if f <= 0 {
					// still elastic
					// continues to be elastic
					state = 0
				} else {
					// yields
					state = 1
				}
			} else {
				if s_eqv2 < prev {
					// unloading
					state = -1
				} else {
					// plastic
					state = 1
				}
			}
			switch state {
			case 1:
				// new matrix computation:
				// plastic
				H = fem_plast_H_linear(ePos, Ex, E1, fy, sigma_vmis2D((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:]))
				// works better with old_sigma !?
				vmis_deriv2D((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], (*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:], type_, alpha)
				chen_Dep((*[1000000]tVector)(unsafe.Pointer(&deriv))[:], H, (*[1000000]tMatrix)(unsafe.Pointer(&De))[:], Dep)
			case 0:
				fallthrough
			case -1:
				fallthrough
			default:
				// elastic
				// plastic unloading
				// error
				D_HookIso_planeRaw(Ex, nu, Problem, Dep)
				break
			}
			femAddPutRepVal(ePos, 63, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, float64(state))
			femAddPutRepVal(ePos, 64, e_rep, resEVal, resELen, resEFrom, eLen, Elem[eType[ePos]].nres, Elem[eType[ePos]].res, Elem[eType[ePos]].nres_rp, Elem[eType[ePos]].res_rp, 0, H)
		}
	}
memFree:
	;
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&deriv))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&old_sigma))[:])
	femVecFree((*[1000000]tVector)(unsafe.Pointer(&sigma))[:])
	femMatFree((*[1000000]tMatrix)(unsafe.Pointer(&De))[:])
	return rv
}

// c4goUnsafeConvert_byte : created by c4go
func c4goUnsafeConvert_byte(c4go_name *byte) []byte {
	return (*[1000000]byte)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_float64 : created by c4go
func c4goUnsafeConvert_float64(c4go_name *float64) []float64 {
	return (*[1000000]float64)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_int32 : created by c4go
func c4goUnsafeConvert_int32(c4go_name *int32) []int32 {
	return (*[1000000]int32)(unsafe.Pointer(c4go_name))[:]
}

// end of fem_e001.c
// end of fem_e005.c
// end of fem_e001.c
// end of fem_spnt.c
// end of fem_od3d.c
// end of fem_pr3d.c
// end of fem_dp.c
// end of fem_e003.c
// end of fem_e011.c
// end of fem_e003.c
// end of fem_e021.c
// end of fem_nrm.c
// end of fem_e006.c
// end of fem_e000.c
// end of fem_e005.c
// end of fem_tth.c
// Writes SILO (MeshTV/VisIt) file
//
// end of fem_spio.c
// material type number
// list of properties (val[num])
// number of properties
// list of REPEATING properties (val[num])
// number of REPEATING properties
// material definition test
// definitions of data structures
// elements
// number of elements
// functions
// end of fem_elem.h
// end of fem_data.c
// end of fem_e016.c
// end of fem_e009.c
// end of fem_eini.c
// end of fem_soil.c
// end of fem_dama.c
// end of fem_e004.c
// end of fem_hard.c
// end of fem_mat.c
// end of fem_mont.c
// end of fem_e007.c
// end of fem_e002.c
// end of fem_e009.c
// end of fem_nols.c
// end of fem_pl1d.c
// end of fem_asse.c
// end of fem_io.c
// end of fem_m006.c
// load multiplier
// x displacement
// y displacement
// z displacement
// filename
// node number
// lenght of femSaPo
// actual item in femSaPo
// structure for saving of data in _ONE_ selected point
// filename for reactions
// use stdout?
// end of fem_spnt.h
// end of fem_alm.c
// end of fem_e009.c
// end of fem_e015.c
// end of fem_eige.c
// end of fem_eini.c
// end of fem_e019.c
// end of fem_m004.c
// end of fem_pl3d.c
// end of fem_e022.c
// end of fem_eqs.c
// end of fem_sb1d.c
// end of fem_e014.c
// end of fem_e017.c
// end of fem_e018.c
// end of fem_e011.c
// end of fem_sbet.c
// 0 = dense; 1 = sparse (rows)
// lenght of "pos" and "data" (if used) fields
// Functions:
// Use with care:  (!!)
// end of fem_math.h
// end of fem_e009.c
// end of fem_m003.c
// end of fem_mrun.c
// end of fem_sol.c
// end of fem_stf2.c
// end of fem_accs.c
// end of fem_ccr3.c
// end of fem_loads.c
// end of fem_e008.c
// end of fem_ccr2.c
// end of fem_e000.c
// end of fem_mem.c
// end of fem_pric.c
// end of fem_vmis.c
// end of fem_ch2d.c
// end of fem_chen.c
// end of fem_e008.c
// end of fem_e008.c
// end of fem_e002.c
// end of fem_e007.c
// end of fem_para.c
// end of fem_sber.c
// end of fem_elem.h
// element type number
// dimensionality: 1..link/2..wall/3..3D/4..slab,shell/5..beam
// number of nodes
// number of degrees of freedom in one node
// list of DOFs in each node (ndof[nodes])
// number of real set values
// list of real set values (real[rs])
// number of REPEATING real set values
// list of REPEATING real set values (real_rp[rs_rp])
// number of results
// list of results nres[res]
// number of REPEATING results
// list of REPEATING results nres_rp[res_rp]
// element stifness matrix (position,mode,nodal forces,FE,residual)
// element stifness matrix (position,mode,nodal forces,FE,residual)
// element mass matrix (position)
// number of element results (position)
// element load usage (elem. position, load pos.)
// x,y,z of element result point
// element pos, node pos, result type, value(returned)
// element pos, volume(returned)
// definitions of data structures
// elements
// number of elements
// functions
// end of fem_elem.h
// end of fem.c
// end of fem_e002.c
// end of fem_math.c
// end of fem_mloc.c
// end of fem_newm.c
// end of fem_ts.c

// chen_limit_test - add c-binding for implemention function
func chen_limit_test(arg0 []tVector, arg1 float64, arg2 float64, arg3 float64, arg4 []int32) int32 {
	return int32(C.chen_limit_test((*C.tVector)(unsafe.Pointer(&arg0[0])), C.double(arg1), C.double(arg2), C.double(arg3), (*C.int)(unsafe.Pointer(&arg4[0]))))
}
